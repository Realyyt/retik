import {
  require_events
} from "./chunk-HK67DIC5.js";
import {
  AccountController,
  ApiController,
  AssetController,
  AssetUtil,
  BlockchainApiController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  CoreHelperUtil,
  EventsController,
  ModalController,
  NetworkController,
  OptionsController,
  PublicStateController,
  RouterController,
  SIWEController,
  SnackController,
  StorageUtil,
  ThemeController,
  TransactionsController,
  proxy,
  ref,
  subscribe,
  subscribeKey
} from "./chunk-3PPZTXNY.js";
import {
  DateUtil,
  LitElement,
  TransactionUtil,
  UiHelperUtil,
  css,
  customElement,
  html,
  ifDefined,
  property,
  setColorTheme,
  setThemeVariables,
  state
} from "./chunk-YPIQHHR7.js";
import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-W7S2ME4R.js";

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a4, b6) {
      var ah = a4 >>> 16 & 65535, al = a4 & 65535;
      var bh = b6 >>> 16 & 65535, bl = b6 & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add3(a4, b6) {
      return a4 + b6 | 0;
    }
    exports.add = add3;
    function sub(a4, b6) {
      return a4 - b6 | 0;
    }
    exports.sub = sub;
    function rotl(x5, n3) {
      return x5 << n3 | x5 >>> 32 - n3;
    }
    exports.rotl = rotl;
    function rotr(x5, n3) {
      return x5 << 32 - n3 | x5 >>> n3;
    }
    exports.rotr = rotr;
    function isIntegerShim(n3) {
      return typeof n3 === "number" && isFinite(n3) && Math.floor(n3) === n3;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n3) {
      return exports.isInteger(n3) && (n3 >= -exports.MAX_SAFE_INTEGER && n3 <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 0] << 8 | array2[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 0] << 8 | array2[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 1] << 8 | array2[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 1] << 8 | array2[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array2[offset + 3] << 24 | array2[offset + 2] << 16 | array2[offset + 1] << 8 | array2[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 3] << 24 | array2[offset + 2] << 16 | array2[offset + 1] << 8 | array2[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array2, offset);
      var lo = readInt32BE(array2, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array2, offset);
      var lo = readUint32BE(array2, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array2, offset);
      var hi = readInt32LE(array2, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array2, offset);
      var hi = readUint32LE(array2, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array2.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul3 = 1;
      for (var i4 = bitLength / 8 + offset - 1; i4 >= offset; i4--) {
        result += array2[i4] * mul3;
        mul3 *= 256;
      }
      return result;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array2.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul3 = 1;
      for (var i4 = offset; i4 < offset + bitLength / 8; i4++) {
        result += array2[i4] * mul3;
        mul3 *= 256;
      }
      return result;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i4 = bitLength / 8 + offset - 1; i4 >= offset; i4--) {
        out[i4] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i4 = offset; i4 < offset + bitLength / 8; i4++) {
        out[i4] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array2) {
      for (var i4 = 0; i4 < array2.length; i4++) {
        array2[i4] = 0;
      }
      return array2;
    }
    exports.wipe = wipe;
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key2) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j22 = 2036477234;
      var j32 = 1797285236;
      var j42 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
      var j52 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
      var j62 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
      var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
      var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
      var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
      var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
      var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x22 = j22;
      var x32 = j32;
      var x42 = j42;
      var x5 = j52;
      var x6 = j62;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i4 = 0; i4 < ROUNDS; i4 += 2) {
        x0 = x0 + x42 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x42 ^= x8;
        x42 = x42 >>> 32 - 12 | x42 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x22 = x22 + x6 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x32 = x32 + x7 | 0;
        x15 ^= x32;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x22 = x22 + x6 | 0;
        x14 ^= x22;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x32 = x32 + x7 | 0;
        x15 ^= x32;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x42 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x42 ^= x8;
        x42 = x42 >>> 32 - 7 | x42 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x22 = x22 + x7 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x32 = x32 + x42 | 0;
        x14 ^= x32;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x42 ^= x9;
        x42 = x42 >>> 32 - 12 | x42 << 12;
        x22 = x22 + x7 | 0;
        x13 ^= x22;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x32 = x32 + x42 | 0;
        x14 ^= x32;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x42 ^= x9;
        x42 = x42 >>> 32 - 7 | x42 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x22 + j22 | 0, out, 8);
      binary_1.writeUint32LE(x32 + j32 | 0, out, 12);
      binary_1.writeUint32LE(x42 + j42 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j52 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j62 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key2, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key2.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i4 = 0; i4 < src2.length; i4 += 64) {
        core(block, nc, key2);
        for (var j7 = i4; j7 < i4 + 64 && j7 < src2.length; j7++) {
          dst[j7] = src2[j7] ^ block[j7 - i4];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports.streamXOR = streamXOR;
    function stream(key2, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key2, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports.select = select;
    function lessOrEqual(a4, b6) {
      return (a4 | 0) - (b6 | 0) - 1 >>> 31 & 1;
    }
    exports.lessOrEqual = lessOrEqual;
    function compare2(a4, b6) {
      if (a4.length !== b6.length) {
        return 0;
      }
      var result = 0;
      for (var i4 = 0; i4 < a4.length; i4++) {
        result |= a4[i4] ^ b6[i4];
      }
      return 1 & result - 1 >>> 8;
    }
    exports.compare = compare2;
    function equal(a4, b6) {
      if (a4.length === 0 || b6.length === 0) {
        return false;
      }
      return compare2(a4, b6) !== 0;
    }
    exports.equal = equal;
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 16;
    var Poly1305 = (
      /** @class */
      function() {
        function Poly13052(key2) {
          this.digestLength = exports.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t0 = key2[0] | key2[1] << 8;
          this._r[0] = t0 & 8191;
          var t1 = key2[2] | key2[3] << 8;
          this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          var t22 = key2[4] | key2[5] << 8;
          this._r[2] = (t1 >>> 10 | t22 << 6) & 7939;
          var t3 = key2[6] | key2[7] << 8;
          this._r[3] = (t22 >>> 7 | t3 << 9) & 8191;
          var t4 = key2[8] | key2[9] << 8;
          this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this._r[5] = t4 >>> 1 & 8190;
          var t5 = key2[10] | key2[11] << 8;
          this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = key2[12] | key2[13] << 8;
          this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          var t7 = key2[14] | key2[15] << 8;
          this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this._r[9] = t7 >>> 5 & 127;
          this._pad[0] = key2[16] | key2[17] << 8;
          this._pad[1] = key2[18] | key2[19] << 8;
          this._pad[2] = key2[20] | key2[21] << 8;
          this._pad[3] = key2[22] | key2[23] << 8;
          this._pad[4] = key2[24] | key2[25] << 8;
          this._pad[5] = key2[26] | key2[27] << 8;
          this._pad[6] = key2[28] | key2[29] << 8;
          this._pad[7] = key2[30] | key2[31] << 8;
        }
        Poly13052.prototype._blocks = function(m5, mpos, bytes) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h42 = this._h[4], h52 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
          var r0 = this._r[0], r1 = this._r[1], r22 = this._r[2], r32 = this._r[3], r42 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes >= 16) {
            var t0 = m5[mpos + 0] | m5[mpos + 1] << 8;
            h0 += t0 & 8191;
            var t1 = m5[mpos + 2] | m5[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            var t22 = m5[mpos + 4] | m5[mpos + 5] << 8;
            h22 += (t1 >>> 10 | t22 << 6) & 8191;
            var t3 = m5[mpos + 6] | m5[mpos + 7] << 8;
            h32 += (t22 >>> 7 | t3 << 9) & 8191;
            var t4 = m5[mpos + 8] | m5[mpos + 9] << 8;
            h42 += (t3 >>> 4 | t4 << 12) & 8191;
            h52 += t4 >>> 1 & 8191;
            var t5 = m5[mpos + 10] | m5[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            var t6 = m5[mpos + 12] | m5[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            var t7 = m5[mpos + 14] | m5[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            var c5 = 0;
            var d0 = c5;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h22 * (5 * r8);
            d0 += h32 * (5 * r7);
            d0 += h42 * (5 * r6);
            c5 = d0 >>> 13;
            d0 &= 8191;
            d0 += h52 * (5 * r5);
            d0 += h6 * (5 * r42);
            d0 += h7 * (5 * r32);
            d0 += h8 * (5 * r22);
            d0 += h9 * (5 * r1);
            c5 += d0 >>> 13;
            d0 &= 8191;
            var d1 = c5;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h22 * (5 * r9);
            d1 += h32 * (5 * r8);
            d1 += h42 * (5 * r7);
            c5 = d1 >>> 13;
            d1 &= 8191;
            d1 += h52 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r42);
            d1 += h8 * (5 * r32);
            d1 += h9 * (5 * r22);
            c5 += d1 >>> 13;
            d1 &= 8191;
            var d22 = c5;
            d22 += h0 * r22;
            d22 += h1 * r1;
            d22 += h22 * r0;
            d22 += h32 * (5 * r9);
            d22 += h42 * (5 * r8);
            c5 = d22 >>> 13;
            d22 &= 8191;
            d22 += h52 * (5 * r7);
            d22 += h6 * (5 * r6);
            d22 += h7 * (5 * r5);
            d22 += h8 * (5 * r42);
            d22 += h9 * (5 * r32);
            c5 += d22 >>> 13;
            d22 &= 8191;
            var d32 = c5;
            d32 += h0 * r32;
            d32 += h1 * r22;
            d32 += h22 * r1;
            d32 += h32 * r0;
            d32 += h42 * (5 * r9);
            c5 = d32 >>> 13;
            d32 &= 8191;
            d32 += h52 * (5 * r8);
            d32 += h6 * (5 * r7);
            d32 += h7 * (5 * r6);
            d32 += h8 * (5 * r5);
            d32 += h9 * (5 * r42);
            c5 += d32 >>> 13;
            d32 &= 8191;
            var d4 = c5;
            d4 += h0 * r42;
            d4 += h1 * r32;
            d4 += h22 * r22;
            d4 += h32 * r1;
            d4 += h42 * r0;
            c5 = d4 >>> 13;
            d4 &= 8191;
            d4 += h52 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c5 += d4 >>> 13;
            d4 &= 8191;
            var d5 = c5;
            d5 += h0 * r5;
            d5 += h1 * r42;
            d5 += h22 * r32;
            d5 += h32 * r22;
            d5 += h42 * r1;
            c5 = d5 >>> 13;
            d5 &= 8191;
            d5 += h52 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c5 += d5 >>> 13;
            d5 &= 8191;
            var d6 = c5;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h22 * r42;
            d6 += h32 * r32;
            d6 += h42 * r22;
            c5 = d6 >>> 13;
            d6 &= 8191;
            d6 += h52 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c5 += d6 >>> 13;
            d6 &= 8191;
            var d7 = c5;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h22 * r5;
            d7 += h32 * r42;
            d7 += h42 * r32;
            c5 = d7 >>> 13;
            d7 &= 8191;
            d7 += h52 * r22;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c5 += d7 >>> 13;
            d7 &= 8191;
            var d8 = c5;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h22 * r6;
            d8 += h32 * r5;
            d8 += h42 * r42;
            c5 = d8 >>> 13;
            d8 &= 8191;
            d8 += h52 * r32;
            d8 += h6 * r22;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c5 += d8 >>> 13;
            d8 &= 8191;
            var d9 = c5;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h22 * r7;
            d9 += h32 * r6;
            d9 += h42 * r5;
            c5 = d9 >>> 13;
            d9 &= 8191;
            d9 += h52 * r42;
            d9 += h6 * r32;
            d9 += h7 * r22;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c5 += d9 >>> 13;
            d9 &= 8191;
            c5 = (c5 << 2) + c5 | 0;
            c5 = c5 + d0 | 0;
            d0 = c5 & 8191;
            c5 = c5 >>> 13;
            d1 += c5;
            h0 = d0;
            h1 = d1;
            h22 = d22;
            h32 = d32;
            h42 = d4;
            h52 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h22;
          this._h[3] = h32;
          this._h[4] = h42;
          this._h[5] = h52;
          this._h[6] = h6;
          this._h[7] = h7;
          this._h[8] = h8;
          this._h[9] = h9;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g7 = new Uint16Array(10);
          var c5;
          var mask2;
          var f5;
          var i4;
          if (this._leftover) {
            i4 = this._leftover;
            this._buffer[i4++] = 1;
            for (; i4 < 16; i4++) {
              this._buffer[i4] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c5 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i4 = 2; i4 < 10; i4++) {
            this._h[i4] += c5;
            c5 = this._h[i4] >>> 13;
            this._h[i4] &= 8191;
          }
          this._h[0] += c5 * 5;
          c5 = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c5;
          c5 = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c5;
          g7[0] = this._h[0] + 5;
          c5 = g7[0] >>> 13;
          g7[0] &= 8191;
          for (i4 = 1; i4 < 10; i4++) {
            g7[i4] = this._h[i4] + c5;
            c5 = g7[i4] >>> 13;
            g7[i4] &= 8191;
          }
          g7[9] -= 1 << 13;
          mask2 = (c5 ^ 1) - 1;
          for (i4 = 0; i4 < 10; i4++) {
            g7[i4] &= mask2;
          }
          mask2 = ~mask2;
          for (i4 = 0; i4 < 10; i4++) {
            this._h[i4] = this._h[i4] & mask2 | g7[i4];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f5 = this._h[0] + this._pad[0];
          this._h[0] = f5 & 65535;
          for (i4 = 1; i4 < 8; i4++) {
            f5 = (this._h[i4] + this._pad[i4] | 0) + (f5 >>> 16) | 0;
            this._h[i4] = f5 & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m5) {
          var mpos = 0;
          var bytes = m5.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
              want = bytes;
            }
            for (var i4 = 0; i4 < want; i4++) {
              this._buffer[this._leftover + i4] = m5[mpos + i4];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m5, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (var i4 = 0; i4 < bytes; i4++) {
              this._buffer[this._leftover + i4] = m5[mpos + i4];
            }
            this._leftover += bytes;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      }()
    );
    exports.Poly1305 = Poly1305;
    function oneTimeAuth(key2, data3) {
      var h6 = new Poly1305(key2);
      h6.update(data3);
      var digest2 = h6.digest();
      h6.clean();
      return digest2;
    }
    exports.oneTimeAuth = oneTimeAuth;
    function equal(a4, b6) {
      if (a4.length !== exports.DIGEST_LENGTH || b6.length !== exports.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a4, b6);
    }
    exports.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary();
    var constant_time_1 = require_constant_time();
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = (
      /** @class */
      function() {
        function ChaCha20Poly13052(key2) {
          this.nonceLength = exports.NONCE_LENGTH;
          this.tagLength = exports.TAG_LENGTH;
          if (key2.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key2);
        }
        ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h6 = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h6.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h6.update(ZEROS.subarray(associatedData.length % 16));
            }
          }
          h6.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h6.update(ZEROS.subarray(ciphertext.length % 16));
          }
          var length2 = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length2);
          }
          h6.update(length2);
          binary_1.writeUint64LE(ciphertext.length, length2);
          h6.update(length2);
          var tag = h6.digest();
          for (var i4 = 0; i4 < tag.length; i4++) {
            tagOut[i4] = tag[i4];
          }
          h6.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length2);
        };
        return ChaCha20Poly13052;
      }()
    );
    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function isSerializableHash(h6) {
      return typeof h6.saveState !== "undefined" && typeof h6.restoreState !== "undefined" && typeof h6.cleanSavedState !== "undefined";
    }
    exports.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hash_1 = require_hash();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = (
      /** @class */
      function() {
        function HMAC2(hash3, key2) {
          this._finished = false;
          this._inner = new hash3();
          this._outer = new hash3();
          this.blockSize = this._outer.blockSize;
          this.digestLength = this._outer.digestLength;
          var pad = new Uint8Array(this.blockSize);
          if (key2.length > this.blockSize) {
            this._inner.update(key2).finish(pad).clean();
          } else {
            pad.set(key2);
          }
          for (var i4 = 0; i4 < pad.length; i4++) {
            pad[i4] ^= 54;
          }
          this._inner.update(pad);
          for (var i4 = 0; i4 < pad.length; i4++) {
            pad[i4] ^= 54 ^ 92;
          }
          this._outer.update(pad);
          if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
          }
          wipe_1.wipe(pad);
        }
        HMAC2.prototype.reset = function() {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
          }
          this._inner.restoreState(this._innerKeyedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.clean = function() {
          if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
          }
          if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
          }
          this._inner.clean();
          this._outer.clean();
        };
        HMAC2.prototype.update = function(data3) {
          this._inner.update(data3);
          return this;
        };
        HMAC2.prototype.finish = function(out) {
          if (this._finished) {
            this._outer.finish(out);
            return this;
          }
          this._inner.finish(out);
          this._outer.update(out.subarray(0, this.digestLength)).finish(out);
          this._finished = true;
          return this;
        };
        HMAC2.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        HMAC2.prototype.saveState = function() {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
          }
          return this._inner.saveState();
        };
        HMAC2.prototype.restoreState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
          }
          this._inner.restoreState(savedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.cleanSavedState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
          }
          this._inner.cleanSavedState(savedState);
        };
        return HMAC2;
      }()
    );
    exports.HMAC = HMAC;
    function hmac2(hash3, key2, data3) {
      var h6 = new HMAC(hash3, key2);
      h6.update(data3);
      var digest2 = h6.digest();
      h6.clean();
      return digest2;
    }
    exports.hmac = hmac2;
    exports.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hmac_1 = require_hmac();
    var wipe_1 = require_wipe();
    var HKDF = (
      /** @class */
      function() {
        function HKDF2(hash3, key2, salt, info) {
          if (salt === void 0) {
            salt = new Uint8Array(0);
          }
          this._counter = new Uint8Array(1);
          this._hash = hash3;
          this._info = info;
          var okm = hmac_1.hmac(this._hash, salt, key2);
          this._hmac = new hmac_1.HMAC(hash3, okm);
          this._buffer = new Uint8Array(this._hmac.digestLength);
          this._bufpos = this._buffer.length;
        }
        HKDF2.prototype._fillBuffer = function() {
          this._counter[0]++;
          var ctr = this._counter[0];
          if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
          }
          this._hmac.reset();
          if (ctr > 1) {
            this._hmac.update(this._buffer);
          }
          if (this._info) {
            this._hmac.update(this._info);
          }
          this._hmac.update(this._counter);
          this._hmac.finish(this._buffer);
          this._bufpos = 0;
        };
        HKDF2.prototype.expand = function(length2) {
          var out = new Uint8Array(length2);
          for (var i4 = 0; i4 < out.length; i4++) {
            if (this._bufpos === this._buffer.length) {
              this._fillBuffer();
            }
            out[i4] = this._buffer[this._bufpos++];
          }
          return out;
        };
        HKDF2.prototype.clean = function() {
          this._hmac.clean();
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._counter);
          this._bufpos = 0;
        };
        return HKDF2;
      }()
    );
    exports.HKDF = HKDF;
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length2);
        for (let i4 = 0; i4 < out.length; i4 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i4, i4 + Math.min(out.length - i4, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_6, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key2}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer2 = this._crypto.randomBytes(length2);
        if (buffer2.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length2);
        for (let i4 = 0; i4 < out.length; i4++) {
          out[i4] = buffer2[i4];
        }
        (0, wipe_1.wipe)(buffer2);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes3(length2, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    exports.randomBytes = randomBytes3;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes3(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf = randomBytes3(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i4 = 0; i4 < buf.length && length2 > 0; i4++) {
          const randomByte = buf[i4];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length2, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    var SHA256 = (
      /** @class */
      function() {
        function SHA2562() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2562.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2562.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2562.prototype.update = function(data3, dataLength) {
          if (dataLength === void 0) {
            dataLength = data3.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data3[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data3, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data3[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2562.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i4 = left + 1; i4 < padLength - 8; i4++) {
              this._buffer[i4] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i4 = 0; i4 < this.digestLength / 4; i4++) {
            binary_1.writeUint32BE(this._state[i4], out, i4 * 4);
          }
          return this;
        };
        SHA2562.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2562.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2562.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2562;
      }()
    );
    exports.SHA256 = SHA256;
    var K4 = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w5, v5, p6, pos, len) {
      while (len >= 64) {
        var a4 = v5[0];
        var b6 = v5[1];
        var c5 = v5[2];
        var d4 = v5[3];
        var e3 = v5[4];
        var f5 = v5[5];
        var g7 = v5[6];
        var h6 = v5[7];
        for (var i4 = 0; i4 < 16; i4++) {
          var j7 = pos + i4 * 4;
          w5[i4] = binary_1.readUint32BE(p6, j7);
        }
        for (var i4 = 16; i4 < 64; i4++) {
          var u5 = w5[i4 - 2];
          var t1 = (u5 >>> 17 | u5 << 32 - 17) ^ (u5 >>> 19 | u5 << 32 - 19) ^ u5 >>> 10;
          u5 = w5[i4 - 15];
          var t22 = (u5 >>> 7 | u5 << 32 - 7) ^ (u5 >>> 18 | u5 << 32 - 18) ^ u5 >>> 3;
          w5[i4] = (t1 + w5[i4 - 7] | 0) + (t22 + w5[i4 - 16] | 0);
        }
        for (var i4 = 0; i4 < 64; i4++) {
          var t1 = (((e3 >>> 6 | e3 << 32 - 6) ^ (e3 >>> 11 | e3 << 32 - 11) ^ (e3 >>> 25 | e3 << 32 - 25)) + (e3 & f5 ^ ~e3 & g7) | 0) + (h6 + (K4[i4] + w5[i4] | 0) | 0) | 0;
          var t22 = ((a4 >>> 2 | a4 << 32 - 2) ^ (a4 >>> 13 | a4 << 32 - 13) ^ (a4 >>> 22 | a4 << 32 - 22)) + (a4 & b6 ^ a4 & c5 ^ b6 & c5) | 0;
          h6 = g7;
          g7 = f5;
          f5 = e3;
          e3 = d4 + t1 | 0;
          d4 = c5;
          c5 = b6;
          b6 = a4;
          a4 = t1 + t22 | 0;
        }
        v5[0] += a4;
        v5[1] += b6;
        v5[2] += c5;
        v5[3] += d4;
        v5[4] += e3;
        v5[5] += f5;
        v5[6] += g7;
        v5[7] += h6;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash3(data3) {
      var h6 = new SHA256();
      h6.update(data3);
      var digest2 = h6.digest();
      h6.clean();
      return digest2;
    }
    exports.hash = hash3;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
    var random_1 = require_random();
    var wipe_1 = require_wipe();
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32;
    function gf(init2) {
      const r5 = new Float64Array(16);
      if (init2) {
        for (let i4 = 0; i4 < init2.length; i4++) {
          r5[i4] = init2[i4];
        }
      }
      return r5;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o3) {
      let c5 = 1;
      for (let i4 = 0; i4 < 16; i4++) {
        let v5 = o3[i4] + c5 + 65535;
        c5 = Math.floor(v5 / 65536);
        o3[i4] = v5 - c5 * 65536;
      }
      o3[0] += c5 - 1 + 37 * (c5 - 1);
    }
    function sel25519(p6, q5, b6) {
      const c5 = ~(b6 - 1);
      for (let i4 = 0; i4 < 16; i4++) {
        const t3 = c5 & (p6[i4] ^ q5[i4]);
        p6[i4] ^= t3;
        q5[i4] ^= t3;
      }
    }
    function pack25519(o3, n3) {
      const m5 = gf();
      const t3 = gf();
      for (let i4 = 0; i4 < 16; i4++) {
        t3[i4] = n3[i4];
      }
      car25519(t3);
      car25519(t3);
      car25519(t3);
      for (let j7 = 0; j7 < 2; j7++) {
        m5[0] = t3[0] - 65517;
        for (let i4 = 1; i4 < 15; i4++) {
          m5[i4] = t3[i4] - 65535 - (m5[i4 - 1] >> 16 & 1);
          m5[i4 - 1] &= 65535;
        }
        m5[15] = t3[15] - 32767 - (m5[14] >> 16 & 1);
        const b6 = m5[15] >> 16 & 1;
        m5[14] &= 65535;
        sel25519(t3, m5, 1 - b6);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o3[2 * i4] = t3[i4] & 255;
        o3[2 * i4 + 1] = t3[i4] >> 8;
      }
    }
    function unpack25519(o3, n3) {
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = n3[2 * i4] + (n3[2 * i4 + 1] << 8);
      }
      o3[15] &= 32767;
    }
    function add3(o3, a4, b6) {
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = a4[i4] + b6[i4];
      }
    }
    function sub(o3, a4, b6) {
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = a4[i4] - b6[i4];
      }
    }
    function mul3(o3, a4, b6) {
      let v5, c5, t0 = 0, t1 = 0, t22 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b6[0], b1 = b6[1], b22 = b6[2], b32 = b6[3], b42 = b6[4], b52 = b6[5], b62 = b6[6], b7 = b6[7], b8 = b6[8], b9 = b6[9], b10 = b6[10], b11 = b6[11], b12 = b6[12], b13 = b6[13], b14 = b6[14], b15 = b6[15];
      v5 = a4[0];
      t0 += v5 * b0;
      t1 += v5 * b1;
      t22 += v5 * b22;
      t3 += v5 * b32;
      t4 += v5 * b42;
      t5 += v5 * b52;
      t6 += v5 * b62;
      t7 += v5 * b7;
      t8 += v5 * b8;
      t9 += v5 * b9;
      t10 += v5 * b10;
      t11 += v5 * b11;
      t12 += v5 * b12;
      t13 += v5 * b13;
      t14 += v5 * b14;
      t15 += v5 * b15;
      v5 = a4[1];
      t1 += v5 * b0;
      t22 += v5 * b1;
      t3 += v5 * b22;
      t4 += v5 * b32;
      t5 += v5 * b42;
      t6 += v5 * b52;
      t7 += v5 * b62;
      t8 += v5 * b7;
      t9 += v5 * b8;
      t10 += v5 * b9;
      t11 += v5 * b10;
      t12 += v5 * b11;
      t13 += v5 * b12;
      t14 += v5 * b13;
      t15 += v5 * b14;
      t16 += v5 * b15;
      v5 = a4[2];
      t22 += v5 * b0;
      t3 += v5 * b1;
      t4 += v5 * b22;
      t5 += v5 * b32;
      t6 += v5 * b42;
      t7 += v5 * b52;
      t8 += v5 * b62;
      t9 += v5 * b7;
      t10 += v5 * b8;
      t11 += v5 * b9;
      t12 += v5 * b10;
      t13 += v5 * b11;
      t14 += v5 * b12;
      t15 += v5 * b13;
      t16 += v5 * b14;
      t17 += v5 * b15;
      v5 = a4[3];
      t3 += v5 * b0;
      t4 += v5 * b1;
      t5 += v5 * b22;
      t6 += v5 * b32;
      t7 += v5 * b42;
      t8 += v5 * b52;
      t9 += v5 * b62;
      t10 += v5 * b7;
      t11 += v5 * b8;
      t12 += v5 * b9;
      t13 += v5 * b10;
      t14 += v5 * b11;
      t15 += v5 * b12;
      t16 += v5 * b13;
      t17 += v5 * b14;
      t18 += v5 * b15;
      v5 = a4[4];
      t4 += v5 * b0;
      t5 += v5 * b1;
      t6 += v5 * b22;
      t7 += v5 * b32;
      t8 += v5 * b42;
      t9 += v5 * b52;
      t10 += v5 * b62;
      t11 += v5 * b7;
      t12 += v5 * b8;
      t13 += v5 * b9;
      t14 += v5 * b10;
      t15 += v5 * b11;
      t16 += v5 * b12;
      t17 += v5 * b13;
      t18 += v5 * b14;
      t19 += v5 * b15;
      v5 = a4[5];
      t5 += v5 * b0;
      t6 += v5 * b1;
      t7 += v5 * b22;
      t8 += v5 * b32;
      t9 += v5 * b42;
      t10 += v5 * b52;
      t11 += v5 * b62;
      t12 += v5 * b7;
      t13 += v5 * b8;
      t14 += v5 * b9;
      t15 += v5 * b10;
      t16 += v5 * b11;
      t17 += v5 * b12;
      t18 += v5 * b13;
      t19 += v5 * b14;
      t20 += v5 * b15;
      v5 = a4[6];
      t6 += v5 * b0;
      t7 += v5 * b1;
      t8 += v5 * b22;
      t9 += v5 * b32;
      t10 += v5 * b42;
      t11 += v5 * b52;
      t12 += v5 * b62;
      t13 += v5 * b7;
      t14 += v5 * b8;
      t15 += v5 * b9;
      t16 += v5 * b10;
      t17 += v5 * b11;
      t18 += v5 * b12;
      t19 += v5 * b13;
      t20 += v5 * b14;
      t21 += v5 * b15;
      v5 = a4[7];
      t7 += v5 * b0;
      t8 += v5 * b1;
      t9 += v5 * b22;
      t10 += v5 * b32;
      t11 += v5 * b42;
      t12 += v5 * b52;
      t13 += v5 * b62;
      t14 += v5 * b7;
      t15 += v5 * b8;
      t16 += v5 * b9;
      t17 += v5 * b10;
      t18 += v5 * b11;
      t19 += v5 * b12;
      t20 += v5 * b13;
      t21 += v5 * b14;
      t222 += v5 * b15;
      v5 = a4[8];
      t8 += v5 * b0;
      t9 += v5 * b1;
      t10 += v5 * b22;
      t11 += v5 * b32;
      t12 += v5 * b42;
      t13 += v5 * b52;
      t14 += v5 * b62;
      t15 += v5 * b7;
      t16 += v5 * b8;
      t17 += v5 * b9;
      t18 += v5 * b10;
      t19 += v5 * b11;
      t20 += v5 * b12;
      t21 += v5 * b13;
      t222 += v5 * b14;
      t23 += v5 * b15;
      v5 = a4[9];
      t9 += v5 * b0;
      t10 += v5 * b1;
      t11 += v5 * b22;
      t12 += v5 * b32;
      t13 += v5 * b42;
      t14 += v5 * b52;
      t15 += v5 * b62;
      t16 += v5 * b7;
      t17 += v5 * b8;
      t18 += v5 * b9;
      t19 += v5 * b10;
      t20 += v5 * b11;
      t21 += v5 * b12;
      t222 += v5 * b13;
      t23 += v5 * b14;
      t24 += v5 * b15;
      v5 = a4[10];
      t10 += v5 * b0;
      t11 += v5 * b1;
      t12 += v5 * b22;
      t13 += v5 * b32;
      t14 += v5 * b42;
      t15 += v5 * b52;
      t16 += v5 * b62;
      t17 += v5 * b7;
      t18 += v5 * b8;
      t19 += v5 * b9;
      t20 += v5 * b10;
      t21 += v5 * b11;
      t222 += v5 * b12;
      t23 += v5 * b13;
      t24 += v5 * b14;
      t25 += v5 * b15;
      v5 = a4[11];
      t11 += v5 * b0;
      t12 += v5 * b1;
      t13 += v5 * b22;
      t14 += v5 * b32;
      t15 += v5 * b42;
      t16 += v5 * b52;
      t17 += v5 * b62;
      t18 += v5 * b7;
      t19 += v5 * b8;
      t20 += v5 * b9;
      t21 += v5 * b10;
      t222 += v5 * b11;
      t23 += v5 * b12;
      t24 += v5 * b13;
      t25 += v5 * b14;
      t26 += v5 * b15;
      v5 = a4[12];
      t12 += v5 * b0;
      t13 += v5 * b1;
      t14 += v5 * b22;
      t15 += v5 * b32;
      t16 += v5 * b42;
      t17 += v5 * b52;
      t18 += v5 * b62;
      t19 += v5 * b7;
      t20 += v5 * b8;
      t21 += v5 * b9;
      t222 += v5 * b10;
      t23 += v5 * b11;
      t24 += v5 * b12;
      t25 += v5 * b13;
      t26 += v5 * b14;
      t27 += v5 * b15;
      v5 = a4[13];
      t13 += v5 * b0;
      t14 += v5 * b1;
      t15 += v5 * b22;
      t16 += v5 * b32;
      t17 += v5 * b42;
      t18 += v5 * b52;
      t19 += v5 * b62;
      t20 += v5 * b7;
      t21 += v5 * b8;
      t222 += v5 * b9;
      t23 += v5 * b10;
      t24 += v5 * b11;
      t25 += v5 * b12;
      t26 += v5 * b13;
      t27 += v5 * b14;
      t28 += v5 * b15;
      v5 = a4[14];
      t14 += v5 * b0;
      t15 += v5 * b1;
      t16 += v5 * b22;
      t17 += v5 * b32;
      t18 += v5 * b42;
      t19 += v5 * b52;
      t20 += v5 * b62;
      t21 += v5 * b7;
      t222 += v5 * b8;
      t23 += v5 * b9;
      t24 += v5 * b10;
      t25 += v5 * b11;
      t26 += v5 * b12;
      t27 += v5 * b13;
      t28 += v5 * b14;
      t29 += v5 * b15;
      v5 = a4[15];
      t15 += v5 * b0;
      t16 += v5 * b1;
      t17 += v5 * b22;
      t18 += v5 * b32;
      t19 += v5 * b42;
      t20 += v5 * b52;
      t21 += v5 * b62;
      t222 += v5 * b7;
      t23 += v5 * b8;
      t24 += v5 * b9;
      t25 += v5 * b10;
      t26 += v5 * b11;
      t27 += v5 * b12;
      t28 += v5 * b13;
      t29 += v5 * b14;
      t30 += v5 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t22 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t222;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c5 = 1;
      v5 = t0 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t0 = v5 - c5 * 65536;
      v5 = t1 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t1 = v5 - c5 * 65536;
      v5 = t22 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t22 = v5 - c5 * 65536;
      v5 = t3 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t3 = v5 - c5 * 65536;
      v5 = t4 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t4 = v5 - c5 * 65536;
      v5 = t5 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t5 = v5 - c5 * 65536;
      v5 = t6 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t6 = v5 - c5 * 65536;
      v5 = t7 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t7 = v5 - c5 * 65536;
      v5 = t8 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t8 = v5 - c5 * 65536;
      v5 = t9 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t9 = v5 - c5 * 65536;
      v5 = t10 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t10 = v5 - c5 * 65536;
      v5 = t11 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t11 = v5 - c5 * 65536;
      v5 = t12 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t12 = v5 - c5 * 65536;
      v5 = t13 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t13 = v5 - c5 * 65536;
      v5 = t14 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t14 = v5 - c5 * 65536;
      v5 = t15 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t15 = v5 - c5 * 65536;
      t0 += c5 - 1 + 37 * (c5 - 1);
      c5 = 1;
      v5 = t0 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t0 = v5 - c5 * 65536;
      v5 = t1 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t1 = v5 - c5 * 65536;
      v5 = t22 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t22 = v5 - c5 * 65536;
      v5 = t3 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t3 = v5 - c5 * 65536;
      v5 = t4 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t4 = v5 - c5 * 65536;
      v5 = t5 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t5 = v5 - c5 * 65536;
      v5 = t6 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t6 = v5 - c5 * 65536;
      v5 = t7 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t7 = v5 - c5 * 65536;
      v5 = t8 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t8 = v5 - c5 * 65536;
      v5 = t9 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t9 = v5 - c5 * 65536;
      v5 = t10 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t10 = v5 - c5 * 65536;
      v5 = t11 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t11 = v5 - c5 * 65536;
      v5 = t12 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t12 = v5 - c5 * 65536;
      v5 = t13 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t13 = v5 - c5 * 65536;
      v5 = t14 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t14 = v5 - c5 * 65536;
      v5 = t15 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t15 = v5 - c5 * 65536;
      t0 += c5 - 1 + 37 * (c5 - 1);
      o3[0] = t0;
      o3[1] = t1;
      o3[2] = t22;
      o3[3] = t3;
      o3[4] = t4;
      o3[5] = t5;
      o3[6] = t6;
      o3[7] = t7;
      o3[8] = t8;
      o3[9] = t9;
      o3[10] = t10;
      o3[11] = t11;
      o3[12] = t12;
      o3[13] = t13;
      o3[14] = t14;
      o3[15] = t15;
    }
    function square(o3, a4) {
      mul3(o3, a4, a4);
    }
    function inv25519(o3, inp) {
      const c5 = gf();
      for (let i4 = 0; i4 < 16; i4++) {
        c5[i4] = inp[i4];
      }
      for (let i4 = 253; i4 >= 0; i4--) {
        square(c5, c5);
        if (i4 !== 2 && i4 !== 4) {
          mul3(c5, c5, inp);
        }
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = c5[i4];
      }
    }
    function scalarMult(n3, p6) {
      const z5 = new Uint8Array(32);
      const x5 = new Float64Array(80);
      const a4 = gf(), b6 = gf(), c5 = gf(), d4 = gf(), e3 = gf(), f5 = gf();
      for (let i4 = 0; i4 < 31; i4++) {
        z5[i4] = n3[i4];
      }
      z5[31] = n3[31] & 127 | 64;
      z5[0] &= 248;
      unpack25519(x5, p6);
      for (let i4 = 0; i4 < 16; i4++) {
        b6[i4] = x5[i4];
      }
      a4[0] = d4[0] = 1;
      for (let i4 = 254; i4 >= 0; --i4) {
        const r5 = z5[i4 >>> 3] >>> (i4 & 7) & 1;
        sel25519(a4, b6, r5);
        sel25519(c5, d4, r5);
        add3(e3, a4, c5);
        sub(a4, a4, c5);
        add3(c5, b6, d4);
        sub(b6, b6, d4);
        square(d4, e3);
        square(f5, a4);
        mul3(a4, c5, a4);
        mul3(c5, b6, e3);
        add3(e3, a4, c5);
        sub(a4, a4, c5);
        square(b6, a4);
        sub(c5, d4, f5);
        mul3(a4, c5, _121665);
        add3(a4, a4, d4);
        mul3(c5, c5, a4);
        mul3(a4, d4, f5);
        mul3(d4, b6, x5);
        square(b6, e3);
        sel25519(a4, b6, r5);
        sel25519(c5, d4, r5);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        x5[i4 + 16] = a4[i4];
        x5[i4 + 32] = c5[i4];
        x5[i4 + 48] = b6[i4];
        x5[i4 + 64] = d4[i4];
      }
      const x32 = x5.subarray(32);
      const x16 = x5.subarray(16);
      inv25519(x32, x32);
      mul3(x16, x16, x32);
      const q5 = new Uint8Array(32);
      pack25519(q5, x16);
      return q5;
    }
    exports.scalarMult = scalarMult;
    function scalarMultBase(n3) {
      return scalarMult(n3, _9);
    }
    exports.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      const secretKey = new Uint8Array(seed);
      const publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function sharedKey2(mySecretKey, theirPublicKey, rejectZero = false) {
      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      const result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        let zeros2 = 0;
        for (let i4 = 0; i4 < result.length; i4++) {
          zeros2 |= result[i4];
        }
        if (zeros2 === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports.sharedKey = sharedKey2;
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate35,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values
});
function __extends(d4, b6) {
  extendStatics(d4, b6);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
}
function __rest(s3, e3) {
  var t3 = {};
  for (var p6 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p6) && e3.indexOf(p6) < 0)
      t3[p6] = s3[p6];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p6 = Object.getOwnPropertySymbols(s3); i4 < p6.length; i4++) {
      if (e3.indexOf(p6[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p6[i4]))
        t3[p6[i4]] = s3[p6[i4]];
    }
  return t3;
}
function __decorate35(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
}
function __param(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _6 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f5, y7, t3, g7;
  return g7 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g7[Symbol.iterator] = function() {
    return this;
  }), g7;
  function verb(n3) {
    return function(v5) {
      return step([n3, v5]);
    };
  }
  function step(op) {
    if (f5)
      throw new TypeError("Generator is already executing.");
    while (_6)
      try {
        if (f5 = 1, y7 && (t3 = op[0] & 2 ? y7["return"] : op[0] ? y7["throw"] || ((t3 = y7["return"]) && t3.call(y7), 0) : y7.next) && !(t3 = t3.call(y7, op[1])).done)
          return t3;
        if (y7 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _6.label++;
            return { value: op[1], done: false };
          case 5:
            _6.label++;
            y7 = op[1];
            op = [0];
            continue;
          case 7:
            op = _6.ops.pop();
            _6.trys.pop();
            continue;
          default:
            if (!(t3 = _6.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _6 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _6.label = op[1];
              break;
            }
            if (op[0] === 6 && _6.label < t3[1]) {
              _6.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _6.label < t3[2]) {
              _6.label = t3[2];
              _6.ops.push(op);
              break;
            }
            if (t3[2])
              _6.ops.pop();
            _6.trys.pop();
            continue;
        }
        op = body.call(thisArg, _6);
      } catch (e3) {
        op = [6, e3];
        y7 = 0;
      } finally {
        f5 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o3, m5, k5, k22) {
  if (k22 === void 0)
    k22 = k5;
  o3[k22] = m5[k5];
}
function __exportStar(m5, exports) {
  for (var p6 in m5)
    if (p6 !== "default" && !exports.hasOwnProperty(p6))
      exports[p6] = m5[p6];
}
function __values(o3) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m5 = s3 && o3[s3], i4 = 0;
  if (m5)
    return m5.call(o3);
  if (o3 && typeof o3.length === "number")
    return {
      next: function() {
        if (o3 && i4 >= o3.length)
          o3 = void 0;
        return { value: o3 && o3[i4++], done: !o3 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o3, n3) {
  var m5 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m5)
    return o3;
  var i4 = m5.call(o3), r5, ar2 = [], e3;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r5 = i4.next()).done)
      ar2.push(r5.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r5 && !r5.done && (m5 = i4["return"]))
        m5.call(i4);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i4 = 0; i4 < arguments.length; i4++)
    ar2 = ar2.concat(__read(arguments[i4]));
  return ar2;
}
function __spreadArrays() {
  for (var s3 = 0, i4 = 0, il = arguments.length; i4 < il; i4++)
    s3 += arguments[i4].length;
  for (var r5 = Array(s3), k5 = 0, i4 = 0; i4 < il; i4++)
    for (var a4 = arguments[i4], j7 = 0, jl = a4.length; j7 < jl; j7++, k5++)
      r5[k5] = a4[j7];
  return r5;
}
function __await(v5) {
  return this instanceof __await ? (this.v = v5, this) : new __await(v5);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g7 = generator.apply(thisArg, _arguments || []), i4, q5 = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n3) {
    if (g7[n3])
      i4[n3] = function(v5) {
        return new Promise(function(a4, b6) {
          q5.push([n3, v5, a4, b6]) > 1 || resume(n3, v5);
        });
      };
  }
  function resume(n3, v5) {
    try {
      step(g7[n3](v5));
    } catch (e3) {
      settle(q5[0][3], e3);
    }
  }
  function step(r5) {
    r5.value instanceof __await ? Promise.resolve(r5.value.v).then(fulfill, reject) : settle(q5[0][2], r5);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f5, v5) {
    if (f5(v5), q5.shift(), q5.length)
      resume(q5[0][0], q5[0][1]);
  }
}
function __asyncDelegator(o3) {
  var i4, p6;
  return i4 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n3, f5) {
    i4[n3] = o3[n3] ? function(v5) {
      return (p6 = !p6) ? { value: __await(o3[n3](v5)), done: n3 === "return" } : f5 ? f5(v5) : v5;
    } : f5;
  }
}
function __asyncValues(o3) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m5 = o3[Symbol.asyncIterator], i4;
  return m5 ? m5.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n3) {
    i4[n3] = o3[n3] && function(v5) {
      return new Promise(function(resolve, reject) {
        v5 = o3[n3](v5), settle(resolve, reject, v5.done, v5.value);
      });
    };
  }
  function settle(resolve, reject, d4, v5) {
    Promise.resolve(v5).then(function(v6) {
      resolve({ value: v6, done: d4 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k5 in mod)
      if (Object.hasOwnProperty.call(mod, k5))
        result[k5] = mod[k5];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d4, b6) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b7) {
        d5.__proto__ = b7;
      } || function(d5, b7) {
        for (var p6 in b7)
          if (b7.hasOwnProperty(p6))
            d5[p6] = b7[p6];
      };
      return extendStatics(d4, b6);
    };
    __assign = function() {
      __assign = Object.assign || function __assign3(t3) {
        for (var s3, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
          s3 = arguments[i4];
          for (var p6 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p6))
              t3[p6] = s3[p6];
        }
        return t3;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/delay.js
var require_delay = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.delay = void 0;
    function delay2(timeout2) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve(true);
        }, timeout2);
      });
    }
    exports.delay = delay2;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/misc.js
var require_misc = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
    exports.ONE_HUNDRED = 100;
    exports.ONE_THOUSAND = 1e3;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/time.js
var require_time = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  }
});

// node_modules/@walletconnect/time/dist/cjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_misc(), exports);
    tslib_1.__exportStar(require_time(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/convert.js
var require_convert = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromMiliseconds = exports.toMiliseconds = void 0;
    var constants_1 = require_constants();
    function toMiliseconds(seconds) {
      return seconds * constants_1.ONE_THOUSAND;
    }
    exports.toMiliseconds = toMiliseconds;
    function fromMiliseconds2(miliseconds) {
      return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
    }
    exports.fromMiliseconds = fromMiliseconds2;
  }
});

// node_modules/@walletconnect/time/dist/cjs/utils/index.js
var require_utils = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_delay(), exports);
    tslib_1.__exportStar(require_convert(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/watch.js
var require_watch = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Watch = void 0;
    var Watch = class {
      constructor() {
        this.timestamps = /* @__PURE__ */ new Map();
      }
      start(label) {
        if (this.timestamps.has(label)) {
          throw new Error(`Watch already started for label: ${label}`);
        }
        this.timestamps.set(label, { started: Date.now() });
      }
      stop(label) {
        const timestamp2 = this.get(label);
        if (typeof timestamp2.elapsed !== "undefined") {
          throw new Error(`Watch already stopped for label: ${label}`);
        }
        const elapsed = Date.now() - timestamp2.started;
        this.timestamps.set(label, { started: timestamp2.started, elapsed });
      }
      get(label) {
        const timestamp2 = this.timestamps.get(label);
        if (typeof timestamp2 === "undefined") {
          throw new Error(`No timestamp found for label: ${label}`);
        }
        return timestamp2;
      }
      elapsed(label) {
        const timestamp2 = this.get(label);
        const elapsed = timestamp2.elapsed || Date.now() - timestamp2.started;
        return elapsed;
      }
    };
    exports.Watch = Watch;
    exports.default = Watch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/watch.js
var require_watch2 = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IWatch = void 0;
    var IWatch = class {
    };
    exports.IWatch = IWatch;
  }
});

// node_modules/@walletconnect/time/dist/cjs/types/index.js
var require_types = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_watch2(), exports);
  }
});

// node_modules/@walletconnect/time/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_utils(), exports);
    tslib_1.__exportStar(require_watch(), exports);
    tslib_1.__exportStar(require_types(), exports);
    tslib_1.__exportStar(require_constants(), exports);
  }
});

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow(name2) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow;
    function getFromWindowOrThrow(name2) {
      const res = getFromWindow(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow;
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow;
    function getDocument() {
      return getFromWindow("document");
    }
    exports.getDocument = getDocument;
    function getNavigatorOrThrow() {
      return getFromWindowOrThrow("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow;
    function getNavigator() {
      return getFromWindow("navigator");
    }
    exports.getNavigator = getNavigator;
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow;
    function getLocation() {
      return getFromWindow("location");
    }
    exports.getLocation = getLocation;
    function getCryptoOrThrow() {
      return getFromWindowOrThrow("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow;
    function getCrypto() {
      return getFromWindow("crypto");
    }
    exports.getCrypto = getCrypto;
    function getLocalStorageOrThrow() {
      return getFromWindowOrThrow("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
    function getLocalStorage() {
      return getFromWindow("localStorage");
    }
    exports.getLocalStorage = getLocalStorage;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs2();
    function getWindowMetadata() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e3) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i4 = 0; i4 < links.length; i4++) {
          const link = links[i4];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i4 = 0; i4 < metaTags.length; i4++) {
          const tag = metaTags[i4];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name3) {
          name3 = doc.title;
        }
        return name3;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name2 = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name: name2
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x5) => `%${x5.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode8(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i4 = 1; i4 < tokens.length; i4++) {
          input = decodeComponents(tokens, i4).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode8(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i4 = 0; i4 < entries.length; i4++) {
        var key2 = entries[i4];
        input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string3, separator) => {
      if (!(typeof string3 === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string3];
      }
      const separatorIndex = string3.indexOf(separator);
      if (separatorIndex === -1) {
        return [string3];
      }
      return [
        string3.slice(0, separatorIndex),
        string3.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys2 = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i4 = 0; i4 < keys2.length; i4++) {
        var key2 = keys2[i4];
        var val = obj[key2];
        if (isArr ? predicate.indexOf(key2) !== -1 : predicate(key2, val, obj)) {
          ret[key2] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key2) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode8(key2, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode8(key2, options), "[", encode8(index, options), "]=", encode8(value, options)].join("")
            ];
          };
        case "bracket":
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode8(key2, options), "[]"].join("")];
            }
            return [...result, [encode8(key2, options), "[]=", encode8(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode8(key2, options), ":list="].join("")];
            }
            return [...result, [encode8(key2, options), ":list=", encode8(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode8(key2, options), keyValueSep, encode8(value, options)].join("")];
            }
            return [[result, encode8(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key2) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode8(key2, options)];
            }
            return [...result, [encode8(key2, options), "=", encode8(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key2, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key2);
            key2 = key2.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = {};
            }
            accumulator[key2][result[1]] = value;
          };
        case "bracket":
          return (key2, value, accumulator) => {
            result = /(\[\])$/.exec(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
        case "colon-list-separator":
          return (key2, value, accumulator) => {
            result = /(:list)$/.exec(key2);
            key2 = key2.replace(/:list$/, "");
            if (!result) {
              accumulator[key2] = value;
              return;
            }
            if (accumulator[key2] === void 0) {
              accumulator[key2] = [value];
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
        case "comma":
        case "separator":
          return (key2, value, accumulator) => {
            const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray2 && decode8(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode8(value, options) : value;
            const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode8(item, options)) : value === null ? value : decode8(value, options);
            accumulator[key2] = newValue;
          };
        case "bracket-separator":
          return (key2, value, accumulator) => {
            const isArray2 = /(\[\])$/.test(key2);
            key2 = key2.replace(/\[\]$/, "");
            if (!isArray2) {
              accumulator[key2] = value ? decode8(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode8(item, options));
            if (accumulator[key2] === void 0) {
              accumulator[key2] = arrayValue;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], arrayValue);
          };
        default:
          return (key2, value, accumulator) => {
            if (accumulator[key2] === void 0) {
              accumulator[key2] = value;
              return;
            }
            accumulator[key2] = [].concat(accumulator[key2], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode8(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode8(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a4, b6) => Number(a4) - Number(b6)).map((key2) => input[key2]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash3 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash3 = url.slice(hashStart);
      }
      return hash3;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse3(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key2, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode8(value, options);
        formatter(decode8(key2, options), value, ret);
      }
      for (const key2 of Object.keys(ret)) {
        const value = ret[key2];
        if (typeof value === "object" && value !== null) {
          for (const k5 of Object.keys(value)) {
            value[k5] = parseValue(value[k5], options);
          }
        } else {
          ret[key2] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
        const value = ret[key2];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key2] = keysSorter(value);
        } else {
          result[key2] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse3;
    exports.stringify = (object2, options) => {
      if (!object2) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object2[key2]) || options.skipEmptyString && object2[key2] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key2 of Object.keys(object2)) {
        if (!shouldFilter(key2)) {
          objectCopy[key2] = object2[key2];
        }
      }
      const keys2 = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys2.sort(options.sort);
      }
      return keys2.map((key2) => {
        const value = object2[key2];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode8(key2, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode8(key2, options) + "[]";
          }
          return value.reduce(formatter(key2), []).join("&");
        }
        return encode8(key2, options) + "=" + encode8(value, options);
      }).filter((x5) => x5.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash3] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse3(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode8(hash3, options) } : {}
      );
    };
    exports.stringifyUrl = (object2, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object2.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object2.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object2.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash3 = getHash(object2.url);
      if (object2.fragmentIdentifier) {
        hash3 = `#${options[encodeFragmentIdentifier] ? encode8(object2.fragmentIdentifier, options) : object2.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash3}`;
    };
    exports.pick = (input, filter2, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter2),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter2, options) => {
      const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents;
var init_events = __esm({
  "node_modules/@walletconnect/events/dist/esm/events.js"() {
    IEvents = class {
    };
  }
});

// node_modules/@walletconnect/events/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  IEvents: () => IEvents
});
var init_esm = __esm({
  "node_modules/@walletconnect/events/dist/esm/index.js"() {
    init_events();
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IHeartBeat = void 0;
    var events_1 = (init_esm(), __toCommonJS(esm_exports));
    var IHeartBeat = class extends events_1.IEvents {
      constructor(opts) {
        super();
      }
    };
    exports.IHeartBeat = IHeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
var require_types2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
var require_heartbeat2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
    var time_1 = require_cjs();
    exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
    exports.HEARTBEAT_EVENTS = {
      pulse: "heartbeat_pulse"
    };
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
var require_constants2 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat2(), exports);
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
var require_heartbeat3 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeartBeat = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var events_1 = require_events();
    var time_1 = require_cjs();
    var types_1 = require_types2();
    var constants_1 = require_constants2();
    var HeartBeat = class _HeartBeat extends types_1.IHeartBeat {
      constructor(opts) {
        super(opts);
        this.events = new events_1.EventEmitter();
        this.interval = constants_1.HEARTBEAT_INTERVAL;
        this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      }
      static init(opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const heartbeat = new _HeartBeat(opts);
          yield heartbeat.init();
          return heartbeat;
        });
      }
      init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
        });
      }
      stop() {
        clearInterval(this.intervalRef);
      }
      on(event, listener) {
        this.events.on(event, listener);
      }
      once(event, listener) {
        this.events.once(event, listener);
      }
      off(event, listener) {
        this.events.off(event, listener);
      }
      removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
      initialize() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
        });
      }
      pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    };
    exports.HeartBeat = HeartBeat;
  }
});

// node_modules/@walletconnect/heartbeat/dist/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_heartbeat3(), exports);
    tslib_1.__exportStar(require_types2(), exports);
    tslib_1.__exportStar(require_constants2(), exports);
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module) {
    "use strict";
    function tryStringify(o3) {
      try {
        return JSON.stringify(o3);
      } catch (e3) {
        return '"[Circular]"';
      }
    }
    module.exports = format;
    function format(f5, args, opts) {
      var ss2 = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f5 === "object" && f5 !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f5;
        var objects = new Array(len);
        objects[0] = ss2(f5);
        for (var index = 1; index < len; index++) {
          objects[index] = ss2(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f5 !== "string") {
        return f5;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f5;
      var str = "";
      var a4 = 1 - offset;
      var lastPos = -1;
      var flen = f5 && f5.length || 0;
      for (var i4 = 0; i4 < flen; ) {
        if (f5.charCodeAt(i4) === 37 && i4 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f5.charCodeAt(i4 + 1)) {
            case 100:
            case 102:
              if (a4 >= argLen)
                break;
              if (args[a4] == null)
                break;
              if (lastPos < i4)
                str += f5.slice(lastPos, i4);
              str += Number(args[a4]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 105:
              if (a4 >= argLen)
                break;
              if (args[a4] == null)
                break;
              if (lastPos < i4)
                str += f5.slice(lastPos, i4);
              str += Math.floor(Number(args[a4]));
              lastPos = i4 + 2;
              i4++;
              break;
            case 79:
            case 111:
            case 106:
              if (a4 >= argLen)
                break;
              if (args[a4] === void 0)
                break;
              if (lastPos < i4)
                str += f5.slice(lastPos, i4);
              var type2 = typeof args[a4];
              if (type2 === "string") {
                str += "'" + args[a4] + "'";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              if (type2 === "function") {
                str += args[a4].name || "<anonymous>";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              str += ss2(args[a4]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 115:
              if (a4 >= argLen)
                break;
              if (lastPos < i4)
                str += f5.slice(lastPos, i4);
              str += String(args[a4]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 37:
              if (lastPos < i4)
                str += f5.slice(lastPos, i4);
              str += "%";
              lastPos = i4 + 2;
              i4++;
              a4--;
              break;
          }
          ++a4;
        }
        ++i4;
      }
      if (lastPos === -1)
        return f5;
      else if (lastPos < flen) {
        str += f5.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize3, serializers) {
      if (Array.isArray(serialize3)) {
        const hasToFilter = serialize3.filter(function(k5) {
          return k5 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize3 === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write)
        opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize3 = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
        stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false)
        opts.level = "silent";
      const level = opts.level || "info";
      const logger47 = Object.create(proto);
      if (!logger47.log)
        logger47.log = noop2;
      Object.defineProperty(logger47, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger47, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize: serialize3,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger47.levels = pino.levels;
      logger47.level = level;
      logger47.setMaxListeners = logger47.getMaxListeners = logger47.emit = logger47.addListener = logger47.on = logger47.prependListener = logger47.once = logger47.prependOnceListener = logger47.removeListener = logger47.removeAllListeners = logger47.listeners = logger47.listenerCount = logger47.eventNames = logger47.write = logger47.flush = noop2;
      logger47.serializers = serializers;
      logger47._serialize = serialize3;
      logger47._stdErrSerialize = stdErrSerialize;
      logger47.child = child;
      if (transmit2)
        logger47._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set3(setOpts, logger47, "error", "log");
        set3(setOpts, logger47, "fatal", "error");
        set3(setOpts, logger47, "warn", "error");
        set3(setOpts, logger47, "info", "log");
        set3(setOpts, logger47, "debug", "log");
        set3(setOpts, logger47, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize3 && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize3 && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize3;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger47;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set3(opts, logger47, level, fallback) {
      const proto = Object.getPrototypeOf(logger47);
      logger47[level] = logger47.levelVal > logger47.levels.values[level] ? noop2 : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop2;
      wrap(opts, logger47, level);
    }
    function wrap(opts, logger47, level) {
      if (!opts.transmit && logger47[level] === noop2)
        return;
      logger47[level] = function(write) {
        return function LOG() {
          const ts2 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i4 = 0; i4 < args.length; i4++)
            args[i4] = arguments[i4];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject)
            write.call(proto, asObject(this, level, args, ts2));
          else
            write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger47.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue)
              return;
            transmit(this, {
              ts: ts2,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger47.level],
              send: opts.transmit.send,
              val: logger47.levelVal
            }, args);
          }
        };
      }(logger47[level]);
    }
    function asObject(logger47, level, args, ts2) {
      if (logger47._serialize)
        applySerializers(args, logger47._serialize, logger47.serializers, logger47._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o3 = {};
      if (ts2) {
        o3.time = ts2;
      }
      o3.level = pino.levels.values[level];
      let lvl = (logger47._childLevel | 0) + 1;
      if (lvl < 1)
        lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o3, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0)
        o3.msg = msg;
      return o3;
    }
    function applySerializers(args, serialize3, serializers, stdErrSerialize) {
      for (const i4 in args) {
        if (stdErrSerialize && args[i4] instanceof Error) {
          args[i4] = pino.stdSerializers.err(args[i4]);
        } else if (typeof args[i4] === "object" && !Array.isArray(args[i4])) {
          for (const k5 in args[i4]) {
            if (serialize3 && serialize3.indexOf(k5) > -1 && k5 in serializers) {
              args[i4][k5] = serializers[k5](args[i4][k5]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i4 = 1; i4 < args.length; i4++) {
          args[i4] = arguments[i4 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger47, opts, args) {
      const send = opts.send;
      const ts2 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger47._logEvent.bindings;
      applySerializers(
        args,
        logger47._serialize || Object.keys(logger47.serializers),
        logger47.serializers,
        logger47._stdErrSerialize === void 0 ? true : logger47._stdErrSerialize
      );
      logger47._logEvent.ts = ts2;
      logger47._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger47._logEvent.level.label = methodLevel;
      logger47._logEvent.level.value = methodValue;
      send(methodLevel, logger47._logEvent, val);
      logger47._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key2 in err) {
        if (obj[key2] === void 0) {
          obj[key2] = err[key2];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a4) {
      return a4;
    }
    function noop2() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o3) {
        return typeof o3 !== "undefined" && o3;
      }
      try {
        if (typeof globalThis !== "undefined")
          return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e3) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/logger/dist/cjs/constants.js
var require_constants3 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PINO_CUSTOM_CONTEXT_KEY = exports.PINO_LOGGER_DEFAULTS = void 0;
    exports.PINO_LOGGER_DEFAULTS = {
      level: "info"
    };
    exports.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
  }
});

// node_modules/@walletconnect/logger/dist/cjs/utils.js
var require_utils2 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateChildLogger = exports.formatChildLoggerContext = exports.getLoggerContext = exports.setBrowserLoggerContext = exports.getBrowserLoggerContext = exports.getDefaultLoggerOptions = void 0;
    var constants_1 = require_constants3();
    function getDefaultLoggerOptions(opts) {
      return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level });
    }
    exports.getDefaultLoggerOptions = getDefaultLoggerOptions;
    function getBrowserLoggerContext(logger47, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      return logger47[customContextKey] || "";
    }
    exports.getBrowserLoggerContext = getBrowserLoggerContext;
    function setBrowserLoggerContext(logger47, context, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      logger47[customContextKey] = context;
      return logger47;
    }
    exports.setBrowserLoggerContext = setBrowserLoggerContext;
    function getLoggerContext(logger47, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      let context = "";
      if (typeof logger47.bindings === "undefined") {
        context = getBrowserLoggerContext(logger47, customContextKey);
      } else {
        context = logger47.bindings().context || "";
      }
      return context;
    }
    exports.getLoggerContext = getLoggerContext;
    function formatChildLoggerContext(logger47, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      const parentContext = getLoggerContext(logger47, customContextKey);
      const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;
      return context;
    }
    exports.formatChildLoggerContext = formatChildLoggerContext;
    function generateChildLogger(logger47, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
      const context = formatChildLoggerContext(logger47, childContext, customContextKey);
      const child = logger47.child({ context });
      return setBrowserLoggerContext(child, context, customContextKey);
    }
    exports.generateChildLogger = generateChildLogger;
  }
});

// node_modules/@walletconnect/logger/dist/cjs/index.js
var require_cjs5 = __commonJS({
  "node_modules/@walletconnect/logger/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pino = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var pino_1 = tslib_1.__importDefault(require_browser2());
    Object.defineProperty(exports, "pino", { enumerable: true, get: function() {
      return pino_1.default;
    } });
    tslib_1.__exportStar(require_constants3(), exports);
    tslib_1.__exportStar(require_utils2(), exports);
  }
});

// node_modules/@stablelib/sha512/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    var SHA512 = (
      /** @class */
      function() {
        function SHA5122() {
          this.digestLength = exports.DIGEST_LENGTH;
          this.blockSize = exports.BLOCK_SIZE;
          this._stateHi = new Int32Array(8);
          this._stateLo = new Int32Array(8);
          this._tempHi = new Int32Array(16);
          this._tempLo = new Int32Array(16);
          this._buffer = new Uint8Array(256);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA5122.prototype._initState = function() {
          this._stateHi[0] = 1779033703;
          this._stateHi[1] = 3144134277;
          this._stateHi[2] = 1013904242;
          this._stateHi[3] = 2773480762;
          this._stateHi[4] = 1359893119;
          this._stateHi[5] = 2600822924;
          this._stateHi[6] = 528734635;
          this._stateHi[7] = 1541459225;
          this._stateLo[0] = 4089235720;
          this._stateLo[1] = 2227873595;
          this._stateLo[2] = 4271175723;
          this._stateLo[3] = 1595750129;
          this._stateLo[4] = 2917565137;
          this._stateLo[5] = 725511199;
          this._stateLo[6] = 4215389547;
          this._stateLo[7] = 327033209;
        };
        SHA5122.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._tempHi);
          wipe_1.wipe(this._tempLo);
          this.reset();
        };
        SHA5122.prototype.update = function(data3, dataLength) {
          if (dataLength === void 0) {
            dataLength = data3.length;
          }
          if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
              this._buffer[this._bufferLength++] = data3[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data3, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data3[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA5122.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 128 < 112 ? 128 : 256;
            this._buffer[left] = 128;
            for (var i4 = left + 1; i4 < padLength - 8; i4++) {
              this._buffer[i4] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i4 = 0; i4 < this.digestLength / 8; i4++) {
            binary_1.writeUint32BE(this._stateHi[i4], out, i4 * 8);
            binary_1.writeUint32BE(this._stateLo[i4], out, i4 * 8 + 4);
          }
          return this;
        };
        SHA5122.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA5122.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA5122.prototype.restoreState = function(savedState) {
          this._stateHi.set(savedState.stateHi);
          this._stateLo.set(savedState.stateLo);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA5122.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.stateHi);
          wipe_1.wipe(savedState.stateLo);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA5122;
      }()
    );
    exports.SHA512 = SHA512;
    var K4 = new Int32Array([
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ]);
    function hashBlocks(wh, wl, hh, hl, m5, pos, len) {
      var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
      var h6, l4;
      var th, tl;
      var a4, b6, c5, d4;
      while (len >= 128) {
        for (var i4 = 0; i4 < 16; i4++) {
          var j7 = 8 * i4 + pos;
          wh[i4] = binary_1.readUint32BE(m5, j7);
          wl[i4] = binary_1.readUint32BE(m5, j7 + 4);
        }
        for (var i4 = 0; i4 < 80; i4++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7;
          h6 = ah7;
          l4 = al7;
          a4 = l4 & 65535;
          b6 = l4 >>> 16;
          c5 = h6 & 65535;
          d4 = h6 >>> 16;
          h6 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l4 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          h6 = ah4 & ah5 ^ ~ah4 & ah6;
          l4 = al4 & al5 ^ ~al4 & al6;
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          h6 = K4[i4 * 2];
          l4 = K4[i4 * 2 + 1];
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          h6 = wh[i4 % 16];
          l4 = wl[i4 % 16];
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          b6 += a4 >>> 16;
          c5 += b6 >>> 16;
          d4 += c5 >>> 16;
          th = c5 & 65535 | d4 << 16;
          tl = a4 & 65535 | b6 << 16;
          h6 = th;
          l4 = tl;
          a4 = l4 & 65535;
          b6 = l4 >>> 16;
          c5 = h6 & 65535;
          d4 = h6 >>> 16;
          h6 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l4 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          h6 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l4 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          b6 += a4 >>> 16;
          c5 += b6 >>> 16;
          d4 += c5 >>> 16;
          bh7 = c5 & 65535 | d4 << 16;
          bl7 = a4 & 65535 | b6 << 16;
          h6 = bh3;
          l4 = bl3;
          a4 = l4 & 65535;
          b6 = l4 >>> 16;
          c5 = h6 & 65535;
          d4 = h6 >>> 16;
          h6 = th;
          l4 = tl;
          a4 += l4 & 65535;
          b6 += l4 >>> 16;
          c5 += h6 & 65535;
          d4 += h6 >>> 16;
          b6 += a4 >>> 16;
          c5 += b6 >>> 16;
          d4 += c5 >>> 16;
          bh3 = c5 & 65535 | d4 << 16;
          bl3 = a4 & 65535 | b6 << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;
          if (i4 % 16 === 15) {
            for (var j7 = 0; j7 < 16; j7++) {
              h6 = wh[j7];
              l4 = wl[j7];
              a4 = l4 & 65535;
              b6 = l4 >>> 16;
              c5 = h6 & 65535;
              d4 = h6 >>> 16;
              h6 = wh[(j7 + 9) % 16];
              l4 = wl[(j7 + 9) % 16];
              a4 += l4 & 65535;
              b6 += l4 >>> 16;
              c5 += h6 & 65535;
              d4 += h6 >>> 16;
              th = wh[(j7 + 1) % 16];
              tl = wl[(j7 + 1) % 16];
              h6 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l4 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a4 += l4 & 65535;
              b6 += l4 >>> 16;
              c5 += h6 & 65535;
              d4 += h6 >>> 16;
              th = wh[(j7 + 14) % 16];
              tl = wl[(j7 + 14) % 16];
              h6 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l4 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a4 += l4 & 65535;
              b6 += l4 >>> 16;
              c5 += h6 & 65535;
              d4 += h6 >>> 16;
              b6 += a4 >>> 16;
              c5 += b6 >>> 16;
              d4 += c5 >>> 16;
              wh[j7] = c5 & 65535 | d4 << 16;
              wl[j7] = a4 & 65535 | b6 << 16;
            }
          }
        }
        h6 = ah0;
        l4 = al0;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[0];
        l4 = hl[0];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[0] = ah0 = c5 & 65535 | d4 << 16;
        hl[0] = al0 = a4 & 65535 | b6 << 16;
        h6 = ah1;
        l4 = al1;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[1];
        l4 = hl[1];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[1] = ah1 = c5 & 65535 | d4 << 16;
        hl[1] = al1 = a4 & 65535 | b6 << 16;
        h6 = ah2;
        l4 = al2;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[2];
        l4 = hl[2];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[2] = ah2 = c5 & 65535 | d4 << 16;
        hl[2] = al2 = a4 & 65535 | b6 << 16;
        h6 = ah3;
        l4 = al3;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[3];
        l4 = hl[3];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[3] = ah3 = c5 & 65535 | d4 << 16;
        hl[3] = al3 = a4 & 65535 | b6 << 16;
        h6 = ah4;
        l4 = al4;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[4];
        l4 = hl[4];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[4] = ah4 = c5 & 65535 | d4 << 16;
        hl[4] = al4 = a4 & 65535 | b6 << 16;
        h6 = ah5;
        l4 = al5;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[5];
        l4 = hl[5];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[5] = ah5 = c5 & 65535 | d4 << 16;
        hl[5] = al5 = a4 & 65535 | b6 << 16;
        h6 = ah6;
        l4 = al6;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[6];
        l4 = hl[6];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[6] = ah6 = c5 & 65535 | d4 << 16;
        hl[6] = al6 = a4 & 65535 | b6 << 16;
        h6 = ah7;
        l4 = al7;
        a4 = l4 & 65535;
        b6 = l4 >>> 16;
        c5 = h6 & 65535;
        d4 = h6 >>> 16;
        h6 = hh[7];
        l4 = hl[7];
        a4 += l4 & 65535;
        b6 += l4 >>> 16;
        c5 += h6 & 65535;
        d4 += h6 >>> 16;
        b6 += a4 >>> 16;
        c5 += b6 >>> 16;
        d4 += c5 >>> 16;
        hh[7] = ah7 = c5 & 65535 | d4 << 16;
        hl[7] = al7 = a4 & 65535 | b6 << 16;
        pos += 128;
        len -= 128;
      }
      return pos;
    }
    function hash3(data3) {
      var h6 = new SHA512();
      h6.update(data3);
      var digest2 = h6.digest();
      h6.clean();
      return digest2;
    }
    exports.hash = hash3;
  }
});

// node_modules/@stablelib/ed25519/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
    var random_1 = require_random();
    var sha512_1 = require_sha512();
    var wipe_1 = require_wipe();
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32;
    function gf(init2) {
      const r5 = new Float64Array(16);
      if (init2) {
        for (let i4 = 0; i4 < init2.length; i4++) {
          r5[i4] = init2[i4];
        }
      }
      return r5;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D6 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X4 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var I3 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function set25519(r5, a4) {
      for (let i4 = 0; i4 < 16; i4++) {
        r5[i4] = a4[i4] | 0;
      }
    }
    function car25519(o3) {
      let c5 = 1;
      for (let i4 = 0; i4 < 16; i4++) {
        let v5 = o3[i4] + c5 + 65535;
        c5 = Math.floor(v5 / 65536);
        o3[i4] = v5 - c5 * 65536;
      }
      o3[0] += c5 - 1 + 37 * (c5 - 1);
    }
    function sel25519(p6, q5, b6) {
      const c5 = ~(b6 - 1);
      for (let i4 = 0; i4 < 16; i4++) {
        const t3 = c5 & (p6[i4] ^ q5[i4]);
        p6[i4] ^= t3;
        q5[i4] ^= t3;
      }
    }
    function pack25519(o3, n3) {
      const m5 = gf();
      const t3 = gf();
      for (let i4 = 0; i4 < 16; i4++) {
        t3[i4] = n3[i4];
      }
      car25519(t3);
      car25519(t3);
      car25519(t3);
      for (let j7 = 0; j7 < 2; j7++) {
        m5[0] = t3[0] - 65517;
        for (let i4 = 1; i4 < 15; i4++) {
          m5[i4] = t3[i4] - 65535 - (m5[i4 - 1] >> 16 & 1);
          m5[i4 - 1] &= 65535;
        }
        m5[15] = t3[15] - 32767 - (m5[14] >> 16 & 1);
        const b6 = m5[15] >> 16 & 1;
        m5[14] &= 65535;
        sel25519(t3, m5, 1 - b6);
      }
      for (let i4 = 0; i4 < 16; i4++) {
        o3[2 * i4] = t3[i4] & 255;
        o3[2 * i4 + 1] = t3[i4] >> 8;
      }
    }
    function verify32(x5, y7) {
      let d4 = 0;
      for (let i4 = 0; i4 < 32; i4++) {
        d4 |= x5[i4] ^ y7[i4];
      }
      return (1 & d4 - 1 >>> 8) - 1;
    }
    function neq25519(a4, b6) {
      const c5 = new Uint8Array(32);
      const d4 = new Uint8Array(32);
      pack25519(c5, a4);
      pack25519(d4, b6);
      return verify32(c5, d4);
    }
    function par25519(a4) {
      const d4 = new Uint8Array(32);
      pack25519(d4, a4);
      return d4[0] & 1;
    }
    function unpack25519(o3, n3) {
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = n3[2 * i4] + (n3[2 * i4 + 1] << 8);
      }
      o3[15] &= 32767;
    }
    function add3(o3, a4, b6) {
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = a4[i4] + b6[i4];
      }
    }
    function sub(o3, a4, b6) {
      for (let i4 = 0; i4 < 16; i4++) {
        o3[i4] = a4[i4] - b6[i4];
      }
    }
    function mul3(o3, a4, b6) {
      let v5, c5, t0 = 0, t1 = 0, t22 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b6[0], b1 = b6[1], b22 = b6[2], b32 = b6[3], b42 = b6[4], b52 = b6[5], b62 = b6[6], b7 = b6[7], b8 = b6[8], b9 = b6[9], b10 = b6[10], b11 = b6[11], b12 = b6[12], b13 = b6[13], b14 = b6[14], b15 = b6[15];
      v5 = a4[0];
      t0 += v5 * b0;
      t1 += v5 * b1;
      t22 += v5 * b22;
      t3 += v5 * b32;
      t4 += v5 * b42;
      t5 += v5 * b52;
      t6 += v5 * b62;
      t7 += v5 * b7;
      t8 += v5 * b8;
      t9 += v5 * b9;
      t10 += v5 * b10;
      t11 += v5 * b11;
      t12 += v5 * b12;
      t13 += v5 * b13;
      t14 += v5 * b14;
      t15 += v5 * b15;
      v5 = a4[1];
      t1 += v5 * b0;
      t22 += v5 * b1;
      t3 += v5 * b22;
      t4 += v5 * b32;
      t5 += v5 * b42;
      t6 += v5 * b52;
      t7 += v5 * b62;
      t8 += v5 * b7;
      t9 += v5 * b8;
      t10 += v5 * b9;
      t11 += v5 * b10;
      t12 += v5 * b11;
      t13 += v5 * b12;
      t14 += v5 * b13;
      t15 += v5 * b14;
      t16 += v5 * b15;
      v5 = a4[2];
      t22 += v5 * b0;
      t3 += v5 * b1;
      t4 += v5 * b22;
      t5 += v5 * b32;
      t6 += v5 * b42;
      t7 += v5 * b52;
      t8 += v5 * b62;
      t9 += v5 * b7;
      t10 += v5 * b8;
      t11 += v5 * b9;
      t12 += v5 * b10;
      t13 += v5 * b11;
      t14 += v5 * b12;
      t15 += v5 * b13;
      t16 += v5 * b14;
      t17 += v5 * b15;
      v5 = a4[3];
      t3 += v5 * b0;
      t4 += v5 * b1;
      t5 += v5 * b22;
      t6 += v5 * b32;
      t7 += v5 * b42;
      t8 += v5 * b52;
      t9 += v5 * b62;
      t10 += v5 * b7;
      t11 += v5 * b8;
      t12 += v5 * b9;
      t13 += v5 * b10;
      t14 += v5 * b11;
      t15 += v5 * b12;
      t16 += v5 * b13;
      t17 += v5 * b14;
      t18 += v5 * b15;
      v5 = a4[4];
      t4 += v5 * b0;
      t5 += v5 * b1;
      t6 += v5 * b22;
      t7 += v5 * b32;
      t8 += v5 * b42;
      t9 += v5 * b52;
      t10 += v5 * b62;
      t11 += v5 * b7;
      t12 += v5 * b8;
      t13 += v5 * b9;
      t14 += v5 * b10;
      t15 += v5 * b11;
      t16 += v5 * b12;
      t17 += v5 * b13;
      t18 += v5 * b14;
      t19 += v5 * b15;
      v5 = a4[5];
      t5 += v5 * b0;
      t6 += v5 * b1;
      t7 += v5 * b22;
      t8 += v5 * b32;
      t9 += v5 * b42;
      t10 += v5 * b52;
      t11 += v5 * b62;
      t12 += v5 * b7;
      t13 += v5 * b8;
      t14 += v5 * b9;
      t15 += v5 * b10;
      t16 += v5 * b11;
      t17 += v5 * b12;
      t18 += v5 * b13;
      t19 += v5 * b14;
      t20 += v5 * b15;
      v5 = a4[6];
      t6 += v5 * b0;
      t7 += v5 * b1;
      t8 += v5 * b22;
      t9 += v5 * b32;
      t10 += v5 * b42;
      t11 += v5 * b52;
      t12 += v5 * b62;
      t13 += v5 * b7;
      t14 += v5 * b8;
      t15 += v5 * b9;
      t16 += v5 * b10;
      t17 += v5 * b11;
      t18 += v5 * b12;
      t19 += v5 * b13;
      t20 += v5 * b14;
      t21 += v5 * b15;
      v5 = a4[7];
      t7 += v5 * b0;
      t8 += v5 * b1;
      t9 += v5 * b22;
      t10 += v5 * b32;
      t11 += v5 * b42;
      t12 += v5 * b52;
      t13 += v5 * b62;
      t14 += v5 * b7;
      t15 += v5 * b8;
      t16 += v5 * b9;
      t17 += v5 * b10;
      t18 += v5 * b11;
      t19 += v5 * b12;
      t20 += v5 * b13;
      t21 += v5 * b14;
      t222 += v5 * b15;
      v5 = a4[8];
      t8 += v5 * b0;
      t9 += v5 * b1;
      t10 += v5 * b22;
      t11 += v5 * b32;
      t12 += v5 * b42;
      t13 += v5 * b52;
      t14 += v5 * b62;
      t15 += v5 * b7;
      t16 += v5 * b8;
      t17 += v5 * b9;
      t18 += v5 * b10;
      t19 += v5 * b11;
      t20 += v5 * b12;
      t21 += v5 * b13;
      t222 += v5 * b14;
      t23 += v5 * b15;
      v5 = a4[9];
      t9 += v5 * b0;
      t10 += v5 * b1;
      t11 += v5 * b22;
      t12 += v5 * b32;
      t13 += v5 * b42;
      t14 += v5 * b52;
      t15 += v5 * b62;
      t16 += v5 * b7;
      t17 += v5 * b8;
      t18 += v5 * b9;
      t19 += v5 * b10;
      t20 += v5 * b11;
      t21 += v5 * b12;
      t222 += v5 * b13;
      t23 += v5 * b14;
      t24 += v5 * b15;
      v5 = a4[10];
      t10 += v5 * b0;
      t11 += v5 * b1;
      t12 += v5 * b22;
      t13 += v5 * b32;
      t14 += v5 * b42;
      t15 += v5 * b52;
      t16 += v5 * b62;
      t17 += v5 * b7;
      t18 += v5 * b8;
      t19 += v5 * b9;
      t20 += v5 * b10;
      t21 += v5 * b11;
      t222 += v5 * b12;
      t23 += v5 * b13;
      t24 += v5 * b14;
      t25 += v5 * b15;
      v5 = a4[11];
      t11 += v5 * b0;
      t12 += v5 * b1;
      t13 += v5 * b22;
      t14 += v5 * b32;
      t15 += v5 * b42;
      t16 += v5 * b52;
      t17 += v5 * b62;
      t18 += v5 * b7;
      t19 += v5 * b8;
      t20 += v5 * b9;
      t21 += v5 * b10;
      t222 += v5 * b11;
      t23 += v5 * b12;
      t24 += v5 * b13;
      t25 += v5 * b14;
      t26 += v5 * b15;
      v5 = a4[12];
      t12 += v5 * b0;
      t13 += v5 * b1;
      t14 += v5 * b22;
      t15 += v5 * b32;
      t16 += v5 * b42;
      t17 += v5 * b52;
      t18 += v5 * b62;
      t19 += v5 * b7;
      t20 += v5 * b8;
      t21 += v5 * b9;
      t222 += v5 * b10;
      t23 += v5 * b11;
      t24 += v5 * b12;
      t25 += v5 * b13;
      t26 += v5 * b14;
      t27 += v5 * b15;
      v5 = a4[13];
      t13 += v5 * b0;
      t14 += v5 * b1;
      t15 += v5 * b22;
      t16 += v5 * b32;
      t17 += v5 * b42;
      t18 += v5 * b52;
      t19 += v5 * b62;
      t20 += v5 * b7;
      t21 += v5 * b8;
      t222 += v5 * b9;
      t23 += v5 * b10;
      t24 += v5 * b11;
      t25 += v5 * b12;
      t26 += v5 * b13;
      t27 += v5 * b14;
      t28 += v5 * b15;
      v5 = a4[14];
      t14 += v5 * b0;
      t15 += v5 * b1;
      t16 += v5 * b22;
      t17 += v5 * b32;
      t18 += v5 * b42;
      t19 += v5 * b52;
      t20 += v5 * b62;
      t21 += v5 * b7;
      t222 += v5 * b8;
      t23 += v5 * b9;
      t24 += v5 * b10;
      t25 += v5 * b11;
      t26 += v5 * b12;
      t27 += v5 * b13;
      t28 += v5 * b14;
      t29 += v5 * b15;
      v5 = a4[15];
      t15 += v5 * b0;
      t16 += v5 * b1;
      t17 += v5 * b22;
      t18 += v5 * b32;
      t19 += v5 * b42;
      t20 += v5 * b52;
      t21 += v5 * b62;
      t222 += v5 * b7;
      t23 += v5 * b8;
      t24 += v5 * b9;
      t25 += v5 * b10;
      t26 += v5 * b11;
      t27 += v5 * b12;
      t28 += v5 * b13;
      t29 += v5 * b14;
      t30 += v5 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t22 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t222;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c5 = 1;
      v5 = t0 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t0 = v5 - c5 * 65536;
      v5 = t1 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t1 = v5 - c5 * 65536;
      v5 = t22 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t22 = v5 - c5 * 65536;
      v5 = t3 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t3 = v5 - c5 * 65536;
      v5 = t4 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t4 = v5 - c5 * 65536;
      v5 = t5 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t5 = v5 - c5 * 65536;
      v5 = t6 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t6 = v5 - c5 * 65536;
      v5 = t7 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t7 = v5 - c5 * 65536;
      v5 = t8 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t8 = v5 - c5 * 65536;
      v5 = t9 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t9 = v5 - c5 * 65536;
      v5 = t10 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t10 = v5 - c5 * 65536;
      v5 = t11 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t11 = v5 - c5 * 65536;
      v5 = t12 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t12 = v5 - c5 * 65536;
      v5 = t13 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t13 = v5 - c5 * 65536;
      v5 = t14 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t14 = v5 - c5 * 65536;
      v5 = t15 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t15 = v5 - c5 * 65536;
      t0 += c5 - 1 + 37 * (c5 - 1);
      c5 = 1;
      v5 = t0 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t0 = v5 - c5 * 65536;
      v5 = t1 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t1 = v5 - c5 * 65536;
      v5 = t22 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t22 = v5 - c5 * 65536;
      v5 = t3 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t3 = v5 - c5 * 65536;
      v5 = t4 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t4 = v5 - c5 * 65536;
      v5 = t5 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t5 = v5 - c5 * 65536;
      v5 = t6 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t6 = v5 - c5 * 65536;
      v5 = t7 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t7 = v5 - c5 * 65536;
      v5 = t8 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t8 = v5 - c5 * 65536;
      v5 = t9 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t9 = v5 - c5 * 65536;
      v5 = t10 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t10 = v5 - c5 * 65536;
      v5 = t11 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t11 = v5 - c5 * 65536;
      v5 = t12 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t12 = v5 - c5 * 65536;
      v5 = t13 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t13 = v5 - c5 * 65536;
      v5 = t14 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t14 = v5 - c5 * 65536;
      v5 = t15 + c5 + 65535;
      c5 = Math.floor(v5 / 65536);
      t15 = v5 - c5 * 65536;
      t0 += c5 - 1 + 37 * (c5 - 1);
      o3[0] = t0;
      o3[1] = t1;
      o3[2] = t22;
      o3[3] = t3;
      o3[4] = t4;
      o3[5] = t5;
      o3[6] = t6;
      o3[7] = t7;
      o3[8] = t8;
      o3[9] = t9;
      o3[10] = t10;
      o3[11] = t11;
      o3[12] = t12;
      o3[13] = t13;
      o3[14] = t14;
      o3[15] = t15;
    }
    function square(o3, a4) {
      mul3(o3, a4, a4);
    }
    function inv25519(o3, i4) {
      const c5 = gf();
      let a4;
      for (a4 = 0; a4 < 16; a4++) {
        c5[a4] = i4[a4];
      }
      for (a4 = 253; a4 >= 0; a4--) {
        square(c5, c5);
        if (a4 !== 2 && a4 !== 4) {
          mul3(c5, c5, i4);
        }
      }
      for (a4 = 0; a4 < 16; a4++) {
        o3[a4] = c5[a4];
      }
    }
    function pow2523(o3, i4) {
      const c5 = gf();
      let a4;
      for (a4 = 0; a4 < 16; a4++) {
        c5[a4] = i4[a4];
      }
      for (a4 = 250; a4 >= 0; a4--) {
        square(c5, c5);
        if (a4 !== 1) {
          mul3(c5, c5, i4);
        }
      }
      for (a4 = 0; a4 < 16; a4++) {
        o3[a4] = c5[a4];
      }
    }
    function edadd(p6, q5) {
      const a4 = gf(), b6 = gf(), c5 = gf(), d4 = gf(), e3 = gf(), f5 = gf(), g7 = gf(), h6 = gf(), t3 = gf();
      sub(a4, p6[1], p6[0]);
      sub(t3, q5[1], q5[0]);
      mul3(a4, a4, t3);
      add3(b6, p6[0], p6[1]);
      add3(t3, q5[0], q5[1]);
      mul3(b6, b6, t3);
      mul3(c5, p6[3], q5[3]);
      mul3(c5, c5, D22);
      mul3(d4, p6[2], q5[2]);
      add3(d4, d4, d4);
      sub(e3, b6, a4);
      sub(f5, d4, c5);
      add3(g7, d4, c5);
      add3(h6, b6, a4);
      mul3(p6[0], e3, f5);
      mul3(p6[1], h6, g7);
      mul3(p6[2], g7, f5);
      mul3(p6[3], e3, h6);
    }
    function cswap(p6, q5, b6) {
      for (let i4 = 0; i4 < 4; i4++) {
        sel25519(p6[i4], q5[i4], b6);
      }
    }
    function pack3(r5, p6) {
      const tx = gf(), ty = gf(), zi2 = gf();
      inv25519(zi2, p6[2]);
      mul3(tx, p6[0], zi2);
      mul3(ty, p6[1], zi2);
      pack25519(r5, ty);
      r5[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p6, q5, s3) {
      set25519(p6[0], gf0);
      set25519(p6[1], gf1);
      set25519(p6[2], gf1);
      set25519(p6[3], gf0);
      for (let i4 = 255; i4 >= 0; --i4) {
        const b6 = s3[i4 / 8 | 0] >> (i4 & 7) & 1;
        cswap(p6, q5, b6);
        edadd(q5, p6);
        edadd(p6, p6);
        cswap(p6, q5, b6);
      }
    }
    function scalarbase(p6, s3) {
      const q5 = [gf(), gf(), gf(), gf()];
      set25519(q5[0], X4);
      set25519(q5[1], Y);
      set25519(q5[2], gf1);
      mul3(q5[3], X4, Y);
      scalarmult(p6, q5, s3);
    }
    function generateKeyPairFromSeed2(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
      }
      const d4 = (0, sha512_1.hash)(seed);
      d4[0] &= 248;
      d4[31] &= 127;
      d4[31] |= 64;
      const publicKey = new Uint8Array(32);
      const p6 = [gf(), gf(), gf(), gf()];
      scalarbase(p6, d4);
      pack3(publicKey, p6);
      const secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey,
        secretKey
      };
    }
    exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
    function generateKeyPair3(prng) {
      const seed = (0, random_1.randomBytes)(32, prng);
      const result = generateKeyPairFromSeed2(seed);
      (0, wipe_1.wipe)(seed);
      return result;
    }
    exports.generateKeyPair = generateKeyPair3;
    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
      }
      return new Uint8Array(secretKey.subarray(32));
    }
    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L4 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function modL(r5, x5) {
      let carry;
      let i4;
      let j7;
      let k5;
      for (i4 = 63; i4 >= 32; --i4) {
        carry = 0;
        for (j7 = i4 - 32, k5 = i4 - 12; j7 < k5; ++j7) {
          x5[j7] += carry - 16 * x5[i4] * L4[j7 - (i4 - 32)];
          carry = Math.floor((x5[j7] + 128) / 256);
          x5[j7] -= carry * 256;
        }
        x5[j7] += carry;
        x5[i4] = 0;
      }
      carry = 0;
      for (j7 = 0; j7 < 32; j7++) {
        x5[j7] += carry - (x5[31] >> 4) * L4[j7];
        carry = x5[j7] >> 8;
        x5[j7] &= 255;
      }
      for (j7 = 0; j7 < 32; j7++) {
        x5[j7] -= carry * L4[j7];
      }
      for (i4 = 0; i4 < 32; i4++) {
        x5[i4 + 1] += x5[i4] >> 8;
        r5[i4] = x5[i4] & 255;
      }
    }
    function reduce2(r5) {
      const x5 = new Float64Array(64);
      for (let i4 = 0; i4 < 64; i4++) {
        x5[i4] = r5[i4];
      }
      for (let i4 = 0; i4 < 64; i4++) {
        r5[i4] = 0;
      }
      modL(r5, x5);
    }
    function sign4(secretKey, message) {
      const x5 = new Float64Array(64);
      const p6 = [gf(), gf(), gf(), gf()];
      const d4 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d4[0] &= 248;
      d4[31] &= 127;
      d4[31] |= 64;
      const signature2 = new Uint8Array(64);
      signature2.set(d4.subarray(32), 32);
      const hs3 = new sha512_1.SHA512();
      hs3.update(signature2.subarray(32));
      hs3.update(message);
      const r5 = hs3.digest();
      hs3.clean();
      reduce2(r5);
      scalarbase(p6, r5);
      pack3(signature2, p6);
      hs3.reset();
      hs3.update(signature2.subarray(0, 32));
      hs3.update(secretKey.subarray(32));
      hs3.update(message);
      const h6 = hs3.digest();
      reduce2(h6);
      for (let i4 = 0; i4 < 32; i4++) {
        x5[i4] = r5[i4];
      }
      for (let i4 = 0; i4 < 32; i4++) {
        for (let j7 = 0; j7 < 32; j7++) {
          x5[i4 + j7] += h6[i4] * d4[j7];
        }
      }
      modL(signature2.subarray(32), x5);
      return signature2;
    }
    exports.sign = sign4;
    function unpackneg(r5, p6) {
      const t3 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r5[2], gf1);
      unpack25519(r5[1], p6);
      square(num, r5[1]);
      mul3(den, num, D6);
      sub(num, num, r5[2]);
      add3(den, r5[2], den);
      square(den2, den);
      square(den4, den2);
      mul3(den6, den4, den2);
      mul3(t3, den6, num);
      mul3(t3, t3, den);
      pow2523(t3, t3);
      mul3(t3, t3, num);
      mul3(t3, t3, den);
      mul3(t3, t3, den);
      mul3(r5[0], t3, den);
      square(chk, r5[0]);
      mul3(chk, chk, den);
      if (neq25519(chk, num)) {
        mul3(r5[0], r5[0], I3);
      }
      square(chk, r5[0]);
      mul3(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r5[0]) === p6[31] >> 7) {
        sub(r5[0], gf0, r5[0]);
      }
      mul3(r5[3], r5[0], r5[1]);
      return 0;
    }
    function verify4(publicKey, message, signature2) {
      const t3 = new Uint8Array(32);
      const p6 = [gf(), gf(), gf(), gf()];
      const q5 = [gf(), gf(), gf(), gf()];
      if (signature2.length !== exports.SIGNATURE_LENGTH) {
        throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
      }
      if (unpackneg(q5, publicKey)) {
        return false;
      }
      const hs3 = new sha512_1.SHA512();
      hs3.update(signature2.subarray(0, 32));
      hs3.update(publicKey);
      hs3.update(message);
      const h6 = hs3.digest();
      reduce2(h6);
      scalarmult(p6, q5, h6);
      scalarbase(q5, signature2.subarray(32));
      edadd(p6, q5);
      pack3(t3, p6);
      if (verify32(signature2, t3)) {
        return false;
      }
      return true;
    }
    exports.verify = verify4;
    function convertPublicKeyToX25519(publicKey) {
      let q5 = [gf(), gf(), gf(), gf()];
      if (unpackneg(q5, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      }
      let a4 = gf();
      let b6 = gf();
      let y7 = q5[1];
      add3(a4, gf1, y7);
      sub(b6, gf1, y7);
      inv25519(b6, b6);
      mul3(a4, a4, b6);
      let z5 = new Uint8Array(32);
      pack25519(z5, a4);
      return z5;
    }
    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    function convertSecretKeyToX25519(secretKey) {
      const d4 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
      d4[0] &= 248;
      d4[31] &= 127;
      d4[31] |= 64;
      const o3 = new Uint8Array(d4.subarray(0, 32));
      (0, wipe_1.wipe)(d4);
      return o3;
    }
    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative2() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative2;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative2() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs6 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto2(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/ws/browser.js
var require_browser3 = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index < length2) {
        var value = array2[index];
        if (predicate(value, index, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array2, values) {
      var index = -1, length2 = values.length, offset = array2.length;
      while (++index < length2) {
        array2[offset + index] = values[index];
      }
      return array2;
    }
    function arraySome(array2, predicate) {
      var index = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index < length2) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n3, iteratee) {
      var index = -1, result = Array(n3);
      while (++index < n3) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func2) {
      return function(value) {
        return func2(value);
      };
    }
    function cacheHas(cache, key2) {
      return cache.has(key2);
    }
    function getValue(object2, key2) {
      return object2 == null ? void 0 : object2[key2];
    }
    function mapToArray(map3) {
      var index = -1, result = Array(map3.size);
      map3.forEach(function(value, key2) {
        result[++index] = [key2, value];
      });
      return result;
    }
    function overArg(func2, transform) {
      return function(arg) {
        return func2(transform(arg));
      };
    }
    function setToArray(set3) {
      var index = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer3 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key2) {
      var result = this.has(key2) && delete this.__data__[key2];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key2) {
      var data3 = this.__data__;
      if (nativeCreate) {
        var result = data3[key2];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data3, key2) ? data3[key2] : void 0;
    }
    function hashHas(key2) {
      var data3 = this.__data__;
      return nativeCreate ? data3[key2] !== void 0 : hasOwnProperty.call(data3, key2);
    }
    function hashSet(key2, value) {
      var data3 = this.__data__;
      this.size += this.has(key2) ? 0 : 1;
      data3[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key2) {
      var data3 = this.__data__, index = assocIndexOf(data3, key2);
      if (index < 0) {
        return false;
      }
      var lastIndex = data3.length - 1;
      if (index == lastIndex) {
        data3.pop();
      } else {
        splice.call(data3, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key2) {
      var data3 = this.__data__, index = assocIndexOf(data3, key2);
      return index < 0 ? void 0 : data3[index][1];
    }
    function listCacheHas(key2) {
      return assocIndexOf(this.__data__, key2) > -1;
    }
    function listCacheSet(key2, value) {
      var data3 = this.__data__, index = assocIndexOf(data3, key2);
      if (index < 0) {
        ++this.size;
        data3.push([key2, value]);
      } else {
        data3[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length2 = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length2) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key2) {
      var result = getMapData(this, key2)["delete"](key2);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key2) {
      return getMapData(this, key2).get(key2);
    }
    function mapCacheHas(key2) {
      return getMapData(this, key2).has(key2);
    }
    function mapCacheSet(key2, value) {
      var data3 = getMapData(this, key2), size2 = data3.size;
      data3.set(key2, value);
      this.size += data3.size == size2 ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length2) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data3 = this.__data__ = new ListCache(entries);
      this.size = data3.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key2) {
      var data3 = this.__data__, result = data3["delete"](key2);
      this.size = data3.size;
      return result;
    }
    function stackGet(key2) {
      return this.__data__.get(key2);
    }
    function stackHas(key2) {
      return this.__data__.has(key2);
    }
    function stackSet(key2, value) {
      var data3 = this.__data__;
      if (data3 instanceof ListCache) {
        var pairs2 = data3.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key2, value]);
          this.size = ++data3.size;
          return this;
        }
        data3 = this.__data__ = new MapCache(pairs2);
      }
      data3.set(key2, value);
      this.size = data3.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key2 in value) {
        if ((inherited || hasOwnProperty.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
        isIndex(key2, length2)))) {
          result.push(key2);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key2) {
      var length2 = array2.length;
      while (length2--) {
        if (eq4(array2[length2][0], key2)) {
          return length2;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object2)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern2 = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key2 in Object(object2)) {
        if (hasOwnProperty.call(object2, key2) && key2 != "constructor") {
          result.push(key2);
        }
      }
      return result;
    }
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq4(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key2 = objProps[index];
        if (!(isPartial ? key2 in other : hasOwnProperty.call(other, key2))) {
          return false;
        }
      }
      var stacked = stack.get(object2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key2 = objProps[index];
        var objValue = object2[key2], othValue = other[key2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack) : customizer(objValue, othValue, key2, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key2 == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys2, getSymbols);
    }
    function getMapData(map3, key2) {
      var data3 = map3.__data__;
      return isKeyable(key2) ? data3[typeof key2 == "string" ? "string" : "hash"] : data3.map;
    }
    function getNative(object2, key2) {
      var value = getValue(object2, key2);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e3) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length2) {
      length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
      return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func2) {
      return !!maskSrcKey && maskSrcKey in func2;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func2) {
      if (func2 != null) {
        try {
          return funcToString.call(func2);
        } catch (e3) {
        }
        try {
          return func2 + "";
        } catch (e3) {
        }
      }
      return "";
    }
    function eq4(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject3(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject3(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object2) {
      return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F6() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F6.prototype = global2;
      return new F6();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e3) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name2) {
          if (typeof name2 !== "string") {
            name2 = String(name2);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name2.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator2 = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator2[Symbol.iterator] = function() {
              return iterator2;
            };
          }
          return iterator2;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name2) {
              this.append(name2, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name2) {
              this.append(name2, headers[name2]);
            }, this);
          }
        }
        Headers.prototype.append = function(name2, value) {
          name2 = normalizeName(name2);
          value = normalizeValue(value);
          var oldValue = this.map[name2];
          this.map[name2] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name2) {
          delete this.map[normalizeName(name2)];
        };
        Headers.prototype.get = function(name2) {
          name2 = normalizeName(name2);
          return this.has(name2) ? this.map[name2] : null;
        };
        Headers.prototype.has = function(name2) {
          return this.map.hasOwnProperty(normalizeName(name2));
        };
        Headers.prototype.set = function(name2, value) {
          this.map[normalizeName(name2)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name2 in this.map) {
            if (this.map.hasOwnProperty(name2)) {
              callback.call(thisArg, this.map[name2], name2, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push(name2);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name2) {
            items.push([name2, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i4 = 0; i4 < view.length; i4++) {
            chars[i4] = String.fromCharCode(view[i4]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode8);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode8(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name2 = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name2), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key2 = parts.shift().trim();
            if (key2) {
              var value = parts.join(":").trim();
              headers.append(key2, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name2) {
            this.message = message;
            this.name = name2;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch3(input, init2) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init2);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name2) {
              xhr.setRequestHeader(name2, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch3.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch3;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch3;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_6, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key2}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN3(number2, base4, endian) {
        if (BN3.isBN(number2)) {
          return number2;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number2 !== null) {
          if (base4 === "le" || base4 === "be") {
            endian = base4;
            base4 = 10;
          }
          this._init(number2 || 0, base4 || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN3;
      } else {
        exports2.BN = BN3;
      }
      BN3.BN = BN3;
      BN3.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require_buffer().Buffer;
        }
      } catch (e3) {
      }
      BN3.isBN = function isBN(num) {
        if (num instanceof BN3) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
      };
      BN3.max = function max3(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN3.min = function min3(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN3.prototype._init = function init2(number2, base4, endian) {
        if (typeof number2 === "number") {
          return this._initNumber(number2, base4, endian);
        }
        if (typeof number2 === "object") {
          return this._initArray(number2, base4, endian);
        }
        if (base4 === "hex") {
          base4 = 16;
        }
        assert3(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
        number2 = number2.toString().replace(/\s+/g, "");
        var start = 0;
        if (number2[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number2.length) {
          if (base4 === 16) {
            this._parseHex(number2, start, endian);
          } else {
            this._parseBase(number2, base4, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base4, endian);
            }
          }
        }
      };
      BN3.prototype._initNumber = function _initNumber(number2, base4, endian) {
        if (number2 < 0) {
          this.negative = 1;
          number2 = -number2;
        }
        if (number2 < 67108864) {
          this.words = [number2 & 67108863];
          this.length = 1;
        } else if (number2 < 4503599627370496) {
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert3(number2 < 9007199254740992);
          this.words = [
            number2 & 67108863,
            number2 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base4, endian);
      };
      BN3.prototype._initArray = function _initArray(number2, base4, endian) {
        assert3(typeof number2.length === "number");
        if (number2.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number2.length / 3);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var j7, w5;
        var off = 0;
        if (endian === "be") {
          for (i4 = number2.length - 1, j7 = 0; i4 >= 0; i4 -= 3) {
            w5 = number2[i4] | number2[i4 - 1] << 8 | number2[i4 - 2] << 16;
            this.words[j7] |= w5 << off & 67108863;
            this.words[j7 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j7++;
            }
          }
        } else if (endian === "le") {
          for (i4 = 0, j7 = 0; i4 < number2.length; i4 += 3) {
            w5 = number2[i4] | number2[i4 + 1] << 8 | number2[i4 + 2] << 16;
            this.words[j7] |= w5 << off & 67108863;
            this.words[j7 + 1] = w5 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j7++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string3, index) {
        var c5 = string3.charCodeAt(index);
        if (c5 >= 48 && c5 <= 57) {
          return c5 - 48;
        } else if (c5 >= 65 && c5 <= 70) {
          return c5 - 55;
        } else if (c5 >= 97 && c5 <= 102) {
          return c5 - 87;
        } else {
          assert3(false, "Invalid character in " + string3);
        }
      }
      function parseHexByte(string3, lowerBound, index) {
        var r5 = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound) {
          r5 |= parseHex4Bits(string3, index - 1) << 4;
        }
        return r5;
      }
      BN3.prototype._parseHex = function _parseHex(number2, start, endian) {
        this.length = Math.ceil((number2.length - start) / 6);
        this.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          this.words[i4] = 0;
        }
        var off = 0;
        var j7 = 0;
        var w5;
        if (endian === "be") {
          for (i4 = number2.length - 1; i4 >= start; i4 -= 2) {
            w5 = parseHexByte(number2, start, i4) << off;
            this.words[j7] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j7 += 1;
              this.words[j7] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number2.length - start;
          for (i4 = parseLength % 2 === 0 ? start + 1 : start; i4 < number2.length; i4 += 2) {
            w5 = parseHexByte(number2, start, i4) << off;
            this.words[j7] |= w5 & 67108863;
            if (off >= 18) {
              off -= 18;
              j7 += 1;
              this.words[j7] |= w5 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul3) {
        var r5 = 0;
        var b6 = 0;
        var len = Math.min(str.length, end);
        for (var i4 = start; i4 < len; i4++) {
          var c5 = str.charCodeAt(i4) - 48;
          r5 *= mul3;
          if (c5 >= 49) {
            b6 = c5 - 49 + 10;
          } else if (c5 >= 17) {
            b6 = c5 - 17 + 10;
          } else {
            b6 = c5;
          }
          assert3(c5 >= 0 && b6 < mul3, "Invalid character");
          r5 += b6;
        }
        return r5;
      }
      BN3.prototype._parseBase = function _parseBase(number2, base4, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base4 | 0;
        var total = number2.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i4 = start; i4 < end; i4 += limbLen) {
          word = parseBase(number2, i4, i4 + limbLen, base4);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number2, i4, number2.length, base4);
          for (i4 = 0; i4 < mod; i4++) {
            pow *= base4;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN3.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i4 = 0; i4 < this.length; i4++) {
          dest.words[i4] = this.words[i4];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN3.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN3.prototype.clone = function clone() {
        var r5 = new BN3(null);
        this.copy(r5);
        return r5;
      };
      BN3.prototype._expand = function _expand(size2) {
        while (this.length < size2) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN3.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN3.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
        } catch (e3) {
          BN3.prototype.inspect = inspect4;
        }
      } else {
        BN3.prototype.inspect = inspect4;
      }
      function inspect4() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros2 = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN3.prototype.toString = function toString4(base4, padding2) {
        base4 = base4 || 10;
        padding2 = padding2 | 0 || 1;
        var out;
        if (base4 === 16 || base4 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i4 = 0; i4 < this.length; i4++) {
            var w5 = this.words[i4];
            var word = ((w5 << off | carry) & 16777215).toString(16);
            carry = w5 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i4--;
            }
            if (carry !== 0 || i4 !== this.length - 1) {
              out = zeros2[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
          var groupSize = groupSizes[base4];
          var groupBase = groupBases[base4];
          out = "";
          var c5 = this.clone();
          c5.negative = 0;
          while (!c5.isZero()) {
            var r5 = c5.modrn(groupBase).toString(base4);
            c5 = c5.idivn(groupBase);
            if (!c5.isZero()) {
              out = zeros2[groupSize - r5.length] + r5 + out;
            } else {
              out = r5 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding2 !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert3(false, "Base should be between 2 and 36");
      };
      BN3.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert3(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN3.prototype.toJSON = function toJSON2() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN3.prototype.toBuffer = function toBuffer(endian, length2) {
          return this.toArrayLike(Buffer3, endian, length2);
        };
      }
      BN3.prototype.toArray = function toArray2(endian, length2) {
        return this.toArrayLike(Array, endian, length2);
      };
      var allocate = function allocate2(ArrayType, size2) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size2);
        }
        return new ArrayType(size2);
      };
      BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length2 || Math.max(1, byteLength);
        assert3(byteLength <= reqLength, "byte array longer than desired length");
        assert3(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i4 = 0, shift = 0; i4 < this.length; i4++) {
          var word = this.words[i4] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN3.prototype._countBits = function _countBits(w5) {
          return 32 - Math.clz32(w5);
        };
      } else {
        BN3.prototype._countBits = function _countBits(w5) {
          var t3 = w5;
          var r5 = 0;
          if (t3 >= 4096) {
            r5 += 13;
            t3 >>>= 13;
          }
          if (t3 >= 64) {
            r5 += 7;
            t3 >>>= 7;
          }
          if (t3 >= 8) {
            r5 += 4;
            t3 >>>= 4;
          }
          if (t3 >= 2) {
            r5 += 2;
            t3 >>>= 2;
          }
          return r5 + t3;
        };
      }
      BN3.prototype._zeroBits = function _zeroBits(w5) {
        if (w5 === 0)
          return 26;
        var t3 = w5;
        var r5 = 0;
        if ((t3 & 8191) === 0) {
          r5 += 13;
          t3 >>>= 13;
        }
        if ((t3 & 127) === 0) {
          r5 += 7;
          t3 >>>= 7;
        }
        if ((t3 & 15) === 0) {
          r5 += 4;
          t3 >>>= 4;
        }
        if ((t3 & 3) === 0) {
          r5 += 2;
          t3 >>>= 2;
        }
        if ((t3 & 1) === 0) {
          r5++;
        }
        return r5;
      };
      BN3.prototype.bitLength = function bitLength() {
        var w5 = this.words[this.length - 1];
        var hi = this._countBits(w5);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w5 = new Array(num.bitLength());
        for (var bit = 0; bit < w5.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w5[bit] = num.words[off] >>> wbit & 1;
        }
        return w5;
      }
      BN3.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r5 = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var b6 = this._zeroBits(this.words[i4]);
          r5 += b6;
          if (b6 !== 26)
            break;
        }
        return r5;
      };
      BN3.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN3.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN3.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN3.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN3.prototype.neg = function neg3() {
        return this.clone().ineg();
      };
      BN3.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN3.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i4 = 0; i4 < num.length; i4++) {
          this.words[i4] = this.words[i4] | num.words[i4];
        }
        return this._strip();
      };
      BN3.prototype.ior = function ior(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN3.prototype.or = function or3(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN3.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN3.prototype.iuand = function iuand(num) {
        var b6;
        if (this.length > num.length) {
          b6 = num;
        } else {
          b6 = this;
        }
        for (var i4 = 0; i4 < b6.length; i4++) {
          this.words[i4] = this.words[i4] & num.words[i4];
        }
        this.length = b6.length;
        return this._strip();
      };
      BN3.prototype.iand = function iand(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN3.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN3.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN3.prototype.iuxor = function iuxor(num) {
        var a4;
        var b6;
        if (this.length > num.length) {
          a4 = this;
          b6 = num;
        } else {
          a4 = num;
          b6 = this;
        }
        for (var i4 = 0; i4 < b6.length; i4++) {
          this.words[i4] = a4.words[i4] ^ b6.words[i4];
        }
        if (this !== a4) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = a4.length;
        return this._strip();
      };
      BN3.prototype.ixor = function ixor(num) {
        assert3((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN3.prototype.xor = function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN3.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN3.prototype.inotn = function inotn(width) {
        assert3(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i4 = 0; i4 < bytesNeeded; i4++) {
          this.words[i4] = ~this.words[i4] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i4] = ~this.words[i4] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN3.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN3.prototype.setn = function setn(bit, val) {
        assert3(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN3.prototype.iadd = function iadd(num) {
        var r5;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r5 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r5 = this.isub(num);
          num.negative = 1;
          return r5._normSign();
        }
        var a4, b6;
        if (this.length > num.length) {
          a4 = this;
          b6 = num;
        } else {
          a4 = num;
          b6 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b6.length; i4++) {
          r5 = (a4.words[i4] | 0) + (b6.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          this.words[i4] = r5 & 67108863;
          carry = r5 >>> 26;
        }
        this.length = a4.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        return this;
      };
      BN3.prototype.add = function add3(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN3.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r5 = this.iadd(num);
          num.negative = 1;
          return r5._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a4, b6;
        if (cmp > 0) {
          a4 = this;
          b6 = num;
        } else {
          a4 = num;
          b6 = this;
        }
        var carry = 0;
        for (var i4 = 0; i4 < b6.length; i4++) {
          r5 = (a4.words[i4] | 0) - (b6.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        for (; carry !== 0 && i4 < a4.length; i4++) {
          r5 = (a4.words[i4] | 0) + carry;
          carry = r5 >> 26;
          this.words[i4] = r5 & 67108863;
        }
        if (carry === 0 && i4 < a4.length && a4 !== this) {
          for (; i4 < a4.length; i4++) {
            this.words[i4] = a4.words[i4];
          }
        }
        this.length = Math.max(this.length, i4);
        if (a4 !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN3.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a4 = self2.words[0] | 0;
        var b6 = num.words[0] | 0;
        var r5 = a4 * b6;
        var lo = r5 & 67108863;
        var carry = r5 / 67108864 | 0;
        out.words[0] = lo;
        for (var k5 = 1; k5 < len; k5++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j7 = Math.max(0, k5 - self2.length + 1); j7 <= maxJ; j7++) {
            var i4 = k5 - j7 | 0;
            a4 = self2.words[i4] | 0;
            b6 = num.words[j7] | 0;
            r5 = a4 * b6 + rword;
            ncarry += r5 / 67108864 | 0;
            rword = r5 & 67108863;
          }
          out.words[k5] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k5] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a4 = self2.words;
        var b6 = num.words;
        var o3 = out.words;
        var c5 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a4[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a4[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a4[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a32 = a4[3] | 0;
        var al3 = a32 & 8191;
        var ah3 = a32 >>> 13;
        var a42 = a4[4] | 0;
        var al4 = a42 & 8191;
        var ah4 = a42 >>> 13;
        var a5 = a4[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a4[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a4[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a4[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a4[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b6[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b6[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b6[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b32 = b6[3] | 0;
        var bl3 = b32 & 8191;
        var bh3 = b32 >>> 13;
        var b42 = b6[4] | 0;
        var bl4 = b42 & 8191;
        var bh4 = b42 >>> 13;
        var b52 = b6[5] | 0;
        var bl5 = b52 & 8191;
        var bh5 = b52 >>> 13;
        var b62 = b6[6] | 0;
        var bl6 = b62 & 8191;
        var bh6 = b62 >>> 13;
        var b7 = b6[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b6[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b6[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w22 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
        w22 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w32 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
        w32 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w42 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
        w42 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c5 + lo | 0) + ((mid & 8191) << 13) | 0;
        c5 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w22;
        o3[3] = w32;
        o3[4] = w42;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c5 !== 0) {
          o3[19] = c5;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k5 = 0; k5 < out.length - 1; k5++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k5, num.length - 1);
          for (var j7 = Math.max(0, k5 - self2.length + 1); j7 <= maxJ; j7++) {
            var i4 = k5 - j7;
            var a4 = self2.words[i4] | 0;
            var b6 = num.words[j7] | 0;
            var r5 = a4 * b6;
            var lo = r5 & 67108863;
            ncarry = ncarry + (r5 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k5] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k5] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN3.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x5, y7) {
        this.x = x5;
        this.y = y7;
      }
      FFTM.prototype.makeRBT = function makeRBT(N15) {
        var t3 = new Array(N15);
        var l4 = BN3.prototype._countBits(N15) - 1;
        for (var i4 = 0; i4 < N15; i4++) {
          t3[i4] = this.revBin(i4, l4, N15);
        }
        return t3;
      };
      FFTM.prototype.revBin = function revBin(x5, l4, N15) {
        if (x5 === 0 || x5 === N15 - 1)
          return x5;
        var rb = 0;
        for (var i4 = 0; i4 < l4; i4++) {
          rb |= (x5 & 1) << l4 - i4 - 1;
          x5 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N15) {
        for (var i4 = 0; i4 < N15; i4++) {
          rtws[i4] = rws[rbt[i4]];
          itws[i4] = iws[rbt[i4]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N15, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N15);
        for (var s3 = 1; s3 < N15; s3 <<= 1) {
          var l4 = s3 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l4);
          var itwdf = Math.sin(2 * Math.PI / l4);
          for (var p6 = 0; p6 < N15; p6 += l4) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j7 = 0; j7 < s3; j7++) {
              var re3 = rtws[p6 + j7];
              var ie3 = itws[p6 + j7];
              var ro = rtws[p6 + j7 + s3];
              var io = itws[p6 + j7 + s3];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p6 + j7] = re3 + ro;
              itws[p6 + j7] = ie3 + io;
              rtws[p6 + j7 + s3] = re3 - ro;
              itws[p6 + j7 + s3] = ie3 - io;
              if (j7 !== l4) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n3, m5) {
        var N15 = Math.max(m5, n3) | 1;
        var odd = N15 & 1;
        var i4 = 0;
        for (N15 = N15 / 2 | 0; N15; N15 = N15 >>> 1) {
          i4++;
        }
        return 1 << i4 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N15) {
        if (N15 <= 1)
          return;
        for (var i4 = 0; i4 < N15 / 2; i4++) {
          var t3 = rws[i4];
          rws[i4] = rws[N15 - i4 - 1];
          rws[N15 - i4 - 1] = t3;
          t3 = iws[i4];
          iws[i4] = -iws[N15 - i4 - 1];
          iws[N15 - i4 - 1] = -t3;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws2, N15) {
        var carry = 0;
        for (var i4 = 0; i4 < N15 / 2; i4++) {
          var w5 = Math.round(ws2[2 * i4 + 1] / N15) * 8192 + Math.round(ws2[2 * i4] / N15) + carry;
          ws2[i4] = w5 & 67108863;
          if (w5 < 67108864) {
            carry = 0;
          } else {
            carry = w5 / 67108864 | 0;
          }
        }
        return ws2;
      };
      FFTM.prototype.convert13b = function convert13b(ws2, len, rws, N15) {
        var carry = 0;
        for (var i4 = 0; i4 < len; i4++) {
          carry = carry + (ws2[i4] | 0);
          rws[2 * i4] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i4 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i4 = 2 * len; i4 < N15; ++i4) {
          rws[i4] = 0;
        }
        assert3(carry === 0);
        assert3((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N15) {
        var ph = new Array(N15);
        for (var i4 = 0; i4 < N15; i4++) {
          ph[i4] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x5, y7, out) {
        var N15 = 2 * this.guessLen13b(x5.length, y7.length);
        var rbt = this.makeRBT(N15);
        var _6 = this.stub(N15);
        var rws = new Array(N15);
        var rwst = new Array(N15);
        var iwst = new Array(N15);
        var nrws = new Array(N15);
        var nrwst = new Array(N15);
        var niwst = new Array(N15);
        var rmws = out.words;
        rmws.length = N15;
        this.convert13b(x5.words, x5.length, rws, N15);
        this.convert13b(y7.words, y7.length, nrws, N15);
        this.transform(rws, _6, rwst, iwst, N15, rbt);
        this.transform(nrws, _6, nrwst, niwst, N15, rbt);
        for (var i4 = 0; i4 < N15; i4++) {
          var rx = rwst[i4] * nrwst[i4] - iwst[i4] * niwst[i4];
          iwst[i4] = rwst[i4] * niwst[i4] + iwst[i4] * nrwst[i4];
          rwst[i4] = rx;
        }
        this.conjugate(rwst, iwst, N15);
        this.transform(rwst, iwst, rmws, _6, N15, rbt);
        this.conjugate(rmws, _6, N15);
        this.normalize13b(rmws, N15);
        out.negative = x5.negative ^ y7.negative;
        out.length = x5.length + y7.length;
        return out._strip();
      };
      BN3.prototype.mul = function mul3(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN3.prototype.mulf = function mulf(num) {
        var out = new BN3(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN3.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN3.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(typeof num === "number");
        assert3(num < 67108864);
        var carry = 0;
        for (var i4 = 0; i4 < this.length; i4++) {
          var w5 = (this.words[i4] | 0) * num;
          var lo = (w5 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w5 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i4] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN3.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN3.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN3.prototype.pow = function pow(num) {
        var w5 = toBitArray(num);
        if (w5.length === 0)
          return new BN3(1);
        var res = this;
        for (var i4 = 0; i4 < w5.length; i4++, res = res.sqr()) {
          if (w5[i4] !== 0)
            break;
        }
        if (++i4 < w5.length) {
          for (var q5 = res.sqr(); i4 < w5.length; i4++, q5 = q5.sqr()) {
            if (w5[i4] === 0)
              continue;
            res = res.mul(q5);
          }
        }
        return res;
      };
      BN3.prototype.iushln = function iushln(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s3 = (bits - r5) / 26;
        var carryMask = 67108863 >>> 26 - r5 << 26 - r5;
        var i4;
        if (r5 !== 0) {
          var carry = 0;
          for (i4 = 0; i4 < this.length; i4++) {
            var newCarry = this.words[i4] & carryMask;
            var c5 = (this.words[i4] | 0) - newCarry << r5;
            this.words[i4] = c5 | carry;
            carry = newCarry >>> 26 - r5;
          }
          if (carry) {
            this.words[i4] = carry;
            this.length++;
          }
        }
        if (s3 !== 0) {
          for (i4 = this.length - 1; i4 >= 0; i4--) {
            this.words[i4 + s3] = this.words[i4];
          }
          for (i4 = 0; i4 < s3; i4++) {
            this.words[i4] = 0;
          }
          this.length += s3;
        }
        return this._strip();
      };
      BN3.prototype.ishln = function ishln(bits) {
        assert3(this.negative === 0);
        return this.iushln(bits);
      };
      BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert3(typeof bits === "number" && bits >= 0);
        var h6;
        if (hint) {
          h6 = (hint - hint % 26) / 26;
        } else {
          h6 = 0;
        }
        var r5 = bits % 26;
        var s3 = Math.min((bits - r5) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r5 << r5;
        var maskedWords = extended;
        h6 -= s3;
        h6 = Math.max(0, h6);
        if (maskedWords) {
          for (var i4 = 0; i4 < s3; i4++) {
            maskedWords.words[i4] = this.words[i4];
          }
          maskedWords.length = s3;
        }
        if (s3 === 0) {
        } else if (this.length > s3) {
          this.length -= s3;
          for (i4 = 0; i4 < this.length; i4++) {
            this.words[i4] = this.words[i4 + s3];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i4 = this.length - 1; i4 >= 0 && (carry !== 0 || i4 >= h6); i4--) {
          var word = this.words[i4] | 0;
          this.words[i4] = carry << 26 - r5 | word >>> r5;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert3(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN3.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN3.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN3.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN3.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN3.prototype.testn = function testn(bit) {
        assert3(typeof bit === "number" && bit >= 0);
        var r5 = bit % 26;
        var s3 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s3)
          return false;
        var w5 = this.words[s3];
        return !!(w5 & q5);
      };
      BN3.prototype.imaskn = function imaskn(bits) {
        assert3(typeof bits === "number" && bits >= 0);
        var r5 = bits % 26;
        var s3 = (bits - r5) / 26;
        assert3(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s3) {
          return this;
        }
        if (r5 !== 0) {
          s3++;
        }
        this.length = Math.min(s3, this.length);
        if (r5 !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r5 << r5;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN3.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN3.prototype.iaddn = function iaddn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN3.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i4 = 0; i4 < this.length && this.words[i4] >= 67108864; i4++) {
          this.words[i4] -= 67108864;
          if (i4 === this.length - 1) {
            this.words[i4 + 1] = 1;
          } else {
            this.words[i4 + 1]++;
          }
        }
        this.length = Math.max(this.length, i4 + 1);
        return this;
      };
      BN3.prototype.isubn = function isubn(num) {
        assert3(typeof num === "number");
        assert3(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i4 = 0; i4 < this.length && this.words[i4] < 0; i4++) {
            this.words[i4] += 67108864;
            this.words[i4 + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN3.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN3.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN3.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN3.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
        var len = num.length + shift;
        var i4;
        this._expand(len);
        var w5;
        var carry = 0;
        for (i4 = 0; i4 < num.length; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          var right = (num.words[i4] | 0) * mul3;
          w5 -= right & 67108863;
          carry = (w5 >> 26) - (right / 67108864 | 0);
          this.words[i4 + shift] = w5 & 67108863;
        }
        for (; i4 < this.length - shift; i4++) {
          w5 = (this.words[i4 + shift] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4 + shift] = w5 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert3(carry === -1);
        carry = 0;
        for (i4 = 0; i4 < this.length; i4++) {
          w5 = -(this.words[i4] | 0) + carry;
          carry = w5 >> 26;
          this.words[i4] = w5 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN3.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a4 = this.clone();
        var b6 = num;
        var bhi = b6.words[b6.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b6 = b6.ushln(shift);
          a4.iushln(shift);
          bhi = b6.words[b6.length - 1] | 0;
        }
        var m5 = a4.length - b6.length;
        var q5;
        if (mode !== "mod") {
          q5 = new BN3(null);
          q5.length = m5 + 1;
          q5.words = new Array(q5.length);
          for (var i4 = 0; i4 < q5.length; i4++) {
            q5.words[i4] = 0;
          }
        }
        var diff = a4.clone()._ishlnsubmul(b6, 1, m5);
        if (diff.negative === 0) {
          a4 = diff;
          if (q5) {
            q5.words[m5] = 1;
          }
        }
        for (var j7 = m5 - 1; j7 >= 0; j7--) {
          var qj = (a4.words[b6.length + j7] | 0) * 67108864 + (a4.words[b6.length + j7 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a4._ishlnsubmul(b6, qj, j7);
          while (a4.negative !== 0) {
            qj--;
            a4.negative = 0;
            a4._ishlnsubmul(b6, 1, j7);
            if (!a4.isZero()) {
              a4.negative ^= 1;
            }
          }
          if (q5) {
            q5.words[j7] = qj;
          }
        }
        if (q5) {
          q5._strip();
        }
        a4._strip();
        if (mode !== "div" && shift !== 0) {
          a4.iushrn(shift);
        }
        return {
          div: q5 || null,
          mod: a4
        };
      };
      BN3.prototype.divmod = function divmod(num, mode, positive) {
        assert3(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN3(0),
            mod: new BN3(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN3(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN3(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN3.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN3.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN3.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN3.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN3.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var p6 = (1 << 26) % num;
        var acc = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          acc = (p6 * acc + (this.words[i4] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN3.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN3.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert3(num <= 67108863);
        var carry = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var w5 = (this.words[i4] | 0) + carry * 67108864;
          this.words[i4] = w5 / num | 0;
          carry = w5 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN3.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN3.prototype.egcd = function egcd(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var x5 = this;
        var y7 = p6.clone();
        if (x5.negative !== 0) {
          x5 = x5.umod(p6);
        } else {
          x5 = x5.clone();
        }
        var A5 = new BN3(1);
        var B5 = new BN3(0);
        var C2 = new BN3(0);
        var D6 = new BN3(1);
        var g7 = 0;
        while (x5.isEven() && y7.isEven()) {
          x5.iushrn(1);
          y7.iushrn(1);
          ++g7;
        }
        var yp = y7.clone();
        var xp = x5.clone();
        while (!x5.isZero()) {
          for (var i4 = 0, im = 1; (x5.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            x5.iushrn(i4);
            while (i4-- > 0) {
              if (A5.isOdd() || B5.isOdd()) {
                A5.iadd(yp);
                B5.isub(xp);
              }
              A5.iushrn(1);
              B5.iushrn(1);
            }
          }
          for (var j7 = 0, jm = 1; (y7.words[0] & jm) === 0 && j7 < 26; ++j7, jm <<= 1)
            ;
          if (j7 > 0) {
            y7.iushrn(j7);
            while (j7-- > 0) {
              if (C2.isOdd() || D6.isOdd()) {
                C2.iadd(yp);
                D6.isub(xp);
              }
              C2.iushrn(1);
              D6.iushrn(1);
            }
          }
          if (x5.cmp(y7) >= 0) {
            x5.isub(y7);
            A5.isub(C2);
            B5.isub(D6);
          } else {
            y7.isub(x5);
            C2.isub(A5);
            D6.isub(B5);
          }
        }
        return {
          a: C2,
          b: D6,
          gcd: y7.iushln(g7)
        };
      };
      BN3.prototype._invmp = function _invmp(p6) {
        assert3(p6.negative === 0);
        assert3(!p6.isZero());
        var a4 = this;
        var b6 = p6.clone();
        if (a4.negative !== 0) {
          a4 = a4.umod(p6);
        } else {
          a4 = a4.clone();
        }
        var x1 = new BN3(1);
        var x22 = new BN3(0);
        var delta = b6.clone();
        while (a4.cmpn(1) > 0 && b6.cmpn(1) > 0) {
          for (var i4 = 0, im = 1; (a4.words[0] & im) === 0 && i4 < 26; ++i4, im <<= 1)
            ;
          if (i4 > 0) {
            a4.iushrn(i4);
            while (i4-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j7 = 0, jm = 1; (b6.words[0] & jm) === 0 && j7 < 26; ++j7, jm <<= 1)
            ;
          if (j7 > 0) {
            b6.iushrn(j7);
            while (j7-- > 0) {
              if (x22.isOdd()) {
                x22.iadd(delta);
              }
              x22.iushrn(1);
            }
          }
          if (a4.cmp(b6) >= 0) {
            a4.isub(b6);
            x1.isub(x22);
          } else {
            b6.isub(a4);
            x22.isub(x1);
          }
        }
        var res;
        if (a4.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x22;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p6);
        }
        return res;
      };
      BN3.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a4 = this.clone();
        var b6 = num.clone();
        a4.negative = 0;
        b6.negative = 0;
        for (var shift = 0; a4.isEven() && b6.isEven(); shift++) {
          a4.iushrn(1);
          b6.iushrn(1);
        }
        do {
          while (a4.isEven()) {
            a4.iushrn(1);
          }
          while (b6.isEven()) {
            b6.iushrn(1);
          }
          var r5 = a4.cmp(b6);
          if (r5 < 0) {
            var t3 = a4;
            a4 = b6;
            b6 = t3;
          } else if (r5 === 0 || b6.cmpn(1) === 0) {
            break;
          }
          a4.isub(b6);
        } while (true);
        return b6.iushln(shift);
      };
      BN3.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN3.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN3.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN3.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN3.prototype.bincn = function bincn(bit) {
        assert3(typeof bit === "number");
        var r5 = bit % 26;
        var s3 = (bit - r5) / 26;
        var q5 = 1 << r5;
        if (this.length <= s3) {
          this._expand(s3 + 1);
          this.words[s3] |= q5;
          return this;
        }
        var carry = q5;
        for (var i4 = s3; carry !== 0 && i4 < this.length; i4++) {
          var w5 = this.words[i4] | 0;
          w5 += carry;
          carry = w5 >>> 26;
          w5 &= 67108863;
          this.words[i4] = w5;
        }
        if (carry !== 0) {
          this.words[i4] = carry;
          this.length++;
        }
        return this;
      };
      BN3.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN3.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert3(num <= 67108863, "Number is too big");
          var w5 = this.words[0] | 0;
          res = w5 === num ? 0 : w5 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN3.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i4 = this.length - 1; i4 >= 0; i4--) {
          var a4 = this.words[i4] | 0;
          var b6 = num.words[i4] | 0;
          if (a4 === b6)
            continue;
          if (a4 < b6) {
            res = -1;
          } else if (a4 > b6) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN3.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN3.prototype.gt = function gt3(num) {
        return this.cmp(num) === 1;
      };
      BN3.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN3.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN3.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN3.prototype.lt = function lt3(num) {
        return this.cmp(num) === -1;
      };
      BN3.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN3.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN3.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN3.prototype.eq = function eq4(num) {
        return this.cmp(num) === 0;
      };
      BN3.red = function red(num) {
        return new Red(num);
      };
      BN3.prototype.toRed = function toRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        assert3(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN3.prototype.fromRed = function fromRed() {
        assert3(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN3.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN3.prototype.forceRed = function forceRed(ctx) {
        assert3(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN3.prototype.redAdd = function redAdd(num) {
        assert3(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN3.prototype.redIAdd = function redIAdd(num) {
        assert3(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN3.prototype.redSub = function redSub(num) {
        assert3(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN3.prototype.redISub = function redISub(num) {
        assert3(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN3.prototype.redShl = function redShl(num) {
        assert3(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN3.prototype.redMul = function redMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN3.prototype.redIMul = function redIMul(num) {
        assert3(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN3.prototype.redSqr = function redSqr() {
        assert3(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN3.prototype.redISqr = function redISqr() {
        assert3(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN3.prototype.redSqrt = function redSqrt() {
        assert3(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN3.prototype.redInvm = function redInvm() {
        assert3(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN3.prototype.redNeg = function redNeg() {
        assert3(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN3.prototype.redPow = function redPow(num) {
        assert3(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name2, p6) {
        this.name = name2;
        this.p = new BN3(p6, 16);
        this.n = this.p.bitLength();
        this.k = new BN3(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN3(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r5 = num;
        var rlen;
        do {
          this.split(r5, this.tmp);
          r5 = this.imulK(r5);
          r5 = r5.iadd(this.tmp);
          rlen = r5.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r5.ucmp(this.p);
        if (cmp === 0) {
          r5.words[0] = 0;
          r5.length = 1;
        } else if (cmp > 0) {
          r5.isub(this.p);
        } else {
          if (r5.strip !== void 0) {
            r5.strip();
          } else {
            r5._strip();
          }
        }
        return r5;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i4 = 0; i4 < outLen; i4++) {
          output.words[i4] = input.words[i4];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask2;
        for (i4 = 10; i4 < input.length; i4++) {
          var next = input.words[i4] | 0;
          input.words[i4 - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i4 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var w5 = num.words[i4] | 0;
          lo += w5 * 977;
          num.words[i4] = lo & 67108863;
          lo = w5 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i4 = 0; i4 < num.length; i4++) {
          var hi = (num.words[i4] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i4] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN3._prime = function prime(name2) {
        if (primes[name2])
          return primes[name2];
        var prime2;
        if (name2 === "k256") {
          prime2 = new K256();
        } else if (name2 === "p224") {
          prime2 = new P224();
        } else if (name2 === "p192") {
          prime2 = new P192();
        } else if (name2 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name2);
        }
        primes[name2] = prime2;
        return prime2;
      };
      function Red(m5) {
        if (typeof m5 === "string") {
          var prime = BN3._prime(m5);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert3(m5.gtn(1), "modulus must be greater than 1");
          this.m = m5;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a4) {
        assert3(a4.negative === 0, "red works only with positives");
        assert3(a4.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a4, b6) {
        assert3((a4.negative | b6.negative) === 0, "red works only with positives");
        assert3(
          a4.red && a4.red === b6.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a4) {
        if (this.prime)
          return this.prime.ireduce(a4)._forceRed(this);
        move(a4, a4.umod(this.m)._forceRed(this));
        return a4;
      };
      Red.prototype.neg = function neg3(a4) {
        if (a4.isZero()) {
          return a4.clone();
        }
        return this.m.sub(a4)._forceRed(this);
      };
      Red.prototype.add = function add3(a4, b6) {
        this._verify2(a4, b6);
        var res = a4.add(b6);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a4, b6) {
        this._verify2(a4, b6);
        var res = a4.iadd(b6);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a4, b6) {
        this._verify2(a4, b6);
        var res = a4.sub(b6);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a4, b6) {
        this._verify2(a4, b6);
        var res = a4.isub(b6);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a4, num) {
        this._verify1(a4);
        return this.imod(a4.ushln(num));
      };
      Red.prototype.imul = function imul(a4, b6) {
        this._verify2(a4, b6);
        return this.imod(a4.imul(b6));
      };
      Red.prototype.mul = function mul3(a4, b6) {
        this._verify2(a4, b6);
        return this.imod(a4.mul(b6));
      };
      Red.prototype.isqr = function isqr(a4) {
        return this.imul(a4, a4.clone());
      };
      Red.prototype.sqr = function sqr(a4) {
        return this.mul(a4, a4);
      };
      Red.prototype.sqrt = function sqrt(a4) {
        if (a4.isZero())
          return a4.clone();
        var mod3 = this.m.andln(3);
        assert3(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN3(1)).iushrn(2);
          return this.pow(a4, pow);
        }
        var q5 = this.m.subn(1);
        var s3 = 0;
        while (!q5.isZero() && q5.andln(1) === 0) {
          s3++;
          q5.iushrn(1);
        }
        assert3(!q5.isZero());
        var one = new BN3(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z5 = this.m.bitLength();
        z5 = new BN3(2 * z5 * z5).toRed(this);
        while (this.pow(z5, lpow).cmp(nOne) !== 0) {
          z5.redIAdd(nOne);
        }
        var c5 = this.pow(z5, q5);
        var r5 = this.pow(a4, q5.addn(1).iushrn(1));
        var t3 = this.pow(a4, q5);
        var m5 = s3;
        while (t3.cmp(one) !== 0) {
          var tmp = t3;
          for (var i4 = 0; tmp.cmp(one) !== 0; i4++) {
            tmp = tmp.redSqr();
          }
          assert3(i4 < m5);
          var b6 = this.pow(c5, new BN3(1).iushln(m5 - i4 - 1));
          r5 = r5.redMul(b6);
          c5 = b6.redSqr();
          t3 = t3.redMul(c5);
          m5 = i4;
        }
        return r5;
      };
      Red.prototype.invm = function invm(a4) {
        var inv = a4._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a4, num) {
        if (num.isZero())
          return new BN3(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a4.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN3(1).toRed(this);
        wnd[1] = a4;
        for (var i4 = 2; i4 < wnd.length; i4++) {
          wnd[i4] = this.mul(wnd[i4 - 1], a4);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i4 = num.length - 1; i4 >= 0; i4--) {
          var word = num.words[i4];
          for (var j7 = start - 1; j7 >= 0; j7--) {
            var bit = word >> j7 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i4 !== 0 || j7 !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r5 = num.umod(this.m);
        return r5 === num ? r5.clone() : r5;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN3.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m5) {
        Red.call(this, m5);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN3(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r5 = this.imod(num.mul(this.rinv));
        r5.red = null;
        return r5;
      };
      Mont.prototype.imul = function imul(a4, b6) {
        if (a4.isZero() || b6.isZero()) {
          a4.words[0] = 0;
          a4.length = 1;
          return a4;
        }
        var t3 = a4.imul(b6);
        var c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t3.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul3(a4, b6) {
        if (a4.isZero() || b6.isZero())
          return new BN3(0)._forceRed(this);
        var t3 = a4.mul(b6);
        var c5 = t3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u5 = t3.isub(c5).iushrn(this.shift);
        var res = u5;
        if (u5.cmp(this.m) >= 0) {
          res = u5.isub(this.m);
        } else if (u5.cmpn(0) < 0) {
          res = u5.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a4) {
        var res = this.imod(a4._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding2, outputType) {
        return function(message) {
          return new Keccak(bits2, padding2, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding2, outputType) {
        return function(message, outputBits, n3, s3) {
          return methods["cshake" + bits2].update(message, outputBits, n3, s3)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding2, outputType) {
        return function(key2, message, outputBits, s3) {
          return methods["kmac" + bits2].update(key2, message, outputBits, s3)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding2) {
        for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
          var type2 = OUTPUT_TYPES[i5];
          method[type2] = createMethod2(bits2, padding2, type2);
        }
        return method;
      };
      var createMethod = function(bits2, padding2) {
        var method = createOutputMethod(bits2, padding2, "hex");
        method.create = function() {
          return new Keccak(bits2, padding2, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding2);
      };
      var createShakeMethod = function(bits2, padding2) {
        var method = createShakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
      };
      var createCshakeMethod = function(bits2, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding2, "hex");
        method.create = function(outputBits, n3, s3) {
          if (!n3 && !s3) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding2, outputBits).bytepad([n3, s3], w5);
          }
        };
        method.update = function(message, outputBits, n3, s3) {
          return method.create(outputBits, n3, s3).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
      };
      var createKmacMethod = function(bits2, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding2, "hex");
        method.create = function(key2, outputBits, s3) {
          return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s3], w5).bytepad([key2], w5);
        };
        method.update = function(key2, message, outputBits, s3) {
          return method.create(key2, outputBits, s3).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i4 = 0; i4 < algorithms.length; ++i4) {
        var algorithm = algorithms[i4];
        var bits = algorithm.bits;
        for (var j7 = 0; j7 < bits.length; ++j7) {
          var methodName = algorithm.name + "_" + bits[j7];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j7], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j7];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i5 = 0; i5 < 50; ++i5) {
          this.s[i5] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type2 = typeof message;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i5, code2;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i5 = 1; i5 < blockCount + 1; ++i5) {
              blocks[i5] = 0;
            }
          }
          if (notString) {
            for (i5 = this.start; index < length2 && i5 < byteCount; ++index) {
              blocks[i5 >> 2] |= message[index] << SHIFT[i5++ & 3];
            }
          } else {
            for (i5 = this.start; index < length2 && i5 < byteCount; ++index) {
              code2 = message.charCodeAt(index);
              if (code2 < 128) {
                blocks[i5 >> 2] |= code2 << SHIFT[i5++ & 3];
              } else if (code2 < 2048) {
                blocks[i5 >> 2] |= (192 | code2 >> 6) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i5 >> 2] |= (224 | code2 >> 12) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i5 >> 2] |= (240 | code2 >> 18) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              }
            }
          }
          this.lastByteIndex = i5;
          if (i5 >= byteCount) {
            this.start = i5 - byteCount;
            this.block = blocks[blockCount];
            for (i5 = 0; i5 < blockCount; ++i5) {
              s3[i5] ^= blocks[i5];
            }
            f5(s3);
            this.reset = true;
          } else {
            this.start = i5;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x5, right) {
        var o3 = x5 & 255, n3 = 1;
        var bytes = [o3];
        x5 = x5 >> 8;
        o3 = x5 & 255;
        while (o3 > 0) {
          bytes.unshift(o3);
          x5 = x5 >> 8;
          o3 = x5 & 255;
          ++n3;
        }
        if (right) {
          bytes.push(n3);
        } else {
          bytes.unshift(n3);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type2 = typeof str;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length2 = str.length;
        if (notString) {
          bytes = length2;
        } else {
          for (var i5 = 0; i5 < str.length; ++i5) {
            var code2 = str.charCodeAt(i5);
            if (code2 < 128) {
              bytes += 1;
            } else if (code2 < 2048) {
              bytes += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i5) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w5) {
        var bytes = this.encode(w5);
        for (var i5 = 0; i5 < strs.length; ++i5) {
          bytes += this.encodeString(strs[i5]);
        }
        var paddingBytes = w5 - bytes % w5;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i5 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks[i5 >> 2] |= this.padding[i5 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i5 = 1; i5 < blockCount + 1; ++i5) {
            blocks[i5] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i5 = 0; i5 < blockCount; ++i5) {
          s3[i5] ^= blocks[i5];
        }
        f5(s3);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j8 = 0;
        var hex = "", block;
        while (j8 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j8 < outputBlocks; ++i5, ++j8) {
            block = s3[i5];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j8 % blockCount === 0) {
            f5(s3);
            i5 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i5];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j8 = 0;
        var bytes = this.outputBits >> 3;
        var buffer2;
        if (extraBytes) {
          buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer2 = new ArrayBuffer(bytes);
        }
        var array2 = new Uint32Array(buffer2);
        while (j8 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j8 < outputBlocks; ++i5, ++j8) {
            array2[j8] = s3[i5];
          }
          if (j8 % blockCount === 0) {
            f5(s3);
          }
        }
        if (extraBytes) {
          array2[i5] = s3[i5];
          buffer2 = buffer2.slice(0, bytes);
        }
        return buffer2;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j8 = 0;
        var array2 = [], offset, block;
        while (j8 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j8 < outputBlocks; ++i5, ++j8) {
            offset = j8 << 2;
            block = s3[i5];
            array2[offset] = block & 255;
            array2[offset + 1] = block >> 8 & 255;
            array2[offset + 2] = block >> 16 & 255;
            array2[offset + 3] = block >> 24 & 255;
          }
          if (j8 % blockCount === 0) {
            f5(s3);
          }
        }
        if (extraBytes) {
          offset = j8 << 2;
          block = s3[i5];
          array2[offset] = block & 255;
          if (extraBytes > 1) {
            array2[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array2[offset + 2] = block >> 16 & 255;
          }
        }
        return array2;
      };
      function Kmac(bits2, padding2, outputBits) {
        Keccak.call(this, bits2, padding2, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f5 = function(s3) {
        var h6, l4, n3, c0, c1, c22, c32, c42, c5, c6, c7, c8, c9, b0, b1, b22, b32, b42, b52, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
        for (n3 = 0; n3 < 48; n3 += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c32 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c42 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h6 = c8 ^ (c22 << 1 | c32 >>> 31);
          l4 = c9 ^ (c32 << 1 | c22 >>> 31);
          s3[0] ^= h6;
          s3[1] ^= l4;
          s3[10] ^= h6;
          s3[11] ^= l4;
          s3[20] ^= h6;
          s3[21] ^= l4;
          s3[30] ^= h6;
          s3[31] ^= l4;
          s3[40] ^= h6;
          s3[41] ^= l4;
          h6 = c0 ^ (c42 << 1 | c5 >>> 31);
          l4 = c1 ^ (c5 << 1 | c42 >>> 31);
          s3[2] ^= h6;
          s3[3] ^= l4;
          s3[12] ^= h6;
          s3[13] ^= l4;
          s3[22] ^= h6;
          s3[23] ^= l4;
          s3[32] ^= h6;
          s3[33] ^= l4;
          s3[42] ^= h6;
          s3[43] ^= l4;
          h6 = c22 ^ (c6 << 1 | c7 >>> 31);
          l4 = c32 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h6;
          s3[5] ^= l4;
          s3[14] ^= h6;
          s3[15] ^= l4;
          s3[24] ^= h6;
          s3[25] ^= l4;
          s3[34] ^= h6;
          s3[35] ^= l4;
          s3[44] ^= h6;
          s3[45] ^= l4;
          h6 = c42 ^ (c8 << 1 | c9 >>> 31);
          l4 = c5 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h6;
          s3[7] ^= l4;
          s3[16] ^= h6;
          s3[17] ^= l4;
          s3[26] ^= h6;
          s3[27] ^= l4;
          s3[36] ^= h6;
          s3[37] ^= l4;
          s3[46] ^= h6;
          s3[47] ^= l4;
          h6 = c6 ^ (c0 << 1 | c1 >>> 31);
          l4 = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h6;
          s3[9] ^= l4;
          s3[18] ^= h6;
          s3[19] ^= l4;
          s3[28] ^= h6;
          s3[29] ^= l4;
          s3[38] ^= h6;
          s3[39] ^= l4;
          s3[48] ^= h6;
          s3[49] ^= l4;
          b0 = s3[0];
          b1 = s3[1];
          b322 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b22 = s3[13] << 12 | s3[12] >>> 20;
          b32 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b222 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b42 = s3[25] << 11 | s3[24] >>> 21;
          b52 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b422 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b6 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b22 & b42;
          s3[1] = b1 ^ ~b32 & b52;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b222 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b322 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b422 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b22 ^ ~b42 & b6;
          s3[3] = b32 ^ ~b52 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b222 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b322 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b422 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b42 ^ ~b6 & b8;
          s3[5] = b52 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b6 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b22;
          s3[9] = b9 ^ ~b1 & b32;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b222;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b322;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b422;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n3];
          s3[1] ^= RC[n3 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i4 = 0; i4 < methodNames.length; ++i4) {
          root[methodNames[i4]] = methods[methodNames[i4]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert3;
    function assert3(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert3.equal = function assertEqual2(l4, r5, msg) {
      if (l4 != r5)
        throw new Error(msg || "Assertion failed: " + l4 + " != " + r5);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils3 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert3 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i4) {
      if ((msg.charCodeAt(i4) & 64512) !== 55296) {
        return false;
      }
      if (i4 < 0 || i4 + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i4 + 1) & 64512) === 56320;
    }
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p6 = 0;
          for (var i4 = 0; i4 < msg.length; i4++) {
            var c5 = msg.charCodeAt(i4);
            if (c5 < 128) {
              res[p6++] = c5;
            } else if (c5 < 2048) {
              res[p6++] = c5 >> 6 | 192;
              res[p6++] = c5 & 63 | 128;
            } else if (isSurrogatePair(msg, i4)) {
              c5 = 65536 + ((c5 & 1023) << 10) + (msg.charCodeAt(++i4) & 1023);
              res[p6++] = c5 >> 18 | 240;
              res[p6++] = c5 >> 12 & 63 | 128;
              res[p6++] = c5 >> 6 & 63 | 128;
              res[p6++] = c5 & 63 | 128;
            } else {
              res[p6++] = c5 >> 12 | 224;
              res[p6++] = c5 >> 6 & 63 | 128;
              res[p6++] = c5 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i4 = 0; i4 < msg.length; i4 += 2)
            res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
        }
      } else {
        for (i4 = 0; i4 < msg.length; i4++)
          res[i4] = msg[i4] | 0;
      }
      return res;
    }
    exports.toArray = toArray2;
    function toHex2(msg) {
      var res = "";
      for (var i4 = 0; i4 < msg.length; i4++)
        res += zero2(msg[i4].toString(16));
      return res;
    }
    exports.toHex = toHex2;
    function htonl(w5) {
      var res = w5 >>> 24 | w5 >>> 8 & 65280 | w5 << 8 & 16711680 | (w5 & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i4 = 0; i4 < msg.length; i4++) {
        var w5 = msg[i4];
        if (endian === "little")
          w5 = htonl(w5);
        res += zero8(w5.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert3(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i4 = 0, k5 = start; i4 < res.length; i4++, k5 += 4) {
        var w5;
        if (endian === "big")
          w5 = msg[k5] << 24 | msg[k5 + 1] << 16 | msg[k5 + 2] << 8 | msg[k5 + 3];
        else
          w5 = msg[k5 + 3] << 24 | msg[k5 + 2] << 16 | msg[k5 + 1] << 8 | msg[k5];
        res[i4] = w5 >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i4 = 0, k5 = 0; i4 < msg.length; i4++, k5 += 4) {
        var m5 = msg[i4];
        if (endian === "big") {
          res[k5] = m5 >>> 24;
          res[k5 + 1] = m5 >>> 16 & 255;
          res[k5 + 2] = m5 >>> 8 & 255;
          res[k5 + 3] = m5 & 255;
        } else {
          res[k5 + 3] = m5 >>> 24;
          res[k5 + 2] = m5 >>> 16 & 255;
          res[k5 + 1] = m5 >>> 8 & 255;
          res[k5] = m5 & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w5, b6) {
      return w5 >>> b6 | w5 << 32 - b6;
    }
    exports.rotr32 = rotr32;
    function rotl32(w5, b6) {
      return w5 << b6 | w5 >>> 32 - b6;
    }
    exports.rotl32 = rotl32;
    function sum32(a4, b6) {
      return a4 + b6 >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a4, b6, c5) {
      return a4 + b6 + c5 >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a4, b6, c5, d4) {
      return a4 + b6 + c5 + d4 >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a4, b6, c5, d4, e3) {
      return a4 + b6 + c5 + d4 + e3 >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r5 = al << 32 - num | ah >>> num;
      return r5 >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r5 = ah << 32 - num | al >>> num;
      return r5 >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r5 = ah << 32 - num | al >>> num;
      return r5 >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var assert3 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r5 = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r5, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r5, this.endian);
        for (var i4 = 0; i4 < msg.length; i4 += this._delta32)
          this._update(msg, i4, i4 + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest2(enc) {
      this.update(this._pad());
      assert3(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k5 = bytes - (len + this.padLength) % bytes;
      var res = new Array(k5 + this.padLength);
      res[0] = 128;
      for (var i4 = 1; i4 < k5; i4++)
        res[i4] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t3 = 8; t3 < this.padLength; t3++)
          res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = len >>> 24 & 255;
        res[i4++] = len >>> 16 & 255;
        res[i4++] = len >>> 8 & 255;
        res[i4++] = len & 255;
      } else {
        res[i4++] = len & 255;
        res[i4++] = len >>> 8 & 255;
        res[i4++] = len >>> 16 & 255;
        res[i4++] = len >>> 24 & 255;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        res[i4++] = 0;
        for (t3 = 8; t3 < this.padLength; t3++)
          res[i4++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var rotr32 = utils.rotr32;
    function ft_1(s3, x5, y7, z5) {
      if (s3 === 0)
        return ch32(x5, y7, z5);
      if (s3 === 1 || s3 === 3)
        return p32(x5, y7, z5);
      if (s3 === 2)
        return maj32(x5, y7, z5);
    }
    exports.ft_1 = ft_1;
    function ch32(x5, y7, z5) {
      return x5 & y7 ^ ~x5 & z5;
    }
    exports.ch32 = ch32;
    function maj32(x5, y7, z5) {
      return x5 & y7 ^ x5 & z5 ^ y7 & z5;
    }
    exports.maj32 = maj32;
    function p32(x5, y7, z5) {
      return x5 ^ y7 ^ z5;
    }
    exports.p32 = p32;
    function s0_256(x5) {
      return rotr32(x5, 2) ^ rotr32(x5, 13) ^ rotr32(x5, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x5) {
      return rotr32(x5, 6) ^ rotr32(x5, 11) ^ rotr32(x5, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x5) {
      return rotr32(x5, 7) ^ rotr32(x5, 18) ^ x5 >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x5) {
      return rotr32(x5, 17) ^ rotr32(x5, 19) ^ x5 >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i4 = 0; i4 < 16; i4++)
        W4[i4] = msg[start + i4];
      for (; i4 < W4.length; i4++)
        W4[i4] = rotl32(W4[i4 - 3] ^ W4[i4 - 8] ^ W4[i4 - 14] ^ W4[i4 - 16], 1);
      var a4 = this.h[0];
      var b6 = this.h[1];
      var c5 = this.h[2];
      var d4 = this.h[3];
      var e3 = this.h[4];
      for (i4 = 0; i4 < W4.length; i4++) {
        var s3 = ~~(i4 / 20);
        var t3 = sum32_5(rotl32(a4, 5), ft_1(s3, b6, c5, d4), e3, W4[i4], sha1_K[s3]);
        e3 = d4;
        d4 = c5;
        c5 = rotl32(b6, 30);
        b6 = a4;
        a4 = t3;
      }
      this.h[0] = sum32(this.h[0], a4);
      this.h[1] = sum32(this.h[1], b6);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d4);
      this.h[4] = sum32(this.h[4], e3);
    };
    SHA1.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var shaCommon = require_common2();
    var assert3 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W4 = this.W;
      for (var i4 = 0; i4 < 16; i4++)
        W4[i4] = msg[start + i4];
      for (; i4 < W4.length; i4++)
        W4[i4] = sum32_4(g1_256(W4[i4 - 2]), W4[i4 - 7], g0_256(W4[i4 - 15]), W4[i4 - 16]);
      var a4 = this.h[0];
      var b6 = this.h[1];
      var c5 = this.h[2];
      var d4 = this.h[3];
      var e3 = this.h[4];
      var f5 = this.h[5];
      var g7 = this.h[6];
      var h6 = this.h[7];
      assert3(this.k.length === W4.length);
      for (i4 = 0; i4 < W4.length; i4++) {
        var T1 = sum32_5(h6, s1_256(e3), ch32(e3, f5, g7), this.k[i4], W4[i4]);
        var T22 = sum32(s0_256(a4), maj32(a4, b6, c5));
        h6 = g7;
        g7 = f5;
        f5 = e3;
        e3 = sum32(d4, T1);
        d4 = c5;
        c5 = b6;
        b6 = a4;
        a4 = sum32(T1, T22);
      }
      this.h[0] = sum32(this.h[0], a4);
      this.h[1] = sum32(this.h[1], b6);
      this.h[2] = sum32(this.h[2], c5);
      this.h[3] = sum32(this.h[3], d4);
      this.h[4] = sum32(this.h[4], e3);
      this.h[5] = sum32(this.h[5], f5);
      this.h[6] = sum32(this.h[6], g7);
      this.h[7] = sum32(this.h[7], h6);
    };
    SHA256.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var assert3 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W4 = this.W;
      for (var i4 = 0; i4 < 32; i4++)
        W4[i4] = msg[start + i4];
      for (; i4 < W4.length; i4 += 2) {
        var c0_hi = g1_512_hi(W4[i4 - 4], W4[i4 - 3]);
        var c0_lo = g1_512_lo(W4[i4 - 4], W4[i4 - 3]);
        var c1_hi = W4[i4 - 14];
        var c1_lo = W4[i4 - 13];
        var c2_hi = g0_512_hi(W4[i4 - 30], W4[i4 - 29]);
        var c2_lo = g0_512_lo(W4[i4 - 30], W4[i4 - 29]);
        var c3_hi = W4[i4 - 32];
        var c3_lo = W4[i4 - 31];
        W4[i4] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W4[i4 + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W4 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert3(this.k.length === W4.length);
      for (var i4 = 0; i4 < W4.length; i4 += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i4];
        var c3_lo = this.k[i4 + 1];
        var c4_hi = W4[i4];
        var c4_lo = W4[i4 + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r5 = xh & yh ^ ~xh & zh;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r5 = xl & yl ^ ~xl & zl;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r5 = xh & yh ^ xh & zh ^ yh & zh;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r5 = xl & yl ^ xl & zl ^ yl & zl;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r5 = c0_hi ^ c1_hi ^ c2_hi;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r5 = c0_lo ^ c1_lo ^ c2_lo;
      if (r5 < 0)
        r5 += 4294967296;
      return r5;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils = require_utils3();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update2(msg, start) {
      var A5 = this.h[0];
      var B5 = this.h[1];
      var C2 = this.h[2];
      var D6 = this.h[3];
      var E6 = this.h[4];
      var Ah = A5;
      var Bh = B5;
      var Ch = C2;
      var Dh = D6;
      var Eh = E6;
      for (var j7 = 0; j7 < 80; j7++) {
        var T4 = sum32(
          rotl32(
            sum32_4(A5, f5(j7, B5, C2, D6), msg[r5[j7] + start], K4(j7)),
            s3[j7]
          ),
          E6
        );
        A5 = E6;
        E6 = D6;
        D6 = rotl32(C2, 10);
        C2 = B5;
        B5 = T4;
        T4 = sum32(
          rotl32(
            sum32_4(Ah, f5(79 - j7, Bh, Ch, Dh), msg[rh[j7] + start], Kh(j7)),
            sh[j7]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T4;
      }
      T4 = sum32_3(this.h[1], C2, Dh);
      this.h[1] = sum32_3(this.h[2], D6, Eh);
      this.h[2] = sum32_3(this.h[3], E6, Ah);
      this.h[3] = sum32_3(this.h[4], A5, Bh);
      this.h[4] = sum32_3(this.h[0], B5, Ch);
      this.h[0] = T4;
    };
    RIPEMD160.prototype._digest = function digest2(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f5(j7, x5, y7, z5) {
      if (j7 <= 15)
        return x5 ^ y7 ^ z5;
      else if (j7 <= 31)
        return x5 & y7 | ~x5 & z5;
      else if (j7 <= 47)
        return (x5 | ~y7) ^ z5;
      else if (j7 <= 63)
        return x5 & z5 | y7 & ~z5;
      else
        return x5 ^ (y7 | ~z5);
    }
    function K4(j7) {
      if (j7 <= 15)
        return 0;
      else if (j7 <= 31)
        return 1518500249;
      else if (j7 <= 47)
        return 1859775393;
      else if (j7 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j7) {
      if (j7 <= 15)
        return 1352829926;
      else if (j7 <= 31)
        return 1548603684;
      else if (j7 <= 47)
        return 1836072691;
      else if (j7 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r5 = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s3 = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    var assert3 = require_minimalistic_assert();
    function Hmac(hash3, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash3, key2, enc);
      this.Hash = hash3;
      this.blockSize = hash3.blockSize / 8;
      this.outSize = hash3.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init2(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert3(key2.length <= this.blockSize);
      for (var i4 = key2.length; i4 < this.blockSize; i4++)
        key2.push(0);
      for (i4 = 0; i4 < key2.length; i4++)
        key2[i4] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i4 = 0; i4 < key2.length; i4++)
        key2[i4] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest2(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash3 = exports;
    hash3.utils = require_utils3();
    hash3.common = require_common();
    hash3.sha = require_sha();
    hash3.ripemd = require_ripemd();
    hash3.hmac = require_hmac2();
    hash3.sha1 = hash3.sha.sha1;
    hash3.sha256 = hash3.sha.sha256;
    hash3.sha224 = hash3.sha.sha224;
    hash3.sha384 = hash3.sha.sha384;
    hash3.sha512 = hash3.sha.sha512;
    hash3.ripemd160 = hash3.ripemd.ripemd160;
  }
});

// node_modules/aes-js/index.js
var require_aes_js = __commonJS({
  "node_modules/aes-js/index.js"(exports, module) {
    "use strict";
    (function(root) {
      function checkInt(value) {
        return parseInt(value) === value;
      }
      function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
          return false;
        }
        for (var i4 = 0; i4 < arrayish.length; i4++) {
          if (!checkInt(arrayish[i4]) || arrayish[i4] < 0 || arrayish[i4] > 255) {
            return false;
          }
        }
        return true;
      }
      function coerceArray(arg, copy) {
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
          if (copy) {
            if (arg.slice) {
              arg = arg.slice();
            } else {
              arg = Array.prototype.slice.call(arg);
            }
          }
          return arg;
        }
        if (Array.isArray(arg)) {
          if (!checkInts(arg)) {
            throw new Error("Array contains invalid value: " + arg);
          }
          return new Uint8Array(arg);
        }
        if (checkInt(arg.length) && checkInts(arg)) {
          return new Uint8Array(arg);
        }
        throw new Error("unsupported array-like object");
      }
      function createArray(length2) {
        return new Uint8Array(length2);
      }
      function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
          if (sourceArray.slice) {
            sourceArray = sourceArray.slice(sourceStart, sourceEnd);
          } else {
            sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
          }
        }
        targetArray.set(sourceArray, targetStart);
      }
      var convertUtf8 = function() {
        function toBytes(text) {
          var result = [], i4 = 0;
          text = encodeURI(text);
          while (i4 < text.length) {
            var c5 = text.charCodeAt(i4++);
            if (c5 === 37) {
              result.push(parseInt(text.substr(i4, 2), 16));
              i4 += 2;
            } else {
              result.push(c5);
            }
          }
          return coerceArray(result);
        }
        function fromBytes(bytes) {
          var result = [], i4 = 0;
          while (i4 < bytes.length) {
            var c5 = bytes[i4];
            if (c5 < 128) {
              result.push(String.fromCharCode(c5));
              i4++;
            } else if (c5 > 191 && c5 < 224) {
              result.push(String.fromCharCode((c5 & 31) << 6 | bytes[i4 + 1] & 63));
              i4 += 2;
            } else {
              result.push(String.fromCharCode((c5 & 15) << 12 | (bytes[i4 + 1] & 63) << 6 | bytes[i4 + 2] & 63));
              i4 += 3;
            }
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var convertHex = function() {
        function toBytes(text) {
          var result = [];
          for (var i4 = 0; i4 < text.length; i4 += 2) {
            result.push(parseInt(text.substr(i4, 2), 16));
          }
          return result;
        }
        var Hex = "0123456789abcdef";
        function fromBytes(bytes) {
          var result = [];
          for (var i4 = 0; i4 < bytes.length; i4++) {
            var v5 = bytes[i4];
            result.push(Hex[(v5 & 240) >> 4] + Hex[v5 & 15]);
          }
          return result.join("");
        }
        return {
          toBytes,
          fromBytes
        };
      }();
      var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
      var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
      var S5 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
      var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
      var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
      var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
      var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
      var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
      var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
      var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
      var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
      var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
      var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
      var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
      var U32 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
      var U42 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
      function convertToInt32(bytes) {
        var result = [];
        for (var i4 = 0; i4 < bytes.length; i4 += 4) {
          result.push(
            bytes[i4] << 24 | bytes[i4 + 1] << 16 | bytes[i4 + 2] << 8 | bytes[i4 + 3]
          );
        }
        return result;
      }
      var AES = function(key2) {
        if (!(this instanceof AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        Object.defineProperty(this, "key", {
          value: coerceArray(key2, true)
        });
        this._prepare();
      };
      AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
        }
        this._Ke = [];
        this._Kd = [];
        for (var i4 = 0; i4 <= rounds; i4++) {
          this._Ke.push([0, 0, 0, 0]);
          this._Kd.push([0, 0, 0, 0]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        var tk = convertToInt32(this.key);
        var index;
        for (var i4 = 0; i4 < KC; i4++) {
          index = i4 >> 2;
          this._Ke[index][i4 % 4] = tk[i4];
          this._Kd[rounds - index][i4 % 4] = tk[i4];
        }
        var rconpointer = 0;
        var t3 = KC, tt2;
        while (t3 < roundKeyCount) {
          tt2 = tk[KC - 1];
          tk[0] ^= S5[tt2 >> 16 & 255] << 24 ^ S5[tt2 >> 8 & 255] << 16 ^ S5[tt2 & 255] << 8 ^ S5[tt2 >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (var i4 = 1; i4 < KC; i4++) {
              tk[i4] ^= tk[i4 - 1];
            }
          } else {
            for (var i4 = 1; i4 < KC / 2; i4++) {
              tk[i4] ^= tk[i4 - 1];
            }
            tt2 = tk[KC / 2 - 1];
            tk[KC / 2] ^= S5[tt2 & 255] ^ S5[tt2 >> 8 & 255] << 8 ^ S5[tt2 >> 16 & 255] << 16 ^ S5[tt2 >> 24 & 255] << 24;
            for (var i4 = KC / 2 + 1; i4 < KC; i4++) {
              tk[i4] ^= tk[i4 - 1];
            }
          }
          var i4 = 0, r5, c5;
          while (i4 < KC && t3 < roundKeyCount) {
            r5 = t3 >> 2;
            c5 = t3 % 4;
            this._Ke[r5][c5] = tk[i4];
            this._Kd[rounds - r5][c5] = tk[i4++];
            t3++;
          }
        }
        for (var r5 = 1; r5 < rounds; r5++) {
          for (var c5 = 0; c5 < 4; c5++) {
            tt2 = this._Kd[r5][c5];
            this._Kd[r5][c5] = U1[tt2 >> 24 & 255] ^ U22[tt2 >> 16 & 255] ^ U32[tt2 >> 8 & 255] ^ U42[tt2 & 255];
          }
        }
      };
      AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
          throw new Error("invalid plaintext size (must be 16 bytes)");
        }
        var rounds = this._Ke.length - 1;
        var a4 = [0, 0, 0, 0];
        var t3 = convertToInt32(plaintext);
        for (var i4 = 0; i4 < 4; i4++) {
          t3[i4] ^= this._Ke[0][i4];
        }
        for (var r5 = 1; r5 < rounds; r5++) {
          for (var i4 = 0; i4 < 4; i4++) {
            a4[i4] = T1[t3[i4] >> 24 & 255] ^ T22[t3[(i4 + 1) % 4] >> 16 & 255] ^ T32[t3[(i4 + 2) % 4] >> 8 & 255] ^ T4[t3[(i4 + 3) % 4] & 255] ^ this._Ke[r5][i4];
          }
          t3 = a4.slice();
        }
        var result = createArray(16), tt2;
        for (var i4 = 0; i4 < 4; i4++) {
          tt2 = this._Ke[rounds][i4];
          result[4 * i4] = (S5[t3[i4] >> 24 & 255] ^ tt2 >> 24) & 255;
          result[4 * i4 + 1] = (S5[t3[(i4 + 1) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
          result[4 * i4 + 2] = (S5[t3[(i4 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
          result[4 * i4 + 3] = (S5[t3[(i4 + 3) % 4] & 255] ^ tt2) & 255;
        }
        return result;
      };
      AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
          throw new Error("invalid ciphertext size (must be 16 bytes)");
        }
        var rounds = this._Kd.length - 1;
        var a4 = [0, 0, 0, 0];
        var t3 = convertToInt32(ciphertext);
        for (var i4 = 0; i4 < 4; i4++) {
          t3[i4] ^= this._Kd[0][i4];
        }
        for (var r5 = 1; r5 < rounds; r5++) {
          for (var i4 = 0; i4 < 4; i4++) {
            a4[i4] = T5[t3[i4] >> 24 & 255] ^ T6[t3[(i4 + 3) % 4] >> 16 & 255] ^ T7[t3[(i4 + 2) % 4] >> 8 & 255] ^ T8[t3[(i4 + 1) % 4] & 255] ^ this._Kd[r5][i4];
          }
          t3 = a4.slice();
        }
        var result = createArray(16), tt2;
        for (var i4 = 0; i4 < 4; i4++) {
          tt2 = this._Kd[rounds][i4];
          result[4 * i4] = (Si[t3[i4] >> 24 & 255] ^ tt2 >> 24) & 255;
          result[4 * i4 + 1] = (Si[t3[(i4 + 3) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
          result[4 * i4 + 2] = (Si[t3[(i4 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
          result[4 * i4 + 3] = (Si[t3[(i4 + 1) % 4] & 255] ^ tt2) & 255;
        }
        return result;
      };
      var ModeOfOperationECB = function(key2) {
        if (!(this instanceof ModeOfOperationECB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key2);
      };
      ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i4 = 0; i4 < plaintext.length; i4 += 16) {
          copyArray(plaintext, block, 0, i4, i4 + 16);
          block = this._aes.encrypt(block);
          copyArray(block, ciphertext, i4);
        }
        return ciphertext;
      };
      ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i4 = 0; i4 < ciphertext.length; i4 += 16) {
          copyArray(ciphertext, block, 0, i4, i4 + 16);
          block = this._aes.decrypt(block);
          copyArray(block, plaintext, i4);
        }
        return plaintext;
      };
      var ModeOfOperationCBC = function(key2, iv2) {
        if (!(this instanceof ModeOfOperationCBC)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv2) {
          iv2 = createArray(16);
        } else if (iv2.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastCipherblock = coerceArray(iv2, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
          throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for (var i4 = 0; i4 < plaintext.length; i4 += 16) {
          copyArray(plaintext, block, 0, i4, i4 + 16);
          for (var j7 = 0; j7 < 16; j7++) {
            block[j7] ^= this._lastCipherblock[j7];
          }
          this._lastCipherblock = this._aes.encrypt(block);
          copyArray(this._lastCipherblock, ciphertext, i4);
        }
        return ciphertext;
      };
      ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
          throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for (var i4 = 0; i4 < ciphertext.length; i4 += 16) {
          copyArray(ciphertext, block, 0, i4, i4 + 16);
          block = this._aes.decrypt(block);
          for (var j7 = 0; j7 < 16; j7++) {
            plaintext[i4 + j7] = block[j7] ^ this._lastCipherblock[j7];
          }
          copyArray(ciphertext, this._lastCipherblock, 0, i4, i4 + 16);
        }
        return plaintext;
      };
      var ModeOfOperationCFB = function(key2, iv2, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv2) {
          iv2 = createArray(16);
        } else if (iv2.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 size)");
        }
        if (!segmentSize) {
          segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv2, true);
        this._aes = new AES(key2);
      };
      ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
          throw new Error("invalid plaintext size (must be segmentSize bytes)");
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for (var i4 = 0; i4 < encrypted.length; i4 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j7 = 0; j7 < this.segmentSize; j7++) {
            encrypted[i4 + j7] ^= xorSegment[j7];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i4, i4 + this.segmentSize);
        }
        return encrypted;
      };
      ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
          throw new Error("invalid ciphertext size (must be segmentSize bytes)");
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for (var i4 = 0; i4 < plaintext.length; i4 += this.segmentSize) {
          xorSegment = this._aes.encrypt(this._shiftRegister);
          for (var j7 = 0; j7 < this.segmentSize; j7++) {
            plaintext[i4 + j7] ^= xorSegment[j7];
          }
          copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
          copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i4, i4 + this.segmentSize);
        }
        return plaintext;
      };
      var ModeOfOperationOFB = function(key2, iv2) {
        if (!(this instanceof ModeOfOperationOFB)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv2) {
          iv2 = createArray(16);
        } else if (iv2.length != 16) {
          throw new Error("invalid initialation vector size (must be 16 bytes)");
        }
        this._lastPrecipher = coerceArray(iv2, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i4 = 0; i4 < encrypted.length; i4++) {
          if (this._lastPrecipherIndex === 16) {
            this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
            this._lastPrecipherIndex = 0;
          }
          encrypted[i4] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
      };
      ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
      var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
          throw Error("Counter must be instanitated with `new`");
        }
        if (initialValue !== 0 && !initialValue) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this._counter = createArray(16);
          this.setValue(initialValue);
        } else {
          this.setBytes(initialValue);
        }
      };
      Counter.prototype.setValue = function(value) {
        if (typeof value !== "number" || parseInt(value) != value) {
          throw new Error("invalid counter value (must be an integer)");
        }
        for (var index = 15; index >= 0; --index) {
          this._counter[index] = value % 256;
          value = value >> 8;
        }
      };
      Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
          throw new Error("invalid counter bytes size (must be 16 bytes)");
        }
        this._counter = bytes;
      };
      Counter.prototype.increment = function() {
        for (var i4 = 15; i4 >= 0; i4--) {
          if (this._counter[i4] === 255) {
            this._counter[i4] = 0;
          } else {
            this._counter[i4]++;
            break;
          }
        }
      };
      var ModeOfOperationCTR = function(key2, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
          throw Error("AES must be instanitated with `new`");
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
          counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key2);
      };
      ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for (var i4 = 0; i4 < encrypted.length; i4++) {
          if (this._remainingCounterIndex === 16) {
            this._remainingCounter = this._aes.encrypt(this._counter._counter);
            this._remainingCounterIndex = 0;
            this._counter.increment();
          }
          encrypted[i4] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
      };
      ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
      function pkcs7pad(data3) {
        data3 = coerceArray(data3, true);
        var padder = 16 - data3.length % 16;
        var result = createArray(data3.length + padder);
        copyArray(data3, result);
        for (var i4 = data3.length; i4 < result.length; i4++) {
          result[i4] = padder;
        }
        return result;
      }
      function pkcs7strip(data3) {
        data3 = coerceArray(data3, true);
        if (data3.length < 16) {
          throw new Error("PKCS#7 invalid length");
        }
        var padder = data3[data3.length - 1];
        if (padder > 16) {
          throw new Error("PKCS#7 padding byte out of range");
        }
        var length2 = data3.length - padder;
        for (var i4 = 0; i4 < padder; i4++) {
          if (data3[length2 + i4] !== padder) {
            throw new Error("PKCS#7 invalid padding byte");
          }
        }
        var result = createArray(length2);
        copyArray(data3, result, 0, 0, length2);
        return result;
      }
      var aesjs = {
        AES,
        Counter,
        ModeOfOperation: {
          ecb: ModeOfOperationECB,
          cbc: ModeOfOperationCBC,
          cfb: ModeOfOperationCFB,
          ofb: ModeOfOperationOFB,
          ctr: ModeOfOperationCTR
        },
        utils: {
          hex: convertHex,
          utf8: convertUtf8
        },
        padding: {
          pkcs7: {
            pad: pkcs7pad,
            strip: pkcs7strip
          }
        },
        _arrayTest: {
          coerceArray,
          createArray,
          copyArray
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = aesjs;
      } else if (typeof define === "function" && define.amd) {
        define(aesjs);
      } else {
        if (root.aesjs) {
          aesjs._aesjs = root.aesjs;
        }
        root.aesjs = aesjs;
      }
    })(exports);
  }
});

// node_modules/scrypt-js/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/scrypt-js/scrypt.js"(exports, module) {
    "use strict";
    (function(root) {
      const MAX_VALUE = 2147483647;
      function SHA256(m5) {
        const K4 = new Uint32Array([
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ]);
        let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h32 = 2773480762;
        let h42 = 1359893119, h52 = 2600822924, h6 = 528734635, h7 = 1541459225;
        const w5 = new Uint32Array(64);
        function blocks(p7) {
          let off = 0, len = p7.length;
          while (len >= 64) {
            let a4 = h0, b6 = h1, c5 = h22, d4 = h32, e3 = h42, f5 = h52, g7 = h6, h8 = h7, u5, i5, j7, t1, t22;
            for (i5 = 0; i5 < 16; i5++) {
              j7 = off + i5 * 4;
              w5[i5] = (p7[j7] & 255) << 24 | (p7[j7 + 1] & 255) << 16 | (p7[j7 + 2] & 255) << 8 | p7[j7 + 3] & 255;
            }
            for (i5 = 16; i5 < 64; i5++) {
              u5 = w5[i5 - 2];
              t1 = (u5 >>> 17 | u5 << 32 - 17) ^ (u5 >>> 19 | u5 << 32 - 19) ^ u5 >>> 10;
              u5 = w5[i5 - 15];
              t22 = (u5 >>> 7 | u5 << 32 - 7) ^ (u5 >>> 18 | u5 << 32 - 18) ^ u5 >>> 3;
              w5[i5] = (t1 + w5[i5 - 7] | 0) + (t22 + w5[i5 - 16] | 0) | 0;
            }
            for (i5 = 0; i5 < 64; i5++) {
              t1 = (((e3 >>> 6 | e3 << 32 - 6) ^ (e3 >>> 11 | e3 << 32 - 11) ^ (e3 >>> 25 | e3 << 32 - 25)) + (e3 & f5 ^ ~e3 & g7) | 0) + (h8 + (K4[i5] + w5[i5] | 0) | 0) | 0;
              t22 = ((a4 >>> 2 | a4 << 32 - 2) ^ (a4 >>> 13 | a4 << 32 - 13) ^ (a4 >>> 22 | a4 << 32 - 22)) + (a4 & b6 ^ a4 & c5 ^ b6 & c5) | 0;
              h8 = g7;
              g7 = f5;
              f5 = e3;
              e3 = d4 + t1 | 0;
              d4 = c5;
              c5 = b6;
              b6 = a4;
              a4 = t1 + t22 | 0;
            }
            h0 = h0 + a4 | 0;
            h1 = h1 + b6 | 0;
            h22 = h22 + c5 | 0;
            h32 = h32 + d4 | 0;
            h42 = h42 + e3 | 0;
            h52 = h52 + f5 | 0;
            h6 = h6 + g7 | 0;
            h7 = h7 + h8 | 0;
            off += 64;
            len -= 64;
          }
        }
        blocks(m5);
        let i4, bytesLeft = m5.length % 64, bitLenHi = m5.length / 536870912 | 0, bitLenLo = m5.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p6 = m5.slice(m5.length - bytesLeft, m5.length);
        p6.push(128);
        for (i4 = bytesLeft + 1; i4 < numZeros; i4++) {
          p6.push(0);
        }
        p6.push(bitLenHi >>> 24 & 255);
        p6.push(bitLenHi >>> 16 & 255);
        p6.push(bitLenHi >>> 8 & 255);
        p6.push(bitLenHi >>> 0 & 255);
        p6.push(bitLenLo >>> 24 & 255);
        p6.push(bitLenLo >>> 16 & 255);
        p6.push(bitLenLo >>> 8 & 255);
        p6.push(bitLenLo >>> 0 & 255);
        blocks(p6);
        return [
          h0 >>> 24 & 255,
          h0 >>> 16 & 255,
          h0 >>> 8 & 255,
          h0 >>> 0 & 255,
          h1 >>> 24 & 255,
          h1 >>> 16 & 255,
          h1 >>> 8 & 255,
          h1 >>> 0 & 255,
          h22 >>> 24 & 255,
          h22 >>> 16 & 255,
          h22 >>> 8 & 255,
          h22 >>> 0 & 255,
          h32 >>> 24 & 255,
          h32 >>> 16 & 255,
          h32 >>> 8 & 255,
          h32 >>> 0 & 255,
          h42 >>> 24 & 255,
          h42 >>> 16 & 255,
          h42 >>> 8 & 255,
          h42 >>> 0 & 255,
          h52 >>> 24 & 255,
          h52 >>> 16 & 255,
          h52 >>> 8 & 255,
          h52 >>> 0 & 255,
          h6 >>> 24 & 255,
          h6 >>> 16 & 255,
          h6 >>> 8 & 255,
          h6 >>> 0 & 255,
          h7 >>> 24 & 255,
          h7 >>> 16 & 255,
          h7 >>> 8 & 255,
          h7 >>> 0 & 255
        ];
      }
      function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i4;
        let dk = [];
        for (i4 = 0; i4 < 64; i4++) {
          inner[i4] = 54;
        }
        for (i4 = 0; i4 < password.length; i4++) {
          inner[i4] ^= password[i4];
        }
        for (i4 = 0; i4 < salt.length; i4++) {
          inner[64 + i4] = salt[i4];
        }
        for (i4 = innerLen - 4; i4 < innerLen; i4++) {
          inner[i4] = 0;
        }
        for (i4 = 0; i4 < 64; i4++)
          outerKey[i4] = 92;
        for (i4 = 0; i4 < password.length; i4++)
          outerKey[i4] ^= password[i4];
        function incrementCounter() {
          for (let i5 = innerLen - 1; i5 >= innerLen - 4; i5--) {
            inner[i5]++;
            if (inner[i5] <= 255)
              return;
            inner[i5] = 0;
          }
        }
        while (dkLen >= 32) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
          dkLen -= 32;
        }
        if (dkLen > 0) {
          incrementCounter();
          dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
      }
      function blockmix_salsa8(BY, Yi2, r5, x5, _X) {
        let i4;
        arraycopy(BY, (2 * r5 - 1) * 16, _X, 0, 16);
        for (i4 = 0; i4 < 2 * r5; i4++) {
          blockxor(BY, i4 * 16, _X, 16);
          salsa20_8(_X, x5);
          arraycopy(_X, 0, BY, Yi2 + i4 * 16, 16);
        }
        for (i4 = 0; i4 < r5; i4++) {
          arraycopy(BY, Yi2 + i4 * 2 * 16, BY, i4 * 16, 16);
        }
        for (i4 = 0; i4 < r5; i4++) {
          arraycopy(BY, Yi2 + (i4 * 2 + 1) * 16, BY, (i4 + r5) * 16, 16);
        }
      }
      function R3(a4, b6) {
        return a4 << b6 | a4 >>> 32 - b6;
      }
      function salsa20_8(B5, x5) {
        arraycopy(B5, 0, x5, 0, 16);
        for (let i4 = 8; i4 > 0; i4 -= 2) {
          x5[4] ^= R3(x5[0] + x5[12], 7);
          x5[8] ^= R3(x5[4] + x5[0], 9);
          x5[12] ^= R3(x5[8] + x5[4], 13);
          x5[0] ^= R3(x5[12] + x5[8], 18);
          x5[9] ^= R3(x5[5] + x5[1], 7);
          x5[13] ^= R3(x5[9] + x5[5], 9);
          x5[1] ^= R3(x5[13] + x5[9], 13);
          x5[5] ^= R3(x5[1] + x5[13], 18);
          x5[14] ^= R3(x5[10] + x5[6], 7);
          x5[2] ^= R3(x5[14] + x5[10], 9);
          x5[6] ^= R3(x5[2] + x5[14], 13);
          x5[10] ^= R3(x5[6] + x5[2], 18);
          x5[3] ^= R3(x5[15] + x5[11], 7);
          x5[7] ^= R3(x5[3] + x5[15], 9);
          x5[11] ^= R3(x5[7] + x5[3], 13);
          x5[15] ^= R3(x5[11] + x5[7], 18);
          x5[1] ^= R3(x5[0] + x5[3], 7);
          x5[2] ^= R3(x5[1] + x5[0], 9);
          x5[3] ^= R3(x5[2] + x5[1], 13);
          x5[0] ^= R3(x5[3] + x5[2], 18);
          x5[6] ^= R3(x5[5] + x5[4], 7);
          x5[7] ^= R3(x5[6] + x5[5], 9);
          x5[4] ^= R3(x5[7] + x5[6], 13);
          x5[5] ^= R3(x5[4] + x5[7], 18);
          x5[11] ^= R3(x5[10] + x5[9], 7);
          x5[8] ^= R3(x5[11] + x5[10], 9);
          x5[9] ^= R3(x5[8] + x5[11], 13);
          x5[10] ^= R3(x5[9] + x5[8], 18);
          x5[12] ^= R3(x5[15] + x5[14], 7);
          x5[13] ^= R3(x5[12] + x5[15], 9);
          x5[14] ^= R3(x5[13] + x5[12], 13);
          x5[15] ^= R3(x5[14] + x5[13], 18);
        }
        for (let i4 = 0; i4 < 16; ++i4) {
          B5[i4] += x5[i4];
        }
      }
      function blockxor(S5, Si, D6, len) {
        for (let i4 = 0; i4 < len; i4++) {
          D6[i4] ^= S5[Si + i4];
        }
      }
      function arraycopy(src2, srcPos, dest, destPos, length2) {
        while (length2--) {
          dest[destPos++] = src2[srcPos++];
        }
      }
      function checkBufferish(o3) {
        if (!o3 || typeof o3.length !== "number") {
          return false;
        }
        for (let i4 = 0; i4 < o3.length; i4++) {
          const v5 = o3[i4];
          if (typeof v5 !== "number" || v5 % 1 || v5 < 0 || v5 >= 256) {
            return false;
          }
        }
        return true;
      }
      function ensureInteger(value, name2) {
        if (typeof value !== "number" || value % 1) {
          throw new Error("invalid " + name2);
        }
        return value;
      }
      function _scrypt(password, salt, N15, r5, p6, dkLen, callback) {
        N15 = ensureInteger(N15, "N");
        r5 = ensureInteger(r5, "r");
        p6 = ensureInteger(p6, "p");
        dkLen = ensureInteger(dkLen, "dkLen");
        if (N15 === 0 || (N15 & N15 - 1) !== 0) {
          throw new Error("N must be power of 2");
        }
        if (N15 > MAX_VALUE / 128 / r5) {
          throw new Error("N too large");
        }
        if (r5 > MAX_VALUE / 128 / p6) {
          throw new Error("r too large");
        }
        if (!checkBufferish(password)) {
          throw new Error("password must be an array or buffer");
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
          throw new Error("salt must be an array or buffer");
        }
        salt = Array.prototype.slice.call(salt);
        let b6 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p6 * 128 * r5);
        const B5 = new Uint32Array(p6 * 32 * r5);
        for (let i4 = 0; i4 < B5.length; i4++) {
          const j7 = i4 * 4;
          B5[i4] = (b6[j7 + 3] & 255) << 24 | (b6[j7 + 2] & 255) << 16 | (b6[j7 + 1] & 255) << 8 | (b6[j7 + 0] & 255) << 0;
        }
        const XY = new Uint32Array(64 * r5);
        const V5 = new Uint32Array(32 * r5 * N15);
        const Yi2 = 32 * r5;
        const x5 = new Uint32Array(16);
        const _X = new Uint32Array(16);
        const totalOps = p6 * N15 * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        let stop = false;
        let state3 = 0;
        let i0 = 0, i1;
        let Bi2;
        const limit = callback ? parseInt(1e3 / r5) : 4294967295;
        const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
        const incrementalSMix = function() {
          if (stop) {
            return callback(new Error("cancelled"), currentOp / totalOps);
          }
          let steps;
          switch (state3) {
            case 0:
              Bi2 = i0 * 32 * r5;
              arraycopy(B5, Bi2, XY, 0, Yi2);
              state3 = 1;
              i1 = 0;
            case 1:
              steps = N15 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i4 = 0; i4 < steps; i4++) {
                arraycopy(XY, 0, V5, (i1 + i4) * Yi2, Yi2);
                blockmix_salsa8(XY, Yi2, r5, x5, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N15) {
                break;
              }
              i1 = 0;
              state3 = 2;
            case 2:
              steps = N15 - i1;
              if (steps > limit) {
                steps = limit;
              }
              for (let i4 = 0; i4 < steps; i4++) {
                const offset = (2 * r5 - 1) * 16;
                const j7 = XY[offset] & N15 - 1;
                blockxor(V5, j7 * Yi2, XY, Yi2);
                blockmix_salsa8(XY, Yi2, r5, x5, _X);
              }
              i1 += steps;
              currentOp += steps;
              if (callback) {
                const percent10 = parseInt(1e3 * currentOp / totalOps);
                if (percent10 !== lastPercent10) {
                  stop = callback(null, currentOp / totalOps);
                  if (stop) {
                    break;
                  }
                  lastPercent10 = percent10;
                }
              }
              if (i1 < N15) {
                break;
              }
              arraycopy(XY, 0, B5, Bi2, Yi2);
              i0++;
              if (i0 < p6) {
                state3 = 0;
                break;
              }
              b6 = [];
              for (let i4 = 0; i4 < B5.length; i4++) {
                b6.push(B5[i4] >> 0 & 255);
                b6.push(B5[i4] >> 8 & 255);
                b6.push(B5[i4] >> 16 & 255);
                b6.push(B5[i4] >> 24 & 255);
              }
              const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b6, dkLen);
              if (callback) {
                callback(null, 1, derivedKey);
              }
              return derivedKey;
          }
          if (callback) {
            nextTick(incrementalSMix);
          }
        };
        if (!callback) {
          while (true) {
            const derivedKey = incrementalSMix();
            if (derivedKey != void 0) {
              return derivedKey;
            }
          }
        }
        incrementalSMix();
      }
      const lib = {
        scrypt: function(password, salt, N15, r5, p6, dkLen, progressCallback) {
          return new Promise(function(resolve, reject) {
            let lastProgress = 0;
            if (progressCallback) {
              progressCallback(0);
            }
            _scrypt(password, salt, N15, r5, p6, dkLen, function(error, progress, key2) {
              if (error) {
                reject(error);
              } else if (key2) {
                if (progressCallback && lastProgress !== 1) {
                  progressCallback(1);
                }
                resolve(new Uint8Array(key2));
              } else if (progressCallback && progress !== lastProgress) {
                lastProgress = progress;
                return progressCallback(progress);
              }
            });
          });
        },
        syncScrypt: function(password, salt, N15, r5, p6, dkLen) {
          return new Uint8Array(_scrypt(password, salt, N15, r5, p6, dkLen));
        }
      };
      if (typeof exports !== "undefined") {
        module.exports = lib;
      } else if (typeof define === "function" && define.amd) {
        define(lib);
      } else if (root) {
        if (root.scrypt) {
          root._scrypt = root.scrypt;
        }
        root.scrypt = lib;
      }
    })(exports);
  }
});

// node_modules/bech32/index.js
var require_bech32 = __commonJS({
  "node_modules/bech32/index.js"(exports, module) {
    "use strict";
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (z5 = 0; z5 < ALPHABET.length; z5++) {
      x5 = ALPHABET.charAt(z5);
      if (ALPHABET_MAP[x5] !== void 0)
        throw new TypeError(x5 + " is ambiguous");
      ALPHABET_MAP[x5] = z5;
    }
    var x5;
    var z5;
    function polymodStep(pre) {
      var b6 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b6 >> 0 & 1) & 996825010 ^ -(b6 >> 1 & 1) & 642813549 ^ -(b6 >> 2 & 1) & 513874426 ^ -(b6 >> 3 & 1) & 1027748829 ^ -(b6 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      var chk = 1;
      for (var i4 = 0; i4 < prefix.length; ++i4) {
        var c5 = prefix.charCodeAt(i4);
        if (c5 < 33 || c5 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c5 >> 5;
      }
      chk = polymodStep(chk);
      for (i4 = 0; i4 < prefix.length; ++i4) {
        var v5 = prefix.charCodeAt(i4);
        chk = polymodStep(chk) ^ v5 & 31;
      }
      return chk;
    }
    function encode8(prefix, words2, LIMIT) {
      LIMIT = LIMIT || 90;
      if (prefix.length + 7 + words2.length > LIMIT)
        throw new TypeError("Exceeds length limit");
      prefix = prefix.toLowerCase();
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        throw new Error(chk);
      var result = prefix + "1";
      for (var i4 = 0; i4 < words2.length; ++i4) {
        var x6 = words2[i4];
        if (x6 >> 5 !== 0)
          throw new Error("Non 5-bit word");
        chk = polymodStep(chk) ^ x6;
        result += ALPHABET.charAt(x6);
      }
      for (i4 = 0; i4 < 6; ++i4) {
        chk = polymodStep(chk);
      }
      chk ^= 1;
      for (i4 = 0; i4 < 6; ++i4) {
        var v5 = chk >> (5 - i4) * 5 & 31;
        result += ALPHABET.charAt(v5);
      }
      return result;
    }
    function __decode(str, LIMIT) {
      LIMIT = LIMIT || 90;
      if (str.length < 8)
        return str + " too short";
      if (str.length > LIMIT)
        return "Exceeds length limit";
      var lowered = str.toLowerCase();
      var uppered = str.toUpperCase();
      if (str !== lowered && str !== uppered)
        return "Mixed-case string " + str;
      str = lowered;
      var split = str.lastIndexOf("1");
      if (split === -1)
        return "No separator character for " + str;
      if (split === 0)
        return "Missing prefix for " + str;
      var prefix = str.slice(0, split);
      var wordChars = str.slice(split + 1);
      if (wordChars.length < 6)
        return "Data too short";
      var chk = prefixChk(prefix);
      if (typeof chk === "string")
        return chk;
      var words2 = [];
      for (var i4 = 0; i4 < wordChars.length; ++i4) {
        var c5 = wordChars.charAt(i4);
        var v5 = ALPHABET_MAP[c5];
        if (v5 === void 0)
          return "Unknown character " + c5;
        chk = polymodStep(chk) ^ v5;
        if (i4 + 6 >= wordChars.length)
          continue;
        words2.push(v5);
      }
      if (chk !== 1)
        return "Invalid checksum for " + str;
      return { prefix, words: words2 };
    }
    function decodeUnsafe() {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
    }
    function decode8(str) {
      var res = __decode.apply(null, arguments);
      if (typeof res === "object")
        return res;
      throw new Error(res);
    }
    function convert(data3, inBits, outBits, pad) {
      var value = 0;
      var bits = 0;
      var maxV = (1 << outBits) - 1;
      var result = [];
      for (var i4 = 0; i4 < data3.length; ++i4) {
        value = value << inBits | data3[i4];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWordsUnsafe(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
    }
    function toWords(bytes) {
      var res = convert(bytes, 8, 5, true);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function fromWordsUnsafe(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words2) {
      var res = convert(words2, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    module.exports = {
      decodeUnsafe,
      decode: decode8,
      encode: encode8,
      toWordsUnsafe,
      toWords,
      fromWordsUnsafe,
      fromWords
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i4 = 0, len = code2.length; i4 < len; ++i4) {
      lookup[i4] = code2[i4];
      revLookup[code2.charCodeAt(i4)] = i4;
    }
    var i4;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i5;
      for (i5 = 0; i5 < len2; i5 += 4) {
        tmp = revLookup[b64.charCodeAt(i5)] << 18 | revLookup[b64.charCodeAt(i5 + 1)] << 12 | revLookup[b64.charCodeAt(i5 + 2)] << 6 | revLookup[b64.charCodeAt(i5 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i5)] << 2 | revLookup[b64.charCodeAt(i5 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i5)] << 10 | revLookup[b64.charCodeAt(i5 + 1)] << 4 | revLookup[b64.charCodeAt(i5 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i5 = start; i5 < end; i5 += 3) {
        tmp = (uint8[i5] << 16 & 16711680) + (uint8[i5 + 1] << 8 & 65280) + (uint8[i5 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i5 = 0, len22 = len2 - extraBytes; i5 < len22; i5 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i5, i5 + maxChunkLength > len22 ? len22 : i5 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e3, m5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i4 = isLE ? nBytes - 1 : 0;
      var d4 = isLE ? -1 : 1;
      var s3 = buffer2[offset + i4];
      i4 += d4;
      e3 = s3 & (1 << -nBits) - 1;
      s3 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i4], i4 += d4, nBits -= 8) {
      }
      m5 = e3 & (1 << -nBits) - 1;
      e3 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m5 = m5 * 256 + buffer2[offset + i4], i4 += d4, nBits -= 8) {
      }
      if (e3 === 0) {
        e3 = 1 - eBias;
      } else if (e3 === eMax) {
        return m5 ? NaN : (s3 ? -1 : 1) * Infinity;
      } else {
        m5 = m5 + Math.pow(2, mLen);
        e3 = e3 - eBias;
      }
      return (s3 ? -1 : 1) * m5 * Math.pow(2, e3 - mLen);
    };
    exports.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e3, m5, c5;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i4 = isLE ? 0 : nBytes - 1;
      var d4 = isLE ? 1 : -1;
      var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m5 = isNaN(value) ? 1 : 0;
        e3 = eMax;
      } else {
        e3 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c5 = Math.pow(2, -e3)) < 1) {
          e3--;
          c5 *= 2;
        }
        if (e3 + eBias >= 1) {
          value += rt2 / c5;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c5 >= 2) {
          e3++;
          c5 /= 2;
        }
        if (e3 + eBias >= eMax) {
          m5 = 0;
          e3 = eMax;
        } else if (e3 + eBias >= 1) {
          m5 = (value * c5 - 1) * Math.pow(2, mLen);
          e3 = e3 + eBias;
        } else {
          m5 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e3 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i4] = m5 & 255, i4 += d4, m5 /= 256, mLen -= 8) {
      }
      e3 = e3 << mLen | m5;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i4] = e3 & 255, i4 += d4, e3 /= 256, eLen -= 8) {
      }
      buffer2[offset + i4 - d4] |= s3 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length2) {
      if (length2 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length2);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe2(arg);
      }
      return from4(arg, encodingOrOffset, length2);
    }
    Buffer3.poolSize = 8192;
    function from4(value, encodingOrOffset, length2) {
      if (typeof value === "string") {
        return fromString3(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length2);
      }
      const b6 = fromObject(value);
      if (b6)
        return b6;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length2) {
      return from4(value, encodingOrOffset, length2);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size2 < 0) {
        throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
      }
    }
    function alloc(size2, fill, encoding) {
      assertSize(size2);
      if (size2 <= 0) {
        return createBuffer(size2);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
      }
      return createBuffer(size2);
    }
    Buffer3.alloc = function(size2, fill, encoding) {
      return alloc(size2, fill, encoding);
    };
    function allocUnsafe2(size2) {
      assertSize(size2);
      return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
    }
    Buffer3.allocUnsafe = function(size2) {
      return allocUnsafe2(size2);
    };
    Buffer3.allocUnsafeSlow = function(size2) {
      return allocUnsafe2(size2);
    };
    function fromString3(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length2 = byteLength(string3, encoding) | 0;
      let buf = createBuffer(length2);
      const actual = buf.write(string3, encoding);
      if (actual !== length2) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length2 = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length2);
      for (let i4 = 0; i4 < length2; i4 += 1) {
        buf[i4] = array2[i4] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length2) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length2 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length2 === void 0) {
        buf = new Uint8Array(array2);
      } else if (length2 === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length2);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length2) {
      if (length2 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length2 | 0;
    }
    function SlowBuffer(length2) {
      if (+length2 != length2) {
        length2 = 0;
      }
      return Buffer3.alloc(+length2);
    }
    Buffer3.isBuffer = function isBuffer(b6) {
      return b6 != null && b6._isBuffer === true && b6 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare2(a4, b6) {
      if (isInstance(a4, Uint8Array))
        a4 = Buffer3.from(a4, a4.offset, a4.byteLength);
      if (isInstance(b6, Uint8Array))
        b6 = Buffer3.from(b6, b6.offset, b6.byteLength);
      if (!Buffer3.isBuffer(a4) || !Buffer3.isBuffer(b6)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a4 === b6)
        return 0;
      let x5 = a4.length;
      let y7 = b6.length;
      for (let i4 = 0, len = Math.min(x5, y7); i4 < len; ++i4) {
        if (a4[i4] !== b6[i4]) {
          x5 = a4[i4];
          y7 = b6[i4];
          break;
        }
      }
      if (x5 < y7)
        return -1;
      if (y7 < x5)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat5(list, length2) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i4;
      if (length2 === void 0) {
        length2 = 0;
        for (i4 = 0; i4 < list.length; ++i4) {
          length2 += list[i4].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length2);
      let pos = 0;
      for (i4 = 0; i4 < list.length; ++i4) {
        let buf = list[i4];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer2,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string3, encoding) {
      if (Buffer3.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3
        );
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b6, n3, m5) {
      const i4 = b6[n3];
      b6[n3] = b6[m5];
      b6[m5] = i4;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 2) {
        swap(this, i4, i4 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 4) {
        swap(this, i4, i4 + 3);
        swap(this, i4 + 1, i4 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i4 = 0; i4 < len; i4 += 8) {
        swap(this, i4, i4 + 7);
        swap(this, i4 + 1, i4 + 6);
        swap(this, i4 + 2, i4 + 5);
        swap(this, i4 + 3, i4 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString4() {
      const length2 = this.length;
      if (length2 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length2);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals4(b6) {
      if (!Buffer3.isBuffer(b6))
        throw new TypeError("Argument must be a Buffer");
      if (this === b6)
        return true;
      return Buffer3.compare(this, b6) === 0;
    };
    Buffer3.prototype.inspect = function inspect4() {
      let str = "";
      const max3 = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max3).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max3)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x5 = thisEnd - thisStart;
      let y7 = end - start;
      const len = Math.min(x5, y7);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i4 = 0; i4 < len; ++i4) {
        if (thisCopy[i4] !== targetCopy[i4]) {
          x5 = thisCopy[i4];
          y7 = targetCopy[i4];
          break;
        }
      }
      if (x5 < y7)
        return -1;
      if (y7 < x5)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i5) {
        if (indexSize === 1) {
          return buf[i5];
        } else {
          return buf.readUInt16BE(i5 * indexSize);
        }
      }
      let i4;
      if (dir) {
        let foundIndex = -1;
        for (i4 = byteOffset; i4 < arrLength; i4++) {
          if (read2(arr, i4) === read2(val, foundIndex === -1 ? 0 : i4 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i4;
            if (i4 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i4 -= i4 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i4 = byteOffset; i4 >= 0; i4--) {
          let found = true;
          for (let j7 = 0; j7 < valLength; j7++) {
            if (read2(arr, i4 + j7) !== read2(val, j7)) {
              found = false;
              break;
            }
          }
          if (found)
            return i4;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string3, offset, length2) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length2) {
        length2 = remaining;
      } else {
        length2 = Number(length2);
        if (length2 > remaining) {
          length2 = remaining;
        }
      }
      const strLen = string3.length;
      if (length2 > strLen / 2) {
        length2 = strLen / 2;
      }
      let i4;
      for (i4 = 0; i4 < length2; ++i4) {
        const parsed = parseInt(string3.substr(i4 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i4;
        buf[offset + i4] = parsed;
      }
      return i4;
    }
    function utf8Write(buf, string3, offset, length2) {
      return blitBuffer(utf8ToBytes(string3, buf.length - offset), buf, offset, length2);
    }
    function asciiWrite(buf, string3, offset, length2) {
      return blitBuffer(asciiToBytes(string3), buf, offset, length2);
    }
    function base64Write(buf, string3, offset, length2) {
      return blitBuffer(base64ToBytes(string3), buf, offset, length2);
    }
    function ucs2Write(buf, string3, offset, length2) {
      return blitBuffer(utf16leToBytes(string3, buf.length - offset), buf, offset, length2);
    }
    Buffer3.prototype.write = function write(string3, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length2 = this.length;
        offset = 0;
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        length2 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length2)) {
          length2 = length2 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length2;
          length2 = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length2 === void 0 || length2 > remaining)
        length2 = remaining;
      if (string3.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length2);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length2);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length2);
          case "base64":
            return base64Write(this, string3, offset, length2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length2);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON2() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base642.fromByteArray(buf);
      } else {
        return base642.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i4 = start;
      while (i4 < end) {
        const firstByte = buf[i4];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i4 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i4 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i4 + 1];
              thirdByte = buf[i4 + 2];
              fourthByte = buf[i4 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i4 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i4 = 0;
      while (i4 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i4, i4 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i4 = start; i4 < end; ++i4) {
        ret += String.fromCharCode(buf[i4] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i4 = start; i4 < end; ++i4) {
        ret += String.fromCharCode(buf[i4]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i4 = start; i4 < end; ++i4) {
        out += hexSliceLookupTable[buf[i4]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i4 = 0; i4 < bytes.length - 1; i4 += 2) {
        res += String.fromCharCode(bytes[i4] + bytes[i4 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length2) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length2)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i4 = 0;
      while (++i4 < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i4] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul3 = 1;
      while (byteLength2 > 0 && (mul3 *= 256)) {
        val += this[offset + --byteLength2] * mul3;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul3 = 1;
      let i4 = 0;
      while (++i4 < byteLength2 && (mul3 *= 256)) {
        val += this[offset + i4] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i4 = byteLength2;
      let mul3 = 1;
      let val = this[offset + --i4];
      while (i4 > 0 && (mul3 *= 256)) {
        val += this[offset + --i4] * mul3;
      }
      mul3 *= 128;
      if (val >= mul3)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first2 = this[offset];
      const last2 = this[offset + 7];
      if (first2 === void 0 || last2 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max3, min3) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max3 || value < min3)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul3 = 1;
      let i4 = 0;
      this[offset] = value & 255;
      while (++i4 < byteLength2 && (mul3 *= 256)) {
        this[offset + i4] = value / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i4 = byteLength2 - 1;
      let mul3 = 1;
      this[offset + i4] = value & 255;
      while (--i4 >= 0 && (mul3 *= 256)) {
        this[offset + i4] = value / mul3 & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min3, max3) {
      checkIntBI(value, min3, max3, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min3, max3) {
      checkIntBI(value, min3, max3, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i4 = 0;
      let mul3 = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i4 < byteLength2 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i4 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i4] = (value / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i4 = byteLength2 - 1;
      let mul3 = 1;
      let sub = 0;
      this[offset + i4] = value & 255;
      while (--i4 >= 0 && (mul3 *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i4 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i4] = (value / mul3 >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max3, min3) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
            val = code2;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i4;
      if (typeof val === "number") {
        for (i4 = start; i4 < end; ++i4) {
          this[i4] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i4 = 0; i4 < end - start; ++i4) {
          this[i4 + start] = bytes[i4 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E6(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E6(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E6(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E6(
      "ERR_OUT_OF_RANGE",
      function(str, range2, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i4 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i4 >= start + 4; i4 -= 3) {
        res = `_${val.slice(i4 - 3, i4)}${res}`;
      }
      return `${val.slice(0, i4)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min3, max3, buf, offset, byteLength2) {
      if (value > max3 || value < min3) {
        const n3 = typeof min3 === "bigint" ? "n" : "";
        let range2;
        if (byteLength2 > 3) {
          if (min3 === 0 || min3 === BigInt(0)) {
            range2 = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`;
          } else {
            range2 = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n3}`;
          }
        } else {
          range2 = `>= ${min3}${n3} and <= ${max3}${n3}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length2, type2) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type2);
        throw new errors.ERR_OUT_OF_RANGE(type2 || "offset", "an integer", value);
      }
      if (length2 < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type2 || "offset",
        `>= ${type2 ? 1 : 0} and <= ${length2}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length2 = string3.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i4 = 0; i4 < length2; ++i4) {
        codePoint = string3.charCodeAt(i4);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i4 + 1 === length2) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i4 = 0; i4 < str.length; ++i4) {
        byteArray.push(str.charCodeAt(i4) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c5, hi, lo;
      const byteArray = [];
      for (let i4 = 0; i4 < str.length; ++i4) {
        if ((units -= 2) < 0)
          break;
        c5 = str.charCodeAt(i4);
        hi = c5 >> 8;
        lo = c5 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length2) {
      let i4;
      for (i4 = 0; i4 < length2; ++i4) {
        if (i4 + offset >= dst.length || i4 >= src2.length)
          break;
        dst[i4 + offset] = src2[i4];
      }
      return i4;
    }
    function isInstance(obj, type2) {
      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet2 = "0123456789abcdef";
      const table = new Array(256);
      for (let i4 = 0; i4 < 16; ++i4) {
        const i16 = i4 * 16;
        for (let j7 = 0; j7 < 16; ++j7) {
          table[i16 + j7] = alphabet2[i4] + alphabet2[j7];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn2) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js
var require_wallet_logo = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/assets/wallet-logo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.walletLogo = void 0;
    var walletLogo = (type2, width) => {
      let height;
      switch (type2) {
        case "standard":
          height = width;
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
        case "circle":
          height = width;
          return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
        case "text":
          height = (0.1 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogo":
          height = (0.25 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        case "textLight":
          height = (0.1 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
        case "textWithLogoLight":
          height = (0.25 * width).toFixed(2);
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
        default:
          height = width;
          return `data:image/svg+xml,%3Csvg width='${width}' height='${height}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
      }
    };
    exports.walletLogo = walletLogo;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/constants.js
var require_constants4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LINK_API_URL = void 0;
    exports.LINK_API_URL = "https://www.walletlink.org";
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js
var require_ScopedLocalStorage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/ScopedLocalStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ScopedLocalStorage = void 0;
    var ScopedLocalStorage = class {
      constructor(scope) {
        this.scope = scope;
      }
      setItem(key2, value) {
        localStorage.setItem(this.scopedKey(key2), value);
      }
      getItem(key2) {
        return localStorage.getItem(this.scopedKey(key2));
      }
      removeItem(key2) {
        localStorage.removeItem(this.scopedKey(key2));
      }
      clear() {
        const prefix = this.scopedKey("");
        const keysToRemove = [];
        for (let i4 = 0; i4 < localStorage.length; i4++) {
          const key2 = localStorage.key(i4);
          if (typeof key2 === "string" && key2.startsWith(prefix)) {
            keysToRemove.push(key2);
          }
        }
        keysToRemove.forEach((key2) => localStorage.removeItem(key2));
      }
      scopedKey(key2) {
        return `${this.scope}:${key2}`;
      }
    };
    exports.ScopedLocalStorage = ScopedLocalStorage;
  }
});

// node_modules/@metamask/safe-event-emitter/index.js
var require_safe_event_emitter = __commonJS({
  "node_modules/@metamask/safe-event-emitter/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    function safeApply(handler, context, args) {
      try {
        Reflect.apply(handler, context, args);
      } catch (err) {
        setTimeout(() => {
          throw err;
        });
      }
    }
    function arrayClone(arr) {
      const n3 = arr.length;
      const copy = new Array(n3);
      for (let i4 = 0; i4 < n3; i4 += 1) {
        copy[i4] = arr[i4];
      }
      return copy;
    }
    var SafeEventEmitter = class extends events_1.EventEmitter {
      emit(type2, ...args) {
        let doError = type2 === "error";
        const events = this._events;
        if (events !== void 0) {
          doError = doError && events.error === void 0;
        } else if (!doError) {
          return false;
        }
        if (doError) {
          let er3;
          if (args.length > 0) {
            [er3] = args;
          }
          if (er3 instanceof Error) {
            throw er3;
          }
          const err = new Error(`Unhandled error.${er3 ? ` (${er3.message})` : ""}`);
          err.context = er3;
          throw err;
        }
        const handler = events[type2];
        if (handler === void 0) {
          return false;
        }
        if (typeof handler === "function") {
          safeApply(handler, this, args);
        } else {
          const len = handler.length;
          const listeners = arrayClone(handler);
          for (let i4 = 0; i4 < len; i4 += 1) {
            safeApply(listeners[i4], this, args);
          }
        }
        return true;
      }
    };
    exports.default = SafeEventEmitter;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/DiagnosticLogger.js
var require_DiagnosticLogger = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/DiagnosticLogger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENTS = void 0;
    exports.EVENTS = {
      STARTED_CONNECTING: "walletlink_sdk.started.connecting",
      CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
      DISCONNECTED: "walletlink_sdk.disconnected",
      METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
      LINKED: "walletlink_sdk.linked",
      FAILURE: "walletlink_sdk.generic_failure",
      SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
      ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
      SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
      UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
      SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
      GENERAL_ERROR: "walletlink_sdk.general_error",
      WEB3_REQUEST: "walletlink_sdk.web3.request",
      WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
      WEB3_RESPONSE: "walletlink_sdk.web3.response",
      UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
    };
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify3;
    stringify3.default = stringify3;
    stringify3.stable = deterministicStringify;
    stringify3.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify3(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_6) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k5, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k5);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k5, { value: replace });
          arr.push([parent, k5, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k5, replace]);
        }
      } else {
        parent[k5] = replace;
        arr.push([parent, k5, val]);
      }
    }
    function decirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i4;
      if (typeof val === "object" && val !== null) {
        for (i4 = 0; i4 < stack.length; i4++) {
          if (stack[i4] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i4 = 0; i4 < val.length; i4++) {
            decirc(val[i4], i4, i4, stack, val, depth, options);
          }
        } else {
          var keys2 = Object.keys(val);
          for (i4 = 0; i4 < keys2.length; i4++) {
            var key2 = keys2[i4];
            decirc(val[key2], key2, i4, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a4, b6) {
      if (a4 < b6) {
        return -1;
      }
      if (a4 > b6) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_6) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k5, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i4;
      if (typeof val === "object" && val !== null) {
        for (i4 = 0; i4 < stack.length; i4++) {
          if (stack[i4] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k5, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_6) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k5, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i4 = 0; i4 < val.length; i4++) {
            deterministicDecirc(val[i4], i4, i4, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys2 = Object.keys(val).sort(compareFunction);
          for (i4 = 0; i4 < keys2.length; i4++) {
            var key2 = keys2[i4];
            deterministicDecirc(val[key2], key2, i4, stack, val, depth, options);
            tmp[key2] = val[key2];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k5, val]);
            parent[k5] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k5, v5) {
        return v5;
      };
      return function(key2, val) {
        if (replacerStack.length > 0) {
          for (var i4 = 0; i4 < replacerStack.length; i4++) {
            var part = replacerStack[i4];
            if (part[1] === key2 && part[0] === val) {
              val = part[2];
              replacerStack.splice(i4, 1);
              break;
            }
          }
        }
        return replacer.call(this, key2, val);
      };
    }
  }
});

// node_modules/eth-rpc-errors/dist/classes.js
var require_classes = __commonJS({
  "node_modules/eth-rpc-errors/dist/classes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumProviderError = exports.EthereumRpcError = void 0;
    var fast_safe_stringify_1 = require_fast_safe_stringify();
    var EthereumRpcError = class extends Error {
      constructor(code2, message, data3) {
        if (!Number.isInteger(code2)) {
          throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
          throw new Error('"message" must be a nonempty string.');
        }
        super(message);
        this.code = code2;
        if (data3 !== void 0) {
          this.data = data3;
        }
      }
      /**
       * Returns a plain object with all public class properties.
       */
      serialize() {
        const serialized = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          serialized.data = this.data;
        }
        if (this.stack) {
          serialized.stack = this.stack;
        }
        return serialized;
      }
      /**
       * Return a string representation of the serialized error, omitting
       * any circular references.
       */
      toString() {
        return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
      }
    };
    exports.EthereumRpcError = EthereumRpcError;
    var EthereumProviderError = class extends EthereumRpcError {
      /**
       * Create an Ethereum Provider JSON-RPC error.
       * `code` must be an integer in the 1000 <= 4999 range.
       */
      constructor(code2, message, data3) {
        if (!isValidEthProviderCode(code2)) {
          throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(code2, message, data3);
      }
    };
    exports.EthereumProviderError = EthereumProviderError;
    function isValidEthProviderCode(code2) {
      return Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999;
    }
    function stringifyReplacer(_6, value) {
      if (value === "[Circular]") {
        return void 0;
      }
      return value;
    }
  }
});

// node_modules/eth-rpc-errors/dist/error-constants.js
var require_error_constants = __commonJS({
  "node_modules/eth-rpc-errors/dist/error-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errorValues = exports.errorCodes = void 0;
    exports.errorCodes = {
      rpc: {
        invalidInput: -32e3,
        resourceNotFound: -32001,
        resourceUnavailable: -32002,
        transactionRejected: -32003,
        methodNotSupported: -32004,
        limitExceeded: -32005,
        parse: -32700,
        invalidRequest: -32600,
        methodNotFound: -32601,
        invalidParams: -32602,
        internal: -32603
      },
      provider: {
        userRejectedRequest: 4001,
        unauthorized: 4100,
        unsupportedMethod: 4200,
        disconnected: 4900,
        chainDisconnected: 4901
      }
    };
    exports.errorValues = {
      "-32700": {
        standard: "JSON RPC 2.0",
        message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
      },
      "-32600": {
        standard: "JSON RPC 2.0",
        message: "The JSON sent is not a valid Request object."
      },
      "-32601": {
        standard: "JSON RPC 2.0",
        message: "The method does not exist / is not available."
      },
      "-32602": {
        standard: "JSON RPC 2.0",
        message: "Invalid method parameter(s)."
      },
      "-32603": {
        standard: "JSON RPC 2.0",
        message: "Internal JSON-RPC error."
      },
      "-32000": {
        standard: "EIP-1474",
        message: "Invalid input."
      },
      "-32001": {
        standard: "EIP-1474",
        message: "Resource not found."
      },
      "-32002": {
        standard: "EIP-1474",
        message: "Resource unavailable."
      },
      "-32003": {
        standard: "EIP-1474",
        message: "Transaction rejected."
      },
      "-32004": {
        standard: "EIP-1474",
        message: "Method not supported."
      },
      "-32005": {
        standard: "EIP-1474",
        message: "Request limit exceeded."
      },
      "4001": {
        standard: "EIP-1193",
        message: "User rejected the request."
      },
      "4100": {
        standard: "EIP-1193",
        message: "The requested account and/or method has not been authorized by the user."
      },
      "4200": {
        standard: "EIP-1193",
        message: "The requested method is not supported by this Ethereum provider."
      },
      "4900": {
        standard: "EIP-1193",
        message: "The provider is disconnected from all chains."
      },
      "4901": {
        standard: "EIP-1193",
        message: "The provider is disconnected from the specified chain."
      }
    };
  }
});

// node_modules/eth-rpc-errors/dist/utils.js
var require_utils4 = __commonJS({
  "node_modules/eth-rpc-errors/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    var error_constants_1 = require_error_constants();
    var classes_1 = require_classes();
    var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
    var FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
    var FALLBACK_ERROR = {
      code: FALLBACK_ERROR_CODE,
      message: getMessageFromCode(FALLBACK_ERROR_CODE)
    };
    exports.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function getMessageFromCode(code2, fallbackMessage = FALLBACK_MESSAGE) {
      if (Number.isInteger(code2)) {
        const codeString = code2.toString();
        if (hasKey(error_constants_1.errorValues, codeString)) {
          return error_constants_1.errorValues[codeString].message;
        }
        if (isJsonRpcServerError(code2)) {
          return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
      }
      return fallbackMessage;
    }
    exports.getMessageFromCode = getMessageFromCode;
    function isValidCode(code2) {
      if (!Number.isInteger(code2)) {
        return false;
      }
      const codeString = code2.toString();
      if (error_constants_1.errorValues[codeString]) {
        return true;
      }
      if (isJsonRpcServerError(code2)) {
        return true;
      }
      return false;
    }
    exports.isValidCode = isValidCode;
    function serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
      var _a2, _b;
      if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
        throw new Error("Must provide fallback error with integer number code and string message.");
      }
      if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
      }
      const serialized = {};
      if (error && typeof error === "object" && !Array.isArray(error) && hasKey(error, "code") && isValidCode(error.code)) {
        const _error = error;
        serialized.code = _error.code;
        if (_error.message && typeof _error.message === "string") {
          serialized.message = _error.message;
          if (hasKey(_error, "data")) {
            serialized.data = _error.data;
          }
        } else {
          serialized.message = getMessageFromCode(serialized.code);
          serialized.data = { originalError: assignOriginalError(error) };
        }
      } else {
        serialized.code = fallbackError.code;
        const message = (_a2 = error) === null || _a2 === void 0 ? void 0 : _a2.message;
        serialized.message = message && typeof message === "string" ? message : fallbackError.message;
        serialized.data = { originalError: assignOriginalError(error) };
      }
      const stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;
      if (shouldIncludeStack && error && stack && typeof stack === "string") {
        serialized.stack = stack;
      }
      return serialized;
    }
    exports.serializeError = serializeError;
    function isJsonRpcServerError(code2) {
      return code2 >= -32099 && code2 <= -32e3;
    }
    function assignOriginalError(error) {
      if (error && typeof error === "object" && !Array.isArray(error)) {
        return Object.assign({}, error);
      }
      return error;
    }
    function hasKey(obj, key2) {
      return Object.prototype.hasOwnProperty.call(obj, key2);
    }
  }
});

// node_modules/eth-rpc-errors/dist/errors.js
var require_errors = __commonJS({
  "node_modules/eth-rpc-errors/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethErrors = void 0;
    var classes_1 = require_classes();
    var utils_12 = require_utils4();
    var error_constants_1 = require_error_constants();
    exports.ethErrors = {
      rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum RPC Server errors must provide single object argument.");
          }
          const { code: code2 } = opts;
          if (!Number.isInteger(code2) || code2 > -32005 || code2 < -32099) {
            throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
          }
          return getEthJsonRpcError(code2, opts);
        },
        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
      },
      provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },
        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },
        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },
        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },
        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: (arg) => {
          return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },
        /**
         * Get a custom Ethereum Provider error.
         */
        custom: (opts) => {
          if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
            throw new Error("Ethereum Provider custom errors must provide single object argument.");
          }
          const { code: code2, message, data: data3 } = opts;
          if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string');
          }
          return new classes_1.EthereumProviderError(code2, message, data3);
        }
      }
    };
    function getEthJsonRpcError(code2, arg) {
      const [message, data3] = parseOpts(arg);
      return new classes_1.EthereumRpcError(code2, message || utils_12.getMessageFromCode(code2), data3);
    }
    function getEthProviderError(code2, arg) {
      const [message, data3] = parseOpts(arg);
      return new classes_1.EthereumProviderError(code2, message || utils_12.getMessageFromCode(code2), data3);
    }
    function parseOpts(arg) {
      if (arg) {
        if (typeof arg === "string") {
          return [arg];
        } else if (typeof arg === "object" && !Array.isArray(arg)) {
          const { message, data: data3 } = arg;
          if (message && typeof message !== "string") {
            throw new Error("Must specify string message.");
          }
          return [message || void 0, data3];
        }
      }
      return [];
    }
  }
});

// node_modules/eth-rpc-errors/dist/index.js
var require_dist = __commonJS({
  "node_modules/eth-rpc-errors/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageFromCode = exports.serializeError = exports.EthereumProviderError = exports.EthereumRpcError = exports.ethErrors = exports.errorCodes = void 0;
    var classes_1 = require_classes();
    Object.defineProperty(exports, "EthereumRpcError", { enumerable: true, get: function() {
      return classes_1.EthereumRpcError;
    } });
    Object.defineProperty(exports, "EthereumProviderError", { enumerable: true, get: function() {
      return classes_1.EthereumProviderError;
    } });
    var utils_12 = require_utils4();
    Object.defineProperty(exports, "serializeError", { enumerable: true, get: function() {
      return utils_12.serializeError;
    } });
    Object.defineProperty(exports, "getMessageFromCode", { enumerable: true, get: function() {
      return utils_12.getMessageFromCode;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "ethErrors", { enumerable: true, get: function() {
      return errors_1.ethErrors;
    } });
    var error_constants_1 = require_error_constants();
    Object.defineProperty(exports, "errorCodes", { enumerable: true, get: function() {
      return error_constants_1.errorCodes;
    } });
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js
var require_Web3Method = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Method.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3Method = void 0;
    var Web3Method;
    (function(Web3Method2) {
      Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
      Web3Method2["signEthereumMessage"] = "signEthereumMessage";
      Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
      Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
      Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
      Web3Method2["scanQRCode"] = "scanQRCode";
      Web3Method2["generic"] = "generic";
      Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
      Web3Method2["addEthereumChain"] = "addEthereumChain";
      Web3Method2["switchEthereumChain"] = "switchEthereumChain";
      Web3Method2["makeEthereumJSONRPCRequest"] = "makeEthereumJSONRPCRequest";
      Web3Method2["watchAsset"] = "watchAsset";
      Web3Method2["selectProvider"] = "selectProvider";
    })(Web3Method = exports.Web3Method || (exports.Web3Method = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js
var require_Web3Response = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3Response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EthereumAddressFromSignedMessageResponse = exports.SubmitEthereumTransactionResponse = exports.SignEthereumTransactionResponse = exports.SignEthereumMessageResponse = exports.isRequestEthereumAccountsResponse = exports.SelectProviderResponse = exports.WatchAssetReponse = exports.RequestEthereumAccountsResponse = exports.SwitchEthereumChainResponse = exports.AddEthereumChainResponse = exports.isErrorResponse = void 0;
    var Web3Method_1 = require_Web3Method();
    function isErrorResponse(response) {
      var _a2, _b;
      return ((_a2 = response) === null || _a2 === void 0 ? void 0 : _a2.method) !== void 0 && ((_b = response) === null || _b === void 0 ? void 0 : _b.errorMessage) !== void 0;
    }
    exports.isErrorResponse = isErrorResponse;
    function AddEthereumChainResponse(addResponse) {
      return {
        method: Web3Method_1.Web3Method.addEthereumChain,
        result: addResponse
      };
    }
    exports.AddEthereumChainResponse = AddEthereumChainResponse;
    function SwitchEthereumChainResponse(switchResponse) {
      return {
        method: Web3Method_1.Web3Method.switchEthereumChain,
        result: switchResponse
      };
    }
    exports.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
    function RequestEthereumAccountsResponse(addresses) {
      return { method: Web3Method_1.Web3Method.requestEthereumAccounts, result: addresses };
    }
    exports.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
    function WatchAssetReponse(success) {
      return { method: Web3Method_1.Web3Method.watchAsset, result: success };
    }
    exports.WatchAssetReponse = WatchAssetReponse;
    function SelectProviderResponse(selectedProviderKey) {
      return { method: Web3Method_1.Web3Method.selectProvider, result: selectedProviderKey };
    }
    exports.SelectProviderResponse = SelectProviderResponse;
    function isRequestEthereumAccountsResponse(res) {
      return res && res.method === Web3Method_1.Web3Method.requestEthereumAccounts;
    }
    exports.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
    function SignEthereumMessageResponse(signature2) {
      return { method: Web3Method_1.Web3Method.signEthereumMessage, result: signature2 };
    }
    exports.SignEthereumMessageResponse = SignEthereumMessageResponse;
    function SignEthereumTransactionResponse(signedData) {
      return { method: Web3Method_1.Web3Method.signEthereumTransaction, result: signedData };
    }
    exports.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
    function SubmitEthereumTransactionResponse(txHash) {
      return { method: Web3Method_1.Web3Method.submitEthereumTransaction, result: txHash };
    }
    exports.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
    function EthereumAddressFromSignedMessageResponse(address) {
      return {
        method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
        result: address
      };
    }
    exports.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/version.js
var require_version = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LIB_VERSION = void 0;
    exports.LIB_VERSION = "3.7.2";
  }
});

// node_modules/@coinbase/wallet-sdk/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getErrorCode = exports.serializeError = exports.standardErrors = exports.standardErrorMessage = exports.standardErrorCodes = void 0;
    var eth_rpc_errors_1 = require_dist();
    var Web3Response_1 = require_Web3Response();
    var version_1 = require_version();
    exports.standardErrorCodes = Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_1.errorCodes), { provider: Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_1.errorCodes.provider), { unsupportedChain: 4902 })) }));
    function standardErrorMessage(code2) {
      return code2 !== void 0 ? (0, eth_rpc_errors_1.getMessageFromCode)(code2) : "Unknown error";
    }
    exports.standardErrorMessage = standardErrorMessage;
    exports.standardErrors = Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_1.ethErrors), { provider: Object.freeze(Object.assign(Object.assign({}, eth_rpc_errors_1.ethErrors.provider), { unsupportedChain: (chainId = "") => eth_rpc_errors_1.ethErrors.provider.custom({
      code: exports.standardErrorCodes.provider.unsupportedChain,
      message: `Unrecognized chain ID ${chainId}. Try adding the chain using wallet_addEthereumChain first.`
    }) })) }));
    function serializeError(error, requestOrMethod) {
      const serialized = (0, eth_rpc_errors_1.serializeError)(getErrorObject(error), {
        shouldIncludeStack: true
      });
      const docUrl = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
      docUrl.searchParams.set("version", version_1.LIB_VERSION);
      docUrl.searchParams.set("code", serialized.code.toString());
      const method = getMethod(serialized.data, requestOrMethod);
      if (method) {
        docUrl.searchParams.set("method", method);
      }
      docUrl.searchParams.set("message", serialized.message);
      return Object.assign(Object.assign({}, serialized), { docUrl: docUrl.href });
    }
    exports.serializeError = serializeError;
    function getErrorObject(error) {
      if (typeof error === "string") {
        return {
          message: error,
          code: exports.standardErrorCodes.rpc.internal
        };
      } else if ((0, Web3Response_1.isErrorResponse)(error)) {
        return Object.assign(Object.assign({}, error), { message: error.errorMessage, code: error.errorCode, data: { method: error.method, result: error.result } });
      } else {
        return error;
      }
    }
    function getMethod(serializedData, request) {
      var _a2;
      const methodInData = (_a2 = serializedData) === null || _a2 === void 0 ? void 0 : _a2.method;
      if (methodInData) {
        return methodInData;
      }
      if (request === void 0) {
        return void 0;
      } else if (typeof request === "string") {
        return request;
      } else if (!Array.isArray(request)) {
        return request.method;
      } else if (request.length > 0) {
        return request[0].method;
      } else {
        return void 0;
      }
    }
    function getErrorCode(error) {
      var _a2;
      if (typeof error === "number") {
        return error;
      } else if (isErrorWithCode(error)) {
        return (_a2 = error.code) !== null && _a2 !== void 0 ? _a2 : error.errorCode;
      }
      return void 0;
    }
    exports.getErrorCode = getErrorCode;
    function isErrorWithCode(error) {
      return typeof error === "object" && error !== null && (typeof error.code === "number" || typeof error.errorCode === "number");
    }
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer2 = require_buffer2();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key2 in src2) {
        dst[key2] = src2[key2];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer3(arg, encodingOrOffset, length2);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size2);
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash3 = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    var Buffer3 = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer3.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data3, enc) {
      if (typeof data3 === "string") {
        enc = enc || "utf8";
        data3 = Buffer3.from(data3, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length2 = data3.length;
      var accum = this._len;
      for (var offset = 0; offset < length2; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length2 - offset, blockSize - assigned);
        for (var i4 = 0; i4 < remainder; i4++) {
          block[assigned + i4] = data3[offset + i4];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length2;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash3 = this._hash();
      return enc ? hash3.toString(enc) : hash3;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash3();
    var Buffer3 = require_safe_buffer().Buffer;
    var K4 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W4 = new Array(80);
    function Sha() {
      this.init();
      this._w = W4;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft4(s3, b6, c5, d4) {
      if (s3 === 0)
        return b6 & c5 | ~b6 & d4;
      if (s3 === 2)
        return b6 & c5 | b6 & d4 | c5 & d4;
      return b6 ^ c5 ^ d4;
    }
    Sha.prototype._update = function(M5) {
      var W5 = this._w;
      var a4 = this._a | 0;
      var b6 = this._b | 0;
      var c5 = this._c | 0;
      var d4 = this._d | 0;
      var e3 = this._e | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W5[i4] = M5.readInt32BE(i4 * 4);
      for (; i4 < 80; ++i4)
        W5[i4] = W5[i4 - 3] ^ W5[i4 - 8] ^ W5[i4 - 14] ^ W5[i4 - 16];
      for (var j7 = 0; j7 < 80; ++j7) {
        var s3 = ~~(j7 / 20);
        var t3 = rotl5(a4) + ft4(s3, b6, c5, d4) + e3 + W5[j7] + K4[s3] | 0;
        e3 = d4;
        d4 = c5;
        c5 = rotl30(b6);
        b6 = a4;
        a4 = t3;
      }
      this._a = a4 + this._a | 0;
      this._b = b6 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d4 + this._d | 0;
      this._e = e3 + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H3 = Buffer3.allocUnsafe(20);
      H3.writeInt32BE(this._a | 0, 0);
      H3.writeInt32BE(this._b | 0, 4);
      H3.writeInt32BE(this._c | 0, 8);
      H3.writeInt32BE(this._d | 0, 12);
      H3.writeInt32BE(this._e | 0, 16);
      return H3;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash3();
    var Buffer3 = require_safe_buffer().Buffer;
    var K4 = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W4 = new Array(80);
    function Sha1() {
      this.init();
      this._w = W4;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft4(s3, b6, c5, d4) {
      if (s3 === 0)
        return b6 & c5 | ~b6 & d4;
      if (s3 === 2)
        return b6 & c5 | b6 & d4 | c5 & d4;
      return b6 ^ c5 ^ d4;
    }
    Sha1.prototype._update = function(M5) {
      var W5 = this._w;
      var a4 = this._a | 0;
      var b6 = this._b | 0;
      var c5 = this._c | 0;
      var d4 = this._d | 0;
      var e3 = this._e | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W5[i4] = M5.readInt32BE(i4 * 4);
      for (; i4 < 80; ++i4)
        W5[i4] = rotl1(W5[i4 - 3] ^ W5[i4 - 8] ^ W5[i4 - 14] ^ W5[i4 - 16]);
      for (var j7 = 0; j7 < 80; ++j7) {
        var s3 = ~~(j7 / 20);
        var t3 = rotl5(a4) + ft4(s3, b6, c5, d4) + e3 + W5[j7] + K4[s3] | 0;
        e3 = d4;
        d4 = c5;
        c5 = rotl30(b6);
        b6 = a4;
        a4 = t3;
      }
      this._a = a4 + this._a | 0;
      this._b = b6 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d4 + this._d | 0;
      this._e = e3 + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H3 = Buffer3.allocUnsafe(20);
      H3.writeInt32BE(this._a | 0, 0);
      H3.writeInt32BE(this._b | 0, 4);
      H3.writeInt32BE(this._c | 0, 8);
      H3.writeInt32BE(this._d | 0, 12);
      H3.writeInt32BE(this._e | 0, 16);
      return H3;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash3();
    var Buffer3 = require_safe_buffer().Buffer;
    var K4 = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W4 = new Array(64);
    function Sha256() {
      this.init();
      this._w = W4;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x5, y7, z5) {
      return z5 ^ x5 & (y7 ^ z5);
    }
    function maj(x5, y7, z5) {
      return x5 & y7 | z5 & (x5 | y7);
    }
    function sigma0(x5) {
      return (x5 >>> 2 | x5 << 30) ^ (x5 >>> 13 | x5 << 19) ^ (x5 >>> 22 | x5 << 10);
    }
    function sigma1(x5) {
      return (x5 >>> 6 | x5 << 26) ^ (x5 >>> 11 | x5 << 21) ^ (x5 >>> 25 | x5 << 7);
    }
    function gamma0(x5) {
      return (x5 >>> 7 | x5 << 25) ^ (x5 >>> 18 | x5 << 14) ^ x5 >>> 3;
    }
    function gamma1(x5) {
      return (x5 >>> 17 | x5 << 15) ^ (x5 >>> 19 | x5 << 13) ^ x5 >>> 10;
    }
    Sha256.prototype._update = function(M5) {
      var W5 = this._w;
      var a4 = this._a | 0;
      var b6 = this._b | 0;
      var c5 = this._c | 0;
      var d4 = this._d | 0;
      var e3 = this._e | 0;
      var f5 = this._f | 0;
      var g7 = this._g | 0;
      var h6 = this._h | 0;
      for (var i4 = 0; i4 < 16; ++i4)
        W5[i4] = M5.readInt32BE(i4 * 4);
      for (; i4 < 64; ++i4)
        W5[i4] = gamma1(W5[i4 - 2]) + W5[i4 - 7] + gamma0(W5[i4 - 15]) + W5[i4 - 16] | 0;
      for (var j7 = 0; j7 < 64; ++j7) {
        var T1 = h6 + sigma1(e3) + ch(e3, f5, g7) + K4[j7] + W5[j7] | 0;
        var T22 = sigma0(a4) + maj(a4, b6, c5) | 0;
        h6 = g7;
        g7 = f5;
        f5 = e3;
        e3 = d4 + T1 | 0;
        d4 = c5;
        c5 = b6;
        b6 = a4;
        a4 = T1 + T22 | 0;
      }
      this._a = a4 + this._a | 0;
      this._b = b6 + this._b | 0;
      this._c = c5 + this._c | 0;
      this._d = d4 + this._d | 0;
      this._e = e3 + this._e | 0;
      this._f = f5 + this._f | 0;
      this._g = g7 + this._g | 0;
      this._h = h6 + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H3 = Buffer3.allocUnsafe(32);
      H3.writeInt32BE(this._a, 0);
      H3.writeInt32BE(this._b, 4);
      H3.writeInt32BE(this._c, 8);
      H3.writeInt32BE(this._d, 12);
      H3.writeInt32BE(this._e, 16);
      H3.writeInt32BE(this._f, 20);
      H3.writeInt32BE(this._g, 24);
      H3.writeInt32BE(this._h, 28);
      return H3;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Sha256 = require_sha2562();
    var Hash = require_hash3();
    var Buffer3 = require_safe_buffer().Buffer;
    var W4 = new Array(64);
    function Sha224() {
      this.init();
      this._w = W4;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H3 = Buffer3.allocUnsafe(28);
      H3.writeInt32BE(this._a, 0);
      H3.writeInt32BE(this._b, 4);
      H3.writeInt32BE(this._c, 8);
      H3.writeInt32BE(this._d, 12);
      H3.writeInt32BE(this._e, 16);
      H3.writeInt32BE(this._f, 20);
      H3.writeInt32BE(this._g, 24);
      return H3;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    var inherits = require_inherits_browser();
    var Hash = require_hash3();
    var Buffer3 = require_safe_buffer().Buffer;
    var K4 = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W4 = new Array(160);
    function Sha512() {
      this.init();
      this._w = W4;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x5, y7, z5) {
      return z5 ^ x5 & (y7 ^ z5);
    }
    function maj(x5, y7, z5) {
      return x5 & y7 | z5 & (x5 | y7);
    }
    function sigma0(x5, xl) {
      return (x5 >>> 28 | xl << 4) ^ (xl >>> 2 | x5 << 30) ^ (xl >>> 7 | x5 << 25);
    }
    function sigma1(x5, xl) {
      return (x5 >>> 14 | xl << 18) ^ (x5 >>> 18 | xl << 14) ^ (xl >>> 9 | x5 << 23);
    }
    function Gamma0(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ x5 >>> 7;
    }
    function Gamma0l(x5, xl) {
      return (x5 >>> 1 | xl << 31) ^ (x5 >>> 8 | xl << 24) ^ (x5 >>> 7 | xl << 25);
    }
    function Gamma1(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ x5 >>> 6;
    }
    function Gamma1l(x5, xl) {
      return (x5 >>> 19 | xl << 13) ^ (xl >>> 29 | x5 << 3) ^ (x5 >>> 6 | xl << 26);
    }
    function getCarry(a4, b6) {
      return a4 >>> 0 < b6 >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M5) {
      var W5 = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i4 = 0; i4 < 32; i4 += 2) {
        W5[i4] = M5.readInt32BE(i4 * 4);
        W5[i4 + 1] = M5.readInt32BE(i4 * 4 + 4);
      }
      for (; i4 < 160; i4 += 2) {
        var xh = W5[i4 - 15 * 2];
        var xl = W5[i4 - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = W5[i4 - 2 * 2];
        xl = W5[i4 - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = W5[i4 - 7 * 2];
        var Wi7l = W5[i4 - 7 * 2 + 1];
        var Wi16h = W5[i4 - 16 * 2];
        var Wi16l = W5[i4 - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        W5[i4] = Wih;
        W5[i4 + 1] = Wil;
      }
      for (var j7 = 0; j7 < 160; j7 += 2) {
        Wih = W5[j7];
        Wil = W5[j7 + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K4[j7];
        var Kil = K4[j7 + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H3 = Buffer3.allocUnsafe(64);
      function writeInt64BE(h6, l4, offset) {
        H3.writeInt32BE(h6, offset);
        H3.writeInt32BE(l4, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H3;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    var inherits = require_inherits_browser();
    var SHA512 = require_sha5122();
    var Hash = require_hash3();
    var Buffer3 = require_safe_buffer().Buffer;
    var W4 = new Array(160);
    function Sha384() {
      this.init();
      this._w = W4;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H3 = Buffer3.allocUnsafe(48);
      function writeInt64BE(h6, l4, offset) {
        H3.writeInt32BE(h6, offset);
        H3.writeInt32BE(l4, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H3;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha4 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    var exports = module.exports = function SHA(algorithm) {
      algorithm = algorithm.toLowerCase();
      var Algorithm = exports[algorithm];
      if (!Algorithm)
        throw new Error(algorithm + " is not supported (we accept pull requests)");
      return new Algorithm();
    };
    exports.sha = require_sha2();
    exports.sha1 = require_sha1();
    exports.sha224 = require_sha224();
    exports.sha256 = require_sha2562();
    exports.sha384 = require_sha384();
    exports.sha512 = require_sha5122();
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max3 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a4, b6) {
      var arr = [];
      for (var i4 = 0; i4 < a4.length; i4 += 1) {
        arr[i4] = a4[i4];
      }
      for (var j7 = 0; j7 < b6.length; j7 += 1) {
        arr[j7 + a4.length] = b6[j7];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i4 = offset || 0, j7 = 0; i4 < arrLike.length; i4 += 1, j7 += 1) {
        arr[j7] = arrLike[i4];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i4 = 0; i4 < arr.length; i4 += 1) {
        str += arr[i4];
        if (i4 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max3(0, target.length - args.length);
      var boundArgs = [];
      for (var i4 = 0; i4 < boundLength; i4++) {
        boundArgs[i4] = "$" + i4;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e3) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e3) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x5) {
      return x5.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e3) {
        errorProto = getProto(getProto(e3));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name2) {
      var value;
      if (name2 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name2 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name2 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name2 === "%AsyncGenerator%") {
        var fn2 = doEval2("%AsyncGeneratorFunction%");
        if (fn2) {
          value = fn2.prototype;
        }
      } else if (name2 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name2] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string3) {
      var first2 = $strSlice(string3, 0, 1);
      var last2 = $strSlice(string3, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string3, rePropName, function(match, number2, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
      var intrinsicName = name2;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
    };
    module.exports = function GetIntrinsic(name2, allowMissing) {
      if (typeof name2 !== "string" || name2.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name2) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name2);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i4 = 1, isOwn = true; i4 < parts.length; i4 += 1) {
        var part = parts[i4];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i4 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
          return true;
        } catch (e3) {
          return false;
        }
      }
      return false;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!hasPropertyDescriptors()) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e3) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e3) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors()();
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = hasPropertyDescriptors && GetIntrinsic("%Object.defineProperty%", true);
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = false;
      }
    }
    var $SyntaxError = GetIntrinsic("%SyntaxError%");
    var $TypeError = GetIntrinsic("%TypeError%");
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property2, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property2 !== "string" && typeof property2 !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property2);
      if ($defineProperty) {
        $defineProperty(obj, property2, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property2] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define3 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn2, length2) {
      if (typeof fn2 !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor(length2) !== length2) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn2 && gOPD) {
        var desc = gOPD(fn2, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define3(fn2, "length", length2, true, true);
        } else {
          define3(fn2, "length", length2);
        }
      }
      return fn2;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e3) {
        $defineProperty = null;
      }
    }
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func2 = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func2,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name2, allowMissing) {
      var intrinsic = GetIntrinsic(name2, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports, module) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O7) {
      return O7.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray2(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect4(value, from4, noIndent) {
        if (from4) {
          seen = $arrSlice.call(seen);
          seen.push(from4);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect4);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement(obj)) {
        var s3 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i4 = 0; i4 < attrs.length; i4++) {
          s3 += " " + attrs[i4].name + "=" + wrapQuotes(quote(attrs[i4].value), "double", opts);
        }
        s3 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s3 += "...";
        }
        s3 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s3;
      }
      if (isArray2(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs2 = arrObjKeys(obj, inspect4);
        if (indent && !singleLineValues(xs2)) {
          return "[" + indentedJoin(xs2, indent) + "]";
        }
        return "[ " + $join.call(xs2, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect4);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect4(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key2) {
            mapParts.push(inspect4(key2, obj, true) + " => " + inspect4(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect4(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect4(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect4(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect4(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate2(obj) && !isRegExp(obj)) {
        var ys2 = arrObjKeys(obj, inspect4);
        var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys2.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys2, indent) + "}";
        }
        return tag + "{ " + $join.call(ys2, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s3, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s3 + quoteChar;
    }
    function quote(s3) {
      return $replace.call(String(s3), /"/g, "&quot;");
    }
    function isArray2(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate2(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e3) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f5) {
      if (f5.name) {
        return f5.name;
      }
      var m5 = $match.call(functionToString.call(f5), /^function\s*([\w$]+)/);
      if (m5) {
        return m5[1];
      }
      return null;
    }
    function indexOf(xs2, x5) {
      if (xs2.indexOf) {
        return xs2.indexOf(x5);
      }
      for (var i4 = 0, l4 = xs2.length; i4 < l4; i4++) {
        if (xs2[i4] === x5) {
          return i4;
        }
      }
      return -1;
    }
    function isMap(x5) {
      if (!mapSize || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        mapSize.call(x5);
        try {
          setSize.call(x5);
        } catch (s3) {
          return true;
        }
        return x5 instanceof Map;
      } catch (e3) {
      }
      return false;
    }
    function isWeakMap(x5) {
      if (!weakMapHas || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x5, weakMapHas);
        try {
          weakSetHas.call(x5, weakSetHas);
        } catch (s3) {
          return true;
        }
        return x5 instanceof WeakMap;
      } catch (e3) {
      }
      return false;
    }
    function isWeakRef(x5) {
      if (!weakRefDeref || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x5);
        return true;
      } catch (e3) {
      }
      return false;
    }
    function isSet(x5) {
      if (!setSize || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        setSize.call(x5);
        try {
          mapSize.call(x5);
        } catch (m5) {
          return true;
        }
        return x5 instanceof Set;
      } catch (e3) {
      }
      return false;
    }
    function isWeakSet(x5) {
      if (!weakSetHas || !x5 || typeof x5 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x5, weakSetHas);
        try {
          weakMapHas.call(x5, weakMapHas);
        } catch (s3) {
          return true;
        }
        return x5 instanceof WeakSet;
      } catch (e3) {
      }
      return false;
    }
    function isElement(x5) {
      if (!x5 || typeof x5 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x5 instanceof HTMLElement) {
        return true;
      }
      return typeof x5.nodeName === "string" && typeof x5.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s3 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s3, "single", opts);
    }
    function lowbyte(c5) {
      var n3 = c5.charCodeAt(0);
      var x5 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n3];
      if (x5) {
        return "\\" + x5;
      }
      return "\\x" + (n3 < 16 ? "0" : "") + $toUpperCase.call(n3.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type2) {
      return type2 + " { ? }";
    }
    function collectionOf(type2, size2, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type2 + " (" + size2 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs2) {
      for (var i4 = 0; i4 < xs2.length; i4++) {
        if (indexOf(xs2[i4], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs2, indent) {
      if (xs2.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs2, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect4) {
      var isArr = isArray2(obj);
      var xs2 = [];
      if (isArr) {
        xs2.length = obj.length;
        for (var i4 = 0; i4 < obj.length; i4++) {
          xs2[i4] = has(obj, i4) ? inspect4(obj[i4], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k5 = 0; k5 < syms.length; k5++) {
          symMap["$" + syms[k5]] = syms[k5];
        }
      }
      for (var key2 in obj) {
        if (!has(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs2.push(inspect4(key2, obj) + ": " + inspect4(obj[key2], obj));
        } else {
          xs2.push(key2 + ": " + inspect4(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j7 = 0; j7 < syms.length; j7++) {
          if (isEnumerable.call(obj, syms[j7])) {
            xs2.push("[" + inspect4(syms[j7]) + "]: " + inspect4(obj[syms[j7]], obj));
          }
        }
      }
      return xs2;
    }
  }
});

// node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "node_modules/side-channel/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect4 = require_object_inspect();
    var $TypeError = GetIntrinsic("%TypeError%");
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key2) {
      for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key2) {
          prev.next = curr.next;
          curr.next = list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key2) {
      var node = listGetNode(objects, key2);
      return node && node.value;
    };
    var listSet = function(objects, key2, value) {
      var node = listGetNode(objects, key2);
      if (node) {
        node.value = value;
      } else {
        objects.next = {
          // eslint-disable-line no-param-reassign
          key: key2,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key2) {
      return !!listGetNode(objects, key2);
    };
    module.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key2) {
          if (!channel.has(key2)) {
            throw new $TypeError("Side channel does not contain " + inspect4(key2));
          }
        },
        get: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key2);
            }
          } else {
            if ($o) {
              return listGet($o, key2);
            }
          }
        },
        has: function(key2) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key2);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key2);
            }
          } else {
            if ($o) {
              return listHas($o, key2);
            }
          }
          return false;
        },
        set: function(key2, value) {
          if ($WeakMap && key2 && (typeof key2 === "object" || typeof key2 === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key2, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key2, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key2, value);
          }
        }
      };
      return channel;
    };
  }
});

// node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "node_modules/qs/lib/formats.js"(exports, module) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// node_modules/qs/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/qs/lib/utils.js"(exports, module) {
    "use strict";
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var hexTable = function() {
      var array2 = [];
      for (var i4 = 0; i4 < 256; ++i4) {
        array2.push("%" + ((i4 < 16 ? "0" : "") + i4.toString(16)).toUpperCase());
      }
      return array2;
    }();
    var compactQueue = function compactQueue2(queue2) {
      while (queue2.length > 1) {
        var item = queue2.pop();
        var obj = item.obj[item.prop];
        if (isArray2(obj)) {
          var compacted = [];
          for (var j7 = 0; j7 < obj.length; ++j7) {
            if (typeof obj[j7] !== "undefined") {
              compacted.push(obj[j7]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i4 = 0; i4 < source.length; ++i4) {
        if (typeof source[i4] !== "undefined") {
          obj[i4] = source[i4];
        }
      }
      return obj;
    };
    var merge3 = function merge4(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray2(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray2(target) && !isArray2(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray2(target) && isArray2(source)) {
        source.forEach(function(item, i4) {
          if (has.call(target, i4)) {
            var targetItem = target[i4];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i4] = merge4(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i4] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key2) {
        var value = source[key2];
        if (has.call(acc, key2)) {
          acc[key2] = merge4(acc[key2], value, options);
        } else {
          acc[key2] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign2 = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key2) {
        acc[key2] = source[key2];
        return acc;
      }, target);
    };
    var decode8 = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e3) {
        return strWithoutPlus;
      }
    };
    var encode8 = function encode9(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string3 = str;
      if (typeof str === "symbol") {
        string3 = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string3 = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string3).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var i4 = 0; i4 < string3.length; ++i4) {
        var c5 = string3.charCodeAt(i4);
        if (c5 === 45 || c5 === 46 || c5 === 95 || c5 === 126 || c5 >= 48 && c5 <= 57 || c5 >= 65 && c5 <= 90 || c5 >= 97 && c5 <= 122 || format === formats.RFC1738 && (c5 === 40 || c5 === 41)) {
          out += string3.charAt(i4);
          continue;
        }
        if (c5 < 128) {
          out = out + hexTable[c5];
          continue;
        }
        if (c5 < 2048) {
          out = out + (hexTable[192 | c5 >> 6] + hexTable[128 | c5 & 63]);
          continue;
        }
        if (c5 < 55296 || c5 >= 57344) {
          out = out + (hexTable[224 | c5 >> 12] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63]);
          continue;
        }
        i4 += 1;
        c5 = 65536 + ((c5 & 1023) << 10 | string3.charCodeAt(i4) & 1023);
        out += hexTable[240 | c5 >> 18] + hexTable[128 | c5 >> 12 & 63] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
      }
      return out;
    };
    var compact = function compact2(value) {
      var queue2 = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i4 = 0; i4 < queue2.length; ++i4) {
        var item = queue2[i4];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j7 = 0; j7 < keys2.length; ++j7) {
          var key2 = keys2[j7];
          var val = obj[key2];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue2.push({ obj, prop: key2 });
            refs.push(val);
          }
        }
      }
      compactQueue(queue2);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a4, b6) {
      return [].concat(a4, b6);
    };
    var maybeMap = function maybeMap2(val, fn2) {
      if (isArray2(val)) {
        var mapped = [];
        for (var i4 = 0; i4 < val.length; i4 += 1) {
          mapped.push(fn2(val[i4]));
        }
        return mapped;
      }
      return fn2(val);
    };
    module.exports = {
      arrayToObject,
      assign: assign2,
      combine,
      compact,
      decode: decode8,
      encode: encode8,
      isBuffer,
      isRegExp,
      maybeMap,
      merge: merge3
    };
  }
});

// node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/qs/lib/stringify.js"(exports, module) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils5();
    var formats = require_formats();
    var has = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key2) {
        return prefix + "[" + key2 + "]";
      },
      repeat: function repeat2(prefix) {
        return prefix;
      }
    };
    var isArray2 = Array.isArray;
    var push = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date2) {
        return toISO.call(date2);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v5) {
      return typeof v5 === "string" || typeof v5 === "number" || typeof v5 === "boolean" || typeof v5 === "symbol" || typeof v5 === "bigint";
    };
    var sentinel = {};
    var stringify3 = function stringify4(object2, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object2;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object2);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values = [];
      if (typeof obj === "undefined") {
        return values;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray2(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray2(filter2)) {
        objKeys = filter2;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
      for (var j7 = 0; j7 < objKeys.length; ++j7) {
        var key2 = objKeys[j7];
        var value = typeof key2 === "object" && typeof key2.value !== "undefined" ? key2.value : obj[key2];
        if (skipNulls && value === null) {
          continue;
        }
        var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key2) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key2 : "[" + key2 + "]");
        sideChannel.set(object2, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values, stringify4(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          strictNullHandling,
          skipNulls,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray2(opts.filter)) {
        filter2 = opts.filter;
      }
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(object2, opts) {
      var obj = object2;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray2(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var arrayFormat;
      if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if (opts && "indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = "indices";
      }
      var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
      if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i4 = 0; i4 < objKeys.length; ++i4) {
        var key2 = objKeys[i4];
        if (options.skipNulls && obj[key2] === null) {
          continue;
        }
        pushToArray(keys2, stringify3(
          obj[key2],
          key2,
          generateArrayPrefix,
          commaRoundTrip,
          options.strictNullHandling,
          options.skipNulls,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys2.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "node_modules/qs/lib/parse.js"(exports, module) {
    "use strict";
    var utils = require_utils5();
    var has = Object.prototype.hasOwnProperty;
    var isArray2 = Array.isArray;
    var defaults = {
      allowDots: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i4;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i4 = 0; i4 < parts.length; ++i4) {
          if (parts[i4].indexOf("utf8=") === 0) {
            if (parts[i4] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i4] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i4;
            i4 = parts.length;
          }
        }
      }
      for (i4 = 0; i4 < parts.length; ++i4) {
        if (i4 === skipIndex) {
          continue;
        }
        var part = parts[i4];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key2, val;
        if (pos === -1) {
          key2 = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key2 = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray2(val) ? [val] : val;
        }
        if (has.call(obj, key2)) {
          obj[key2] = utils.combine(obj[key2], val);
        } else {
          obj[key2] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i4 = chain.length - 1; i4 >= 0; --i4) {
        var obj;
        var root = chain[i4];
        if (root === "[]" && options.parseArrays) {
          obj = [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
          var index = parseInt(cleanRoot, 10);
          if (!options.parseArrays && cleanRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root !== cleanRoot && String(index) === cleanRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (cleanRoot !== "__proto__") {
            obj[cleanRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key2 = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key2);
      var parent = segment ? key2.slice(0, segment.index) : key2;
      var keys2 = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(parent);
      }
      var i4 = 0;
      while (options.depth > 0 && (segment = child.exec(key2)) !== null && i4 < options.depth) {
        i4 += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(segment[1]);
      }
      if (segment) {
        keys2.push("[" + key2.slice(segment.index) + "]");
      }
      return parseObject(keys2, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      return {
        allowDots: typeof opts.allowDots === "undefined" ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys2 = Object.keys(tempObj);
      for (var i4 = 0; i4 < keys2.length; ++i4) {
        var key2 = keys2[i4];
        var newObj = parseKeys(key2, tempObj[key2], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// node_modules/qs/lib/index.js
var require_lib = __commonJS({
  "node_modules/qs/lib/index.js"(exports, module) {
    "use strict";
    var stringify3 = require_stringify();
    var parse3 = require_parse();
    var formats = require_formats();
    module.exports = {
      formats,
      parse: parse3,
      stringify: stringify3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/types.js
var require_types3 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderType = exports.RegExpString = exports.IntNumber = exports.BigIntString = exports.AddressString = exports.HexString = exports.OpaqueType = void 0;
    function OpaqueType() {
      return (value) => value;
    }
    exports.OpaqueType = OpaqueType;
    exports.HexString = OpaqueType();
    exports.AddressString = OpaqueType();
    exports.BigIntString = OpaqueType();
    function IntNumber(num) {
      return Math.floor(num);
    }
    exports.IntNumber = IntNumber;
    exports.RegExpString = OpaqueType();
    var ProviderType;
    (function(ProviderType2) {
      ProviderType2["CoinbaseWallet"] = "CoinbaseWallet";
      ProviderType2["MetaMask"] = "MetaMask";
      ProviderType2["Unselected"] = "";
    })(ProviderType = exports.ProviderType || (exports.ProviderType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/util.js
var require_util2 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/util.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isInIFrame = exports.createQrUrl = exports.getFavicon = exports.range = exports.isBigNumber = exports.ensureParsedJSONObject = exports.ensureBN = exports.ensureRegExpString = exports.ensureIntNumber = exports.ensureBuffer = exports.ensureAddressString = exports.ensureEvenLengthHexString = exports.ensureHexString = exports.isHexString = exports.prepend0x = exports.strip0x = exports.has0xPrefix = exports.hexStringFromIntNumber = exports.intNumberFromHexString = exports.bigIntStringFromBN = exports.hexStringFromBuffer = exports.hexStringToUint8Array = exports.uint8ArrayToHex = exports.randomBytesHex = void 0;
    var bn_js_1 = __importDefault3(require_bn());
    var qs_1 = require_lib();
    var errors_1 = require_errors2();
    var types_1 = require_types3();
    var INT_STRING_REGEX = /^[0-9]*$/;
    var HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
    function randomBytesHex(length2) {
      return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length2)));
    }
    exports.randomBytesHex = randomBytesHex;
    function uint8ArrayToHex(value) {
      return [...value].map((b6) => b6.toString(16).padStart(2, "0")).join("");
    }
    exports.uint8ArrayToHex = uint8ArrayToHex;
    function hexStringToUint8Array(hexString) {
      return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
    }
    exports.hexStringToUint8Array = hexStringToUint8Array;
    function hexStringFromBuffer(buf, includePrefix = false) {
      const hex = buf.toString("hex");
      return (0, types_1.HexString)(includePrefix ? "0x" + hex : hex);
    }
    exports.hexStringFromBuffer = hexStringFromBuffer;
    function bigIntStringFromBN(bn2) {
      return (0, types_1.BigIntString)(bn2.toString(10));
    }
    exports.bigIntStringFromBN = bigIntStringFromBN;
    function intNumberFromHexString(hex) {
      return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
    }
    exports.intNumberFromHexString = intNumberFromHexString;
    function hexStringFromIntNumber(num) {
      return (0, types_1.HexString)("0x" + new bn_js_1.default(num).toString(16));
    }
    exports.hexStringFromIntNumber = hexStringFromIntNumber;
    function has0xPrefix(str) {
      return str.startsWith("0x") || str.startsWith("0X");
    }
    exports.has0xPrefix = has0xPrefix;
    function strip0x(hex) {
      if (has0xPrefix(hex)) {
        return hex.slice(2);
      }
      return hex;
    }
    exports.strip0x = strip0x;
    function prepend0x(hex) {
      if (has0xPrefix(hex)) {
        return "0x" + hex.slice(2);
      }
      return "0x" + hex;
    }
    exports.prepend0x = prepend0x;
    function isHexString2(hex) {
      if (typeof hex !== "string") {
        return false;
      }
      const s3 = strip0x(hex).toLowerCase();
      return HEXADECIMAL_STRING_REGEX.test(s3);
    }
    exports.isHexString = isHexString2;
    function ensureHexString(hex, includePrefix = false) {
      if (typeof hex === "string") {
        const s3 = strip0x(hex).toLowerCase();
        if (HEXADECIMAL_STRING_REGEX.test(s3)) {
          return (0, types_1.HexString)(includePrefix ? "0x" + s3 : s3);
        }
      }
      throw errors_1.standardErrors.rpc.invalidParams(`"${String(hex)}" is not a hexadecimal string`);
    }
    exports.ensureHexString = ensureHexString;
    function ensureEvenLengthHexString(hex, includePrefix = false) {
      let h6 = ensureHexString(hex, false);
      if (h6.length % 2 === 1) {
        h6 = (0, types_1.HexString)("0" + h6);
      }
      return includePrefix ? (0, types_1.HexString)("0x" + h6) : h6;
    }
    exports.ensureEvenLengthHexString = ensureEvenLengthHexString;
    function ensureAddressString(str) {
      if (typeof str === "string") {
        const s3 = strip0x(str).toLowerCase();
        if (isHexString2(s3) && s3.length === 40) {
          return (0, types_1.AddressString)(prepend0x(s3));
        }
      }
      throw errors_1.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(str)}`);
    }
    exports.ensureAddressString = ensureAddressString;
    function ensureBuffer(str) {
      if (Buffer.isBuffer(str)) {
        return str;
      }
      if (typeof str === "string") {
        if (isHexString2(str)) {
          const s3 = ensureEvenLengthHexString(str, false);
          return Buffer.from(s3, "hex");
        } else {
          return Buffer.from(str, "utf8");
        }
      }
      throw errors_1.standardErrors.rpc.invalidParams(`Not binary data: ${String(str)}`);
    }
    exports.ensureBuffer = ensureBuffer;
    function ensureIntNumber(num) {
      if (typeof num === "number" && Number.isInteger(num)) {
        return (0, types_1.IntNumber)(num);
      }
      if (typeof num === "string") {
        if (INT_STRING_REGEX.test(num)) {
          return (0, types_1.IntNumber)(Number(num));
        }
        if (isHexString2(num)) {
          return (0, types_1.IntNumber)(new bn_js_1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
        }
      }
      throw errors_1.standardErrors.rpc.invalidParams(`Not an integer: ${String(num)}`);
    }
    exports.ensureIntNumber = ensureIntNumber;
    function ensureRegExpString(regExp) {
      if (regExp instanceof RegExp) {
        return (0, types_1.RegExpString)(regExp.toString());
      }
      throw errors_1.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(regExp)}`);
    }
    exports.ensureRegExpString = ensureRegExpString;
    function ensureBN(val) {
      if (val !== null && (bn_js_1.default.isBN(val) || isBigNumber(val))) {
        return new bn_js_1.default(val.toString(10), 10);
      }
      if (typeof val === "number") {
        return new bn_js_1.default(ensureIntNumber(val));
      }
      if (typeof val === "string") {
        if (INT_STRING_REGEX.test(val)) {
          return new bn_js_1.default(val, 10);
        }
        if (isHexString2(val)) {
          return new bn_js_1.default(ensureEvenLengthHexString(val, false), 16);
        }
      }
      throw errors_1.standardErrors.rpc.invalidParams(`Not an integer: ${String(val)}`);
    }
    exports.ensureBN = ensureBN;
    function ensureParsedJSONObject(val) {
      if (typeof val === "string") {
        return JSON.parse(val);
      }
      if (typeof val === "object") {
        return val;
      }
      throw errors_1.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(val)}`);
    }
    exports.ensureParsedJSONObject = ensureParsedJSONObject;
    function isBigNumber(val) {
      if (val == null || typeof val.constructor !== "function") {
        return false;
      }
      const { constructor } = val;
      return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
    }
    exports.isBigNumber = isBigNumber;
    function range2(start, stop) {
      return Array.from({ length: stop - start }, (_6, i4) => start + i4);
    }
    exports.range = range2;
    function getFavicon() {
      const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
      const { protocol, host } = document.location;
      const href = el ? el.getAttribute("href") : null;
      if (!href || href.startsWith("javascript:")) {
        return null;
      }
      if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
        return href;
      }
      if (href.startsWith("//")) {
        return protocol + href;
      }
      return `${protocol}//${host}${href}`;
    }
    exports.getFavicon = getFavicon;
    function createQrUrl(sessionId, sessionSecret, serverUrl, isParentConnection, version28, chainId) {
      const sessionIdKey = isParentConnection ? "parent-id" : "id";
      const query = (0, qs_1.stringify)({
        [sessionIdKey]: sessionId,
        secret: sessionSecret,
        server: serverUrl,
        v: version28,
        chainId
      });
      const qrUrl = `${serverUrl}/#/link?${query}`;
      return qrUrl;
    }
    exports.createQrUrl = createQrUrl;
    function isInIFrame() {
      try {
        return window.frameElement !== null;
      } catch (e3) {
        return false;
      }
    }
    exports.isInIFrame = isInIFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Session.js
var require_Session = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Session.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Session = void 0;
    var sha_js_1 = require_sha4();
    var util_1 = require_util2();
    var STORAGE_KEY_SESSION_ID = "session:id";
    var STORAGE_KEY_SESSION_SECRET = "session:secret";
    var STORAGE_KEY_SESSION_LINKED = "session:linked";
    var Session = class _Session {
      constructor(storage, id2, secret, linked) {
        this._storage = storage;
        this._id = id2 || (0, util_1.randomBytesHex)(16);
        this._secret = secret || (0, util_1.randomBytesHex)(32);
        this._key = new sha_js_1.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex");
        this._linked = !!linked;
      }
      static load(storage) {
        const id2 = storage.getItem(STORAGE_KEY_SESSION_ID);
        const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
        const secret = storage.getItem(STORAGE_KEY_SESSION_SECRET);
        if (id2 && secret) {
          return new _Session(storage, id2, secret, linked === "1");
        }
        return null;
      }
      /**
       * Takes in a session ID and returns the sha256 hash of it.
       * @param sessionId session ID
       */
      static hash(sessionId) {
        return new sha_js_1.sha256().update(sessionId).digest("hex");
      }
      get id() {
        return this._id;
      }
      get secret() {
        return this._secret;
      }
      get key() {
        return this._key;
      }
      get linked() {
        return this._linked;
      }
      set linked(val) {
        this._linked = val;
        this.persistLinked();
      }
      save() {
        this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
        this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
        this.persistLinked();
        return this;
      }
      persistLinked() {
        this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
      }
    };
    exports.Session = Session;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js
var require_WalletSDKRelayAbstract = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayAbstract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelayAbstract = exports.APP_VERSION_KEY = exports.LOCAL_STORAGE_ADDRESSES_KEY = exports.WALLET_USER_NAME_KEY = void 0;
    var errors_1 = require_errors2();
    exports.WALLET_USER_NAME_KEY = "walletUsername";
    exports.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
    exports.APP_VERSION_KEY = "AppVersion";
    var WalletSDKRelayAbstract = class {
      async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
        if (!jsonRpcUrl)
          throw new Error("Error: No jsonRpcUrl provided");
        return window.fetch(jsonRpcUrl, {
          method: "POST",
          body: JSON.stringify(request),
          mode: "cors",
          headers: { "Content-Type": "application/json" }
        }).then((res) => res.json()).then((json) => {
          if (!json) {
            throw errors_1.standardErrors.rpc.parse({});
          }
          const response = json;
          const { error } = response;
          if (error) {
            throw (0, errors_1.serializeError)(error, request.method);
          }
          return response;
        });
      }
    };
    exports.WalletSDKRelayAbstract = WalletSDKRelayAbstract;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// browser-external:util
var require_util3 = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_6, key2) {
        if (key2 !== "__esModule" && key2 !== "__proto__" && key2 !== "constructor" && key2 !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key2}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    function ownKeys(object2, enumerableOnly) {
      var keys2 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
        })), keys2.push.apply(keys2, symbols);
      }
      return keys2;
    }
    function _objectSpread(target) {
      for (var i4 = 1; i4 < arguments.length; i4++) {
        var source = null != arguments[i4] ? arguments[i4] : {};
        i4 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
          _defineProperty(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i4 = 0; i4 < props.length; i4++) {
        var descriptor = props[i4];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer2();
    var Buffer3 = _require.Buffer;
    var _require2 = require_util3();
    var inspect4 = _require2.inspect;
    var custom = inspect4 && inspect4.custom || "inspect";
    function copyBuffer(src2, target, offset) {
      Buffer3.prototype.copy.call(src2, target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v5) {
          var entry = {
            data: v5,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v5) {
          var entry = {
            data: v5,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear2() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s3) {
          if (this.length === 0)
            return "";
          var p6 = this.head;
          var ret = "" + p6.data;
          while (p6 = p6.next)
            ret += s3 + p6.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat5(n3) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n3 >>> 0);
          var p6 = this.head;
          var i4 = 0;
          while (p6) {
            copyBuffer(p6.data, ret, i4);
            i4 += p6.data.length;
            p6 = p6.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p6 = this.head;
          var c5 = 1;
          var ret = p6.data;
          n3 -= ret.length;
          while (p6 = p6.next) {
            var str = p6.data;
            var nb = n3 > str.length ? str.length : n3;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str.length) {
                ++c5;
                if (p6.next)
                  this.head = p6.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p6;
                p6.data = str.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer3.allocUnsafe(n3);
          var p6 = this.head;
          var c5 = 1;
          p6.data.copy(ret);
          n3 -= p6.data.length;
          while (p6 = p6.next) {
            var buf = p6.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c5;
                if (p6.next)
                  this.head = p6.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p6;
                p6.data = buf.slice(nb);
              }
              break;
            }
            ++c5;
          }
          this.length -= c5;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_6, options) {
          return inspect4(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports, module) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code2, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code2;
      codes[code2] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i4) {
          return String(i4);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type2 = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state3, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state3.objectMode ? 16 : 16 * 1024;
    }
    module.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser4 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate2;
    function deprecate2(fn2, msg) {
      if (config2("noDeprecation")) {
        return fn2;
      }
      var warned = false;
      function deprecated2() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated2;
    }
    function config2(name2) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_6) {
        return false;
      }
      var val = global.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    module.exports = Writable;
    function CorkedRequest(state3) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state3);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser4()
    };
    var Stream = require_stream_browser();
    var Buffer3 = require_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er3) {
        onwrite(stream, er3);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_6) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object2) {
          if (realHasInstance.call(this, object2))
            return true;
          if (this !== Writable)
            return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er3 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er3);
      process.nextTick(cb, er3);
    }
    function validChunk(stream, state3, chunk, cb) {
      var er3;
      if (chunk === null) {
        er3 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state3.objectMode) {
        er3 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er3) {
        errorOrDestroy(stream, er3);
        process.nextTick(cb, er3);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state3 = this._writableState;
      var ret = false;
      var isBuf = !state3.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state3.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state3.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state3, chunk, cb)) {
        state3.pendingcb++;
        ret = writeOrBuffer(this, state3, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state3 = this._writableState;
      if (state3.corked) {
        state3.corked--;
        if (!state3.writing && !state3.corked && !state3.bufferProcessing && state3.bufferedRequest)
          clearBuffer(this, state3);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state3, chunk, encoding) {
      if (!state3.objectMode && state3.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state3, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state3, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state3.objectMode ? 1 : chunk.length;
      state3.length += len;
      var ret = state3.length < state3.highWaterMark;
      if (!ret)
        state3.needDrain = true;
      if (state3.writing || state3.corked) {
        var last2 = state3.lastBufferedRequest;
        state3.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last2) {
          last2.next = state3.lastBufferedRequest;
        } else {
          state3.bufferedRequest = state3.lastBufferedRequest;
        }
        state3.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state3, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state3, writev, len, chunk, encoding, cb) {
      state3.writelen = len;
      state3.writecb = cb;
      state3.writing = true;
      state3.sync = true;
      if (state3.destroyed)
        state3.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state3.onwrite);
      else
        stream._write(chunk, encoding, state3.onwrite);
      state3.sync = false;
    }
    function onwriteError(stream, state3, sync, er3, cb) {
      --state3.pendingcb;
      if (sync) {
        process.nextTick(cb, er3);
        process.nextTick(finishMaybe, stream, state3);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er3);
      } else {
        cb(er3);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er3);
        finishMaybe(stream, state3);
      }
    }
    function onwriteStateUpdate(state3) {
      state3.writing = false;
      state3.writecb = null;
      state3.length -= state3.writelen;
      state3.writelen = 0;
    }
    function onwrite(stream, er3) {
      var state3 = stream._writableState;
      var sync = state3.sync;
      var cb = state3.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state3);
      if (er3)
        onwriteError(stream, state3, sync, er3, cb);
      else {
        var finished = needFinish(state3) || stream.destroyed;
        if (!finished && !state3.corked && !state3.bufferProcessing && state3.bufferedRequest) {
          clearBuffer(stream, state3);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state3, finished, cb);
        } else {
          afterWrite(stream, state3, finished, cb);
        }
      }
    }
    function afterWrite(stream, state3, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state3);
      state3.pendingcb--;
      cb();
      finishMaybe(stream, state3);
    }
    function onwriteDrain(stream, state3) {
      if (state3.length === 0 && state3.needDrain) {
        state3.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state3) {
      state3.bufferProcessing = true;
      var entry = state3.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l4 = state3.bufferedRequestCount;
        var buffer2 = new Array(l4);
        var holder = state3.corkedRequestsFree;
        holder.entry = entry;
        var count2 = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count2] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count2 += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state3, true, state3.length, buffer2, "", holder.finish);
        state3.pendingcb++;
        state3.lastBufferedRequest = null;
        if (holder.next) {
          state3.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state3.corkedRequestsFree = new CorkedRequest(state3);
        }
        state3.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state3.objectMode ? 1 : chunk.length;
          doWrite(stream, state3, false, len, chunk, encoding, cb);
          entry = entry.next;
          state3.bufferedRequestCount--;
          if (state3.writing) {
            break;
          }
        }
        if (entry === null)
          state3.lastBufferedRequest = null;
      }
      state3.bufferedRequest = entry;
      state3.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state3 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state3.corked) {
        state3.corked = 1;
        this.uncork();
      }
      if (!state3.ending)
        endWritable(this, state3, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function needFinish(state3) {
      return state3.ending && state3.length === 0 && state3.bufferedRequest === null && !state3.finished && !state3.writing;
    }
    function callFinal(stream, state3) {
      stream._final(function(err) {
        state3.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state3.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state3);
      });
    }
    function prefinish(stream, state3) {
      if (!state3.prefinished && !state3.finalCalled) {
        if (typeof stream._final === "function" && !state3.destroyed) {
          state3.pendingcb++;
          state3.finalCalled = true;
          process.nextTick(callFinal, stream, state3);
        } else {
          state3.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state3) {
      var need = needFinish(state3);
      if (need) {
        prefinish(stream, state3);
        if (state3.pendingcb === 0) {
          state3.finished = true;
          stream.emit("finish");
          if (state3.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state3, cb) {
      state3.ending = true;
      finishMaybe(stream, state3);
      if (cb) {
        if (state3.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state3.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state3, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state3.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state3.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set3(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key2 in obj)
        keys3.push(key2);
      return keys3;
    };
    module.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v5 = 0; v5 < keys2.length; v5++) {
        method = keys2[v5];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v5;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set3(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r5;
      var i4;
      if (this.lastNeed) {
        r5 = this.fillLast(buf);
        if (r5 === void 0)
          return "";
        i4 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i4 = 0;
      }
      if (i4 < buf.length)
        return r5 ? r5 + this.text(buf, i4) : this.text(buf, i4);
      return r5 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i4) {
      var j7 = buf.length - 1;
      if (j7 < i4)
        return 0;
      var nb = utf8CheckByte(buf[j7]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j7 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j7]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j7 < i4 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j7]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p6) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p6 = this.lastTotal - this.lastNeed;
      var r5 = utf8CheckExtraBytes(this, buf, p6);
      if (r5 !== void 0)
        return r5;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p6, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p6, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i4) {
      var total = utf8CheckIncomplete(this, buf, i4);
      if (!this.lastNeed)
        return buf.toString("utf8", i4);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i4, end);
    }
    function utf8End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r5 + "�";
      return r5;
    }
    function utf16Text(buf, i4) {
      if ((buf.length - i4) % 2 === 0) {
        var r5 = buf.toString("utf16le", i4);
        if (r5) {
          var c5 = r5.charCodeAt(r5.length - 1);
          if (c5 >= 55296 && c5 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r5.slice(0, -1);
          }
        }
        return r5;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i4, buf.length - 1);
    }
    function utf16End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r5 + this.lastChar.toString("utf16le", 0, end);
      }
      return r5;
    }
    function base64Text(buf, i4) {
      var n3 = (buf.length - i4) % 3;
      if (n3 === 0)
        return buf.toString("base64", i4);
      this.lastNeed = 3 - n3;
      this.lastTotal = 3;
      if (n3 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i4, buf.length - n3);
    }
    function base64End(buf) {
      var r5 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r5 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r5;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key2, value) {
      key2 = _toPropertyKey(key2);
      if (key2 in obj) {
        Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key2] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key2 = _toPrimitive(arg, "string");
      return typeof key2 === "symbol" ? key2 : String(key2);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data3 = iter[kStream].read();
        if (data3 !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data3, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data3 = this[kStream].read();
          if (data3 !== null) {
            return Promise.resolve(createIterResult(data3, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data3 = iterator2[kStream].read();
          if (data3) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            resolve(createIterResult(data3, false));
          } else {
            iterator2[kLastResolve] = resolve;
            iterator2[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator2[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator2[kLastReject];
          if (reject !== null) {
            iterator2[kLastPromise] = null;
            iterator2[kLastResolve] = null;
            iterator2[kLastReject] = null;
            reject(err);
          }
          iterator2[kError] = err;
          return;
        }
        var resolve = iterator2[kLastResolve];
        if (resolve !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator2[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator2));
      return iterator2;
    };
    module.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    module.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type2) {
      return emitter.listeners(type2).length;
    };
    var Stream = require_stream_browser();
    var Buffer3 = require_buffer2().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util3();
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from4;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn2) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn2);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn2);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn2);
      else
        emitter._events[event] = [fn2, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set3(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state3 = this._readableState;
      var skipChunkCheck;
      if (!state3.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state3.defaultEncoding;
          if (encoding !== state3.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state3 = stream._readableState;
      if (chunk === null) {
        state3.reading = false;
        onEofChunk(stream, state3);
      } else {
        var er3;
        if (!skipChunkCheck)
          er3 = chunkInvalid(state3, chunk);
        if (er3) {
          errorOrDestroy(stream, er3);
        } else if (state3.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state3.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state3.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state3, chunk, true);
          } else if (state3.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state3.destroyed) {
            return false;
          } else {
            state3.reading = false;
            if (state3.decoder && !encoding) {
              chunk = state3.decoder.write(chunk);
              if (state3.objectMode || chunk.length !== 0)
                addChunk(stream, state3, chunk, false);
              else
                maybeReadMore(stream, state3);
            } else {
              addChunk(stream, state3, chunk, false);
            }
          }
        } else if (!addToFront) {
          state3.reading = false;
          maybeReadMore(stream, state3);
        }
      }
      return !state3.ended && (state3.length < state3.highWaterMark || state3.length === 0);
    }
    function addChunk(stream, state3, chunk, addToFront) {
      if (state3.flowing && state3.length === 0 && !state3.sync) {
        state3.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state3.length += state3.objectMode ? 1 : chunk.length;
        if (addToFront)
          state3.buffer.unshift(chunk);
        else
          state3.buffer.push(chunk);
        if (state3.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state3);
    }
    function chunkInvalid(state3, chunk) {
      var er3;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state3.objectMode) {
        er3 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er3;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p6 = this._readableState.buffer.head;
      var content = "";
      while (p6 !== null) {
        content += decoder.write(p6.data);
        p6 = p6.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n3) {
      if (n3 >= MAX_HWM) {
        n3 = MAX_HWM;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead(n3, state3) {
      if (n3 <= 0 || state3.length === 0 && state3.ended)
        return 0;
      if (state3.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state3.flowing && state3.length)
          return state3.buffer.head.data.length;
        else
          return state3.length;
      }
      if (n3 > state3.highWaterMark)
        state3.highWaterMark = computeNewHighWaterMark(n3);
      if (n3 <= state3.length)
        return n3;
      if (!state3.ended) {
        state3.needReadable = true;
        return 0;
      }
      return state3.length;
    }
    Readable.prototype.read = function(n3) {
      debug("read", n3);
      n3 = parseInt(n3, 10);
      var state3 = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state3.emittedReadable = false;
      if (n3 === 0 && state3.needReadable && ((state3.highWaterMark !== 0 ? state3.length >= state3.highWaterMark : state3.length > 0) || state3.ended)) {
        debug("read: emitReadable", state3.length, state3.ended);
        if (state3.length === 0 && state3.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n3 = howMuchToRead(n3, state3);
      if (n3 === 0 && state3.ended) {
        if (state3.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state3.needReadable;
      debug("need readable", doRead);
      if (state3.length === 0 || state3.length - n3 < state3.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state3.ended || state3.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state3.reading = true;
        state3.sync = true;
        if (state3.length === 0)
          state3.needReadable = true;
        this._read(state3.highWaterMark);
        state3.sync = false;
        if (!state3.reading)
          n3 = howMuchToRead(nOrig, state3);
      }
      var ret;
      if (n3 > 0)
        ret = fromList(n3, state3);
      else
        ret = null;
      if (ret === null) {
        state3.needReadable = state3.length <= state3.highWaterMark;
        n3 = 0;
      } else {
        state3.length -= n3;
        state3.awaitDrain = 0;
      }
      if (state3.length === 0) {
        if (!state3.ended)
          state3.needReadable = true;
        if (nOrig !== n3 && state3.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state3) {
      debug("onEofChunk");
      if (state3.ended)
        return;
      if (state3.decoder) {
        var chunk = state3.decoder.end();
        if (chunk && chunk.length) {
          state3.buffer.push(chunk);
          state3.length += state3.objectMode ? 1 : chunk.length;
        }
      }
      state3.ended = true;
      if (state3.sync) {
        emitReadable(stream);
      } else {
        state3.needReadable = false;
        if (!state3.emittedReadable) {
          state3.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state3 = stream._readableState;
      debug("emitReadable", state3.needReadable, state3.emittedReadable);
      state3.needReadable = false;
      if (!state3.emittedReadable) {
        debug("emitReadable", state3.flowing);
        state3.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state3 = stream._readableState;
      debug("emitReadable_", state3.destroyed, state3.length, state3.ended);
      if (!state3.destroyed && (state3.length || state3.ended)) {
        stream.emit("readable");
        state3.emittedReadable = false;
      }
      state3.needReadable = !state3.flowing && !state3.ended && state3.length <= state3.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state3) {
      if (!state3.readingMore) {
        state3.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state3);
      }
    }
    function maybeReadMore_(stream, state3) {
      while (!state3.reading && !state3.ended && (state3.length < state3.highWaterMark || state3.flowing && state3.length === 0)) {
        var len = state3.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state3.length)
          break;
      }
      state3.readingMore = false;
    }
    Readable.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state3 = this._readableState;
      switch (state3.pipesCount) {
        case 0:
          state3.pipes = dest;
          break;
        case 1:
          state3.pipes = [state3.pipes, dest];
          break;
        default:
          state3.pipes.push(dest);
          break;
      }
      state3.pipesCount += 1;
      debug("pipe count=%d opts=%j", state3.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state3.endEmitted)
        process.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state3.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src2.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state3.pipesCount === 1 && state3.pipes === dest || state3.pipesCount > 1 && indexOf(state3.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state3.awaitDrain);
            state3.awaitDrain++;
          }
          src2.pause();
        }
      }
      function onerror(er3) {
        debug("onerror", er3);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er3);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state3.flowing) {
        debug("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function pipeOnDrainFunctionResult() {
        var state3 = src2._readableState;
        debug("pipeOnDrain", state3.awaitDrain);
        if (state3.awaitDrain)
          state3.awaitDrain--;
        if (state3.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state3.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state3 = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state3.pipesCount === 0)
        return this;
      if (state3.pipesCount === 1) {
        if (dest && dest !== state3.pipes)
          return this;
        if (!dest)
          dest = state3.pipes;
        state3.pipes = null;
        state3.pipesCount = 0;
        state3.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state3.pipes;
        var len = state3.pipesCount;
        state3.pipes = null;
        state3.pipesCount = 0;
        state3.flowing = false;
        for (var i4 = 0; i4 < len; i4++)
          dests[i4].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state3.pipes, dest);
      if (index === -1)
        return this;
      state3.pipes.splice(index, 1);
      state3.pipesCount -= 1;
      if (state3.pipesCount === 1)
        state3.pipes = state3.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev2, fn2) {
      var res = Stream.prototype.on.call(this, ev2, fn2);
      var state3 = this._readableState;
      if (ev2 === "data") {
        state3.readableListening = this.listenerCount("readable") > 0;
        if (state3.flowing !== false)
          this.resume();
      } else if (ev2 === "readable") {
        if (!state3.endEmitted && !state3.readableListening) {
          state3.readableListening = state3.needReadable = true;
          state3.flowing = false;
          state3.emittedReadable = false;
          debug("on readable", state3.length, state3.reading);
          if (state3.length) {
            emitReadable(this);
          } else if (!state3.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev2, fn2) {
      var res = Stream.prototype.removeListener.call(this, ev2, fn2);
      if (ev2 === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev2) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev2 === "readable" || ev2 === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state3 = self2._readableState;
      state3.readableListening = self2.listenerCount("readable") > 0;
      if (state3.resumeScheduled && !state3.paused) {
        state3.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state3 = this._readableState;
      if (!state3.flowing) {
        debug("resume");
        state3.flowing = !state3.readableListening;
        resume(this, state3);
      }
      state3.paused = false;
      return this;
    };
    function resume(stream, state3) {
      if (!state3.resumeScheduled) {
        state3.resumeScheduled = true;
        process.nextTick(resume_, stream, state3);
      }
    }
    function resume_(stream, state3) {
      debug("resume", state3.reading);
      if (!state3.reading) {
        stream.read(0);
      }
      state3.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state3.flowing && !state3.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state3 = stream._readableState;
      debug("flow", state3.flowing);
      while (state3.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state3 = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state3.decoder && !state3.ended) {
          var chunk = state3.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state3.decoder)
          chunk = state3.decoder.write(chunk);
        if (state3.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state3.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i4 in stream) {
        if (this[i4] === void 0 && typeof stream[i4] === "function") {
          this[i4] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i4);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.flowing;
      },
      set: function set3(state3) {
        if (this._readableState) {
          this._readableState.flowing = state3;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get2() {
        return this._readableState.length;
      }
    });
    function fromList(n3, state3) {
      if (state3.length === 0)
        return null;
      var ret;
      if (state3.objectMode)
        ret = state3.buffer.shift();
      else if (!n3 || n3 >= state3.length) {
        if (state3.decoder)
          ret = state3.buffer.join("");
        else if (state3.buffer.length === 1)
          ret = state3.buffer.first();
        else
          ret = state3.buffer.concat(state3.length);
        state3.buffer.clear();
      } else {
        ret = state3.buffer.consume(n3, state3.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state3 = stream._readableState;
      debug("endReadable", state3.endEmitted);
      if (!state3.endEmitted) {
        state3.ended = true;
        process.nextTick(endReadableNT, state3, stream);
      }
    }
    function endReadableNT(state3, stream) {
      debug("endReadableNT", state3.endEmitted, state3.length);
      if (!state3.endEmitted && state3.length === 0) {
        state3.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state3.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from4 === void 0) {
          from4 = require_from_browser();
        }
        return from4(Readable, iterable, opts);
      };
    }
    function indexOf(xs2, x5) {
      for (var i4 = 0, l4 = xs2.length; i4 < l4; i4++) {
        if (xs2[i4] === x5)
          return i4;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er3, data3) {
      var ts2 = this._transformState;
      ts2.transforming = false;
      var cb = ts2.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts2.writechunk = null;
      ts2.writecb = null;
      if (data3 != null)
        this.push(data3);
      cb(er3);
      var rs2 = this._readableState;
      rs2.reading = false;
      if (rs2.needReadable || rs2.length < rs2.highWaterMark) {
        this._read(rs2.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er3, data3) {
          done(_this, er3, data3);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts2 = this._transformState;
      ts2.writecb = cb;
      ts2.writechunk = chunk;
      ts2.writeencoding = encoding;
      if (!ts2.transforming) {
        var rs2 = this._readableState;
        if (ts2.needTransform || rs2.needReadable || rs2.length < rs2.highWaterMark)
          this._read(rs2.highWaterMark);
      }
    };
    Transform.prototype._read = function(n3) {
      var ts2 = this._transformState;
      if (ts2.writechunk !== null && !ts2.transforming) {
        ts2.transforming = true;
        this._transform(ts2.writechunk, ts2.writeencoding, ts2.afterTransform);
      } else {
        ts2.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er3, data3) {
      if (er3)
        return stream.emit("error", er3);
      if (data3 != null)
        stream.push(data3);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn2) {
      fn2();
    }
    function pipe2(from4, to) {
      return from4.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i4) {
        var reading = i4 < streams.length - 1;
        var writing = i4 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe2);
    }
    module.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    exports.finished = require_end_of_stream();
    exports.pipeline = require_pipeline();
  }
});

// node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/keccak/lib/api/keccak.js"(exports, module) {
    var { Transform } = require_readable_browser();
    module.exports = (KeccakState) => class Keccak extends Transform {
      constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush(callback) {
        let error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      update(data3, encoding) {
        if (!Buffer.isBuffer(data3) && typeof data3 !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data3))
          data3 = Buffer.from(data3, encoding);
        this._state.absorb(data3);
        return this;
      }
      digest(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        let digest2 = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest2 = digest2.toString(encoding);
        this._resetState();
        return digest2;
      }
      // remove result from memory
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      // because sometimes we need hash right now and little later
      _clone() {
        const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/keccak/lib/api/shake.js"(exports, module) {
    var { Transform } = require_readable_browser();
    module.exports = (KeccakState) => class Shake extends Transform {
      constructor(rate, capacity, delimitedSuffix, options) {
        super(options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      _transform(chunk, encoding, callback) {
        let error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      }
      _flush() {
      }
      _read(size2) {
        this.push(this.squeeze(size2));
      }
      update(data3, encoding) {
        if (!Buffer.isBuffer(data3) && typeof data3 !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer.isBuffer(data3))
          data3 = Buffer.from(data3, encoding);
        this._state.absorb(data3);
        return this;
      }
      squeeze(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        let data3 = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data3 = data3.toString(encoding);
        return data3;
      }
      _resetState() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      }
      _clone() {
        const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      }
    };
  }
});

// node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/keccak/lib/api/index.js"(exports, module) {
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      const Keccak = createKeccak(KeccakState);
      const Shake = createShake(KeccakState);
      return function(algorithm, options) {
        const hash3 = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash3) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s3) {
      for (let round = 0; round < 24; ++round) {
        const lo0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
        const hi0 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
        const lo1 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
        const hi1 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
        const lo2 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
        const hi2 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
        const lo3 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
        const hi3 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
        const lo4 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
        const hi4 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
        let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        const t1slo0 = s3[0] ^ lo;
        const t1shi0 = s3[1] ^ hi;
        const t1slo5 = s3[10] ^ lo;
        const t1shi5 = s3[11] ^ hi;
        const t1slo10 = s3[20] ^ lo;
        const t1shi10 = s3[21] ^ hi;
        const t1slo15 = s3[30] ^ lo;
        const t1shi15 = s3[31] ^ hi;
        const t1slo20 = s3[40] ^ lo;
        const t1shi20 = s3[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        const t1slo1 = s3[2] ^ lo;
        const t1shi1 = s3[3] ^ hi;
        const t1slo6 = s3[12] ^ lo;
        const t1shi6 = s3[13] ^ hi;
        const t1slo11 = s3[22] ^ lo;
        const t1shi11 = s3[23] ^ hi;
        const t1slo16 = s3[32] ^ lo;
        const t1shi16 = s3[33] ^ hi;
        const t1slo21 = s3[42] ^ lo;
        const t1shi21 = s3[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        const t1slo2 = s3[4] ^ lo;
        const t1shi2 = s3[5] ^ hi;
        const t1slo7 = s3[14] ^ lo;
        const t1shi7 = s3[15] ^ hi;
        const t1slo12 = s3[24] ^ lo;
        const t1shi12 = s3[25] ^ hi;
        const t1slo17 = s3[34] ^ lo;
        const t1shi17 = s3[35] ^ hi;
        const t1slo22 = s3[44] ^ lo;
        const t1shi22 = s3[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        const t1slo3 = s3[6] ^ lo;
        const t1shi3 = s3[7] ^ hi;
        const t1slo8 = s3[16] ^ lo;
        const t1shi8 = s3[17] ^ hi;
        const t1slo13 = s3[26] ^ lo;
        const t1shi13 = s3[27] ^ hi;
        const t1slo18 = s3[36] ^ lo;
        const t1shi18 = s3[37] ^ hi;
        const t1slo23 = s3[46] ^ lo;
        const t1shi23 = s3[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        const t1slo4 = s3[8] ^ lo;
        const t1shi4 = s3[9] ^ hi;
        const t1slo9 = s3[18] ^ lo;
        const t1shi9 = s3[19] ^ hi;
        const t1slo14 = s3[28] ^ lo;
        const t1shi14 = s3[29] ^ hi;
        const t1slo19 = s3[38] ^ lo;
        const t1shi19 = s3[39] ^ hi;
        const t1slo24 = s3[48] ^ lo;
        const t1shi24 = s3[49] ^ hi;
        const t2slo0 = t1slo0;
        const t2shi0 = t1shi0;
        const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s3[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s3[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s3[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s3[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s3[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s3[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s3[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s3[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s3[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s3[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s3[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s3[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s3[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s3[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s3[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s3[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s3[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s3[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s3[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s3[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s3[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s3[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s3[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s3[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s3[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s3[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s3[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s3[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s3[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s3[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s3[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s3[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s3[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s3[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s3[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s3[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s3[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s3[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s3[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s3[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s3[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s3[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s3[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s3[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s3[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s3[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s3[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s3[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s3[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s3[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s3[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s3[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/keccak/lib/keccak.js"(exports, module) {
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (let i4 = 0; i4 < 50; ++i4)
        this.state[i4] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data3) {
      for (let i4 = 0; i4 < data3.length; ++i4) {
        this.state[~~(this.count / 4)] ^= data3[i4] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length2) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      const output = Buffer.alloc(length2);
      for (let i4 = 0; i4 < length2; ++i4) {
        output[i4] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (let i4 = 0; i4 < 50; ++i4)
        dest.state[i4] = this.state[i4];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/keccak/js.js"(exports, module) {
    module.exports = require_api()(require_keccak2());
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js
var require_util4 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/util.js"(exports, module) {
    var createKeccakHash = require_js();
    var BN3 = require_bn();
    function zeros2(bytes) {
      return Buffer.allocUnsafe(bytes).fill(0);
    }
    function setLength(msg, length2, right) {
      const buf = zeros2(length2);
      msg = toBuffer(msg);
      if (right) {
        if (msg.length < length2) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length2);
      } else {
        if (msg.length < length2) {
          msg.copy(buf, length2 - msg.length);
          return buf;
        }
        return msg.slice(-length2);
      }
    }
    function setLengthRight(msg, length2) {
      return setLength(msg, length2, true);
    }
    function toBuffer(v5) {
      if (!Buffer.isBuffer(v5)) {
        if (Array.isArray(v5)) {
          v5 = Buffer.from(v5);
        } else if (typeof v5 === "string") {
          if (isHexString2(v5)) {
            v5 = Buffer.from(padToEven(stripHexPrefix(v5)), "hex");
          } else {
            v5 = Buffer.from(v5);
          }
        } else if (typeof v5 === "number") {
          v5 = intToBuffer(v5);
        } else if (v5 === null || v5 === void 0) {
          v5 = Buffer.allocUnsafe(0);
        } else if (BN3.isBN(v5)) {
          v5 = v5.toArrayLike(Buffer);
        } else if (v5.toArray) {
          v5 = Buffer.from(v5.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v5;
    }
    function bufferToHex(buf) {
      buf = toBuffer(buf);
      return "0x" + buf.toString("hex");
    }
    function keccak(a4, bits) {
      a4 = toBuffer(a4);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a4).digest();
    }
    function padToEven(str) {
      return str.length % 2 ? "0" + str : str;
    }
    function isHexString2(str) {
      return typeof str === "string" && str.match(/^0x[0-9A-Fa-f]*$/);
    }
    function stripHexPrefix(str) {
      if (typeof str === "string" && str.startsWith("0x")) {
        return str.slice(2);
      }
      return str;
    }
    module.exports = {
      zeros: zeros2,
      setLength,
      setLengthRight,
      isHexString: isHexString2,
      stripHexPrefix,
      toBuffer,
      bufferToHex,
      keccak
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js
var require_abi = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/abi.js"(exports, module) {
    var util = require_util4();
    var BN3 = require_bn();
    function elementaryName(name2) {
      if (name2.startsWith("int[")) {
        return "int256" + name2.slice(3);
      } else if (name2 === "int") {
        return "int256";
      } else if (name2.startsWith("uint[")) {
        return "uint256" + name2.slice(4);
      } else if (name2 === "uint") {
        return "uint256";
      } else if (name2.startsWith("fixed[")) {
        return "fixed128x128" + name2.slice(5);
      } else if (name2 === "fixed") {
        return "fixed128x128";
      } else if (name2.startsWith("ufixed[")) {
        return "ufixed128x128" + name2.slice(6);
      } else if (name2 === "ufixed") {
        return "ufixed128x128";
      }
      return name2;
    }
    function parseTypeN(type2) {
      return parseInt(/^\D+(\d+)$/.exec(type2)[1], 10);
    }
    function parseTypeNxM(type2) {
      var tmp = /^\D+(\d+)x(\d+)$/.exec(type2);
      return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
    }
    function parseTypeArray(type2) {
      var tmp = type2.match(/(.*)\[(.*?)\]$/);
      if (tmp) {
        return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
      }
      return null;
    }
    function parseNumber(arg) {
      var type2 = typeof arg;
      if (type2 === "string") {
        if (util.isHexString(arg)) {
          return new BN3(util.stripHexPrefix(arg), 16);
        } else {
          return new BN3(arg, 10);
        }
      } else if (type2 === "number") {
        return new BN3(arg);
      } else if (arg.toArray) {
        return arg;
      } else {
        throw new Error("Argument is not a number");
      }
    }
    function encodeSingle(type2, arg) {
      var size2, num, ret, i4;
      if (type2 === "address") {
        return encodeSingle("uint160", parseNumber(arg));
      } else if (type2 === "bool") {
        return encodeSingle("uint8", arg ? 1 : 0);
      } else if (type2 === "string") {
        return encodeSingle("bytes", new Buffer(arg, "utf8"));
      } else if (isArray2(type2)) {
        if (typeof arg.length === "undefined") {
          throw new Error("Not an array?");
        }
        size2 = parseTypeArray(type2);
        if (size2 !== "dynamic" && size2 !== 0 && arg.length > size2) {
          throw new Error("Elements exceed array size: " + size2);
        }
        ret = [];
        type2 = type2.slice(0, type2.lastIndexOf("["));
        if (typeof arg === "string") {
          arg = JSON.parse(arg);
        }
        for (i4 in arg) {
          ret.push(encodeSingle(type2, arg[i4]));
        }
        if (size2 === "dynamic") {
          var length2 = encodeSingle("uint256", arg.length);
          ret.unshift(length2);
        }
        return Buffer.concat(ret);
      } else if (type2 === "bytes") {
        arg = new Buffer(arg);
        ret = Buffer.concat([encodeSingle("uint256", arg.length), arg]);
        if (arg.length % 32 !== 0) {
          ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);
        }
        return ret;
      } else if (type2.startsWith("bytes")) {
        size2 = parseTypeN(type2);
        if (size2 < 1 || size2 > 32) {
          throw new Error("Invalid bytes<N> width: " + size2);
        }
        return util.setLengthRight(arg, 32);
      } else if (type2.startsWith("uint")) {
        size2 = parseTypeN(type2);
        if (size2 % 8 || size2 < 8 || size2 > 256) {
          throw new Error("Invalid uint<N> width: " + size2);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size2) {
          throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
        }
        if (num < 0) {
          throw new Error("Supplied uint is negative");
        }
        return num.toArrayLike(Buffer, "be", 32);
      } else if (type2.startsWith("int")) {
        size2 = parseTypeN(type2);
        if (size2 % 8 || size2 < 8 || size2 > 256) {
          throw new Error("Invalid int<N> width: " + size2);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size2) {
          throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
        }
        return num.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (type2.startsWith("ufixed")) {
        size2 = parseTypeNxM(type2);
        num = parseNumber(arg);
        if (num < 0) {
          throw new Error("Supplied ufixed is negative");
        }
        return encodeSingle("uint256", num.mul(new BN3(2).pow(new BN3(size2[1]))));
      } else if (type2.startsWith("fixed")) {
        size2 = parseTypeNxM(type2);
        return encodeSingle("int256", parseNumber(arg).mul(new BN3(2).pow(new BN3(size2[1]))));
      }
      throw new Error("Unsupported or invalid type: " + type2);
    }
    function isDynamic(type2) {
      return type2 === "string" || type2 === "bytes" || parseTypeArray(type2) === "dynamic";
    }
    function isArray2(type2) {
      return type2.lastIndexOf("]") === type2.length - 1;
    }
    function rawEncode(types, values) {
      var output = [];
      var data3 = [];
      var headLength = 32 * types.length;
      for (var i4 in types) {
        var type2 = elementaryName(types[i4]);
        var value = values[i4];
        var cur = encodeSingle(type2, value);
        if (isDynamic(type2)) {
          output.push(encodeSingle("uint256", headLength));
          data3.push(cur);
          headLength += cur.length;
        } else {
          output.push(cur);
        }
      }
      return Buffer.concat(output.concat(data3));
    }
    function solidityPack(types, values) {
      if (types.length !== values.length) {
        throw new Error("Number of types are not matching the values");
      }
      var size2, num;
      var ret = [];
      for (var i4 = 0; i4 < types.length; i4++) {
        var type2 = elementaryName(types[i4]);
        var value = values[i4];
        if (type2 === "bytes") {
          ret.push(value);
        } else if (type2 === "string") {
          ret.push(new Buffer(value, "utf8"));
        } else if (type2 === "bool") {
          ret.push(new Buffer(value ? "01" : "00", "hex"));
        } else if (type2 === "address") {
          ret.push(util.setLength(value, 20));
        } else if (type2.startsWith("bytes")) {
          size2 = parseTypeN(type2);
          if (size2 < 1 || size2 > 32) {
            throw new Error("Invalid bytes<N> width: " + size2);
          }
          ret.push(util.setLengthRight(value, size2));
        } else if (type2.startsWith("uint")) {
          size2 = parseTypeN(type2);
          if (size2 % 8 || size2 < 8 || size2 > 256) {
            throw new Error("Invalid uint<N> width: " + size2);
          }
          num = parseNumber(value);
          if (num.bitLength() > size2) {
            throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
          }
          ret.push(num.toArrayLike(Buffer, "be", size2 / 8));
        } else if (type2.startsWith("int")) {
          size2 = parseTypeN(type2);
          if (size2 % 8 || size2 < 8 || size2 > 256) {
            throw new Error("Invalid int<N> width: " + size2);
          }
          num = parseNumber(value);
          if (num.bitLength() > size2) {
            throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
          }
          ret.push(num.toTwos(size2).toArrayLike(Buffer, "be", size2 / 8));
        } else {
          throw new Error("Unsupported or invalid type: " + type2);
        }
      }
      return Buffer.concat(ret);
    }
    function soliditySHA3(types, values) {
      return util.keccak(solidityPack(types, values));
    }
    module.exports = {
      rawEncode,
      solidityPack,
      soliditySHA3
    };
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js
var require_eth_eip712_util = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/eth-eip712-util/index.js"(exports, module) {
    var util = require_util4();
    var abi = require_abi();
    var TYPED_MESSAGE_SCHEMA = {
      type: "object",
      properties: {
        types: {
          type: "object",
          additionalProperties: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                type: { type: "string" }
              },
              required: ["name", "type"]
            }
          }
        },
        primaryType: { type: "string" },
        domain: { type: "object" },
        message: { type: "object" }
      },
      required: ["types", "primaryType", "domain", "message"]
    };
    var TypedDataUtils = {
      /**
       * Encodes an object by encoding and concatenating each of its members
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of an object
       */
      encodeData(primaryType, data3, types, useV4 = true) {
        const encodedTypes = ["bytes32"];
        const encodedValues = [this.hashType(primaryType, types)];
        if (useV4) {
          const encodeField = (name2, type2, value) => {
            if (types[type2] !== void 0) {
              return ["bytes32", value == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type2, value, types, useV4))];
            }
            if (value === void 0)
              throw new Error(`missing value for field ${name2} of type ${type2}`);
            if (type2 === "bytes") {
              return ["bytes32", util.keccak(value)];
            }
            if (type2 === "string") {
              if (typeof value === "string") {
                value = Buffer.from(value, "utf8");
              }
              return ["bytes32", util.keccak(value)];
            }
            if (type2.lastIndexOf("]") === type2.length - 1) {
              const parsedType = type2.slice(0, type2.lastIndexOf("["));
              const typeValuePairs = value.map((item) => encodeField(name2, parsedType, item));
              return ["bytes32", util.keccak(abi.rawEncode(
                typeValuePairs.map(([type3]) => type3),
                typeValuePairs.map(([, value2]) => value2)
              ))];
            }
            return [type2, value];
          };
          for (const field of types[primaryType]) {
            const [type2, value] = encodeField(field.name, field.type, data3[field.name]);
            encodedTypes.push(type2);
            encodedValues.push(value);
          }
        } else {
          for (const field of types[primaryType]) {
            let value = data3[field.name];
            if (value !== void 0) {
              if (field.type === "bytes") {
                encodedTypes.push("bytes32");
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (field.type === "string") {
                encodedTypes.push("bytes32");
                if (typeof value === "string") {
                  value = Buffer.from(value, "utf8");
                }
                value = util.keccak(value);
                encodedValues.push(value);
              } else if (types[field.type] !== void 0) {
                encodedTypes.push("bytes32");
                value = util.keccak(this.encodeData(field.type, value, types, useV4));
                encodedValues.push(value);
              } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
                throw new Error("Arrays currently unimplemented in encodeData");
              } else {
                encodedTypes.push(field.type);
                encodedValues.push(value);
              }
            }
          }
        }
        return abi.rawEncode(encodedTypes, encodedValues);
      },
      /**
       * Encodes the type of an object by encoding a comma delimited list of its members
       *
       * @param {string} primaryType - Root type to encode
       * @param {Object} types - Type definitions
       * @returns {string} - Encoded representation of the type of an object
       */
      encodeType(primaryType, types) {
        let result = "";
        let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
        deps = [primaryType].concat(deps.sort());
        for (const type2 of deps) {
          const children = types[type2];
          if (!children) {
            throw new Error("No type definition specified: " + type2);
          }
          result += type2 + "(" + types[type2].map(({ name: name2, type: type3 }) => type3 + " " + name2).join(",") + ")";
        }
        return result;
      },
      /**
       * Finds all types within a type defintion object
       *
       * @param {string} primaryType - Root type
       * @param {Object} types - Type definitions
       * @param {Array} results - current set of accumulated types
       * @returns {Array} - Set of all types found in the type definition
       */
      findTypeDependencies(primaryType, types, results = []) {
        primaryType = primaryType.match(/^\w*/)[0];
        if (results.includes(primaryType) || types[primaryType] === void 0) {
          return results;
        }
        results.push(primaryType);
        for (const field of types[primaryType]) {
          for (const dep of this.findTypeDependencies(field.type, types, results)) {
            !results.includes(dep) && results.push(dep);
          }
        }
        return results;
      },
      /**
       * Hashes an object
       *
       * @param {string} primaryType - Root type
       * @param {Object} data - Object to hash
       * @param {Object} types - Type definitions
       * @returns {Buffer} - Hash of an object
       */
      hashStruct(primaryType, data3, types, useV4 = true) {
        return util.keccak(this.encodeData(primaryType, data3, types, useV4));
      },
      /**
       * Hashes the type of an object
       *
       * @param {string} primaryType - Root type to hash
       * @param {Object} types - Type definitions
       * @returns {string} - Hash of an object
       */
      hashType(primaryType, types) {
        return util.keccak(this.encodeType(primaryType, types));
      },
      /**
       * Removes properties from a message object that are not defined per EIP-712
       *
       * @param {Object} data - typed message object
       * @returns {Object} - typed message object with only allowed fields
       */
      sanitizeData(data3) {
        const sanitizedData = {};
        for (const key2 in TYPED_MESSAGE_SCHEMA.properties) {
          data3[key2] && (sanitizedData[key2] = data3[key2]);
        }
        if (sanitizedData.types) {
          sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
        }
        return sanitizedData;
      },
      /**
       * Returns the hash of a typed message as per EIP-712 for signing
       *
       * @param {Object} typedData - Types message data to sign
       * @returns {string} - sha3 hash for signing
       */
      hash(typedData, useV4 = true) {
        const sanitizedData = this.sanitizeData(typedData);
        const parts = [Buffer.from("1901", "hex")];
        parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
        if (sanitizedData.primaryType !== "EIP712Domain") {
          parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
        }
        return util.keccak(Buffer.concat(parts));
      }
    };
    module.exports = {
      TYPED_MESSAGE_SCHEMA,
      TypedDataUtils,
      hashForSignTypedDataLegacy: function(msgParams) {
        return typedSignatureHashLegacy(msgParams.data);
      },
      hashForSignTypedData_v3: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data, false);
      },
      hashForSignTypedData_v4: function(msgParams) {
        return TypedDataUtils.hash(msgParams.data);
      }
    };
    function typedSignatureHashLegacy(typedData) {
      const error = new Error("Expect argument to be non-empty array");
      if (typeof typedData !== "object" || !typedData.length)
        throw error;
      const data3 = typedData.map(function(e3) {
        return e3.type === "bytes" ? util.toBuffer(e3.value) : e3.value;
      });
      const types = typedData.map(function(e3) {
        return e3.type;
      });
      const schema = typedData.map(function(e3) {
        if (!e3.name)
          throw error;
        return e3.type + " " + e3.name;
      });
      return abi.soliditySHA3(
        ["bytes32", "bytes32"],
        [
          abi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
          abi.soliditySHA3(types, data3)
        ]
      );
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js
var require_FilterPolyfill = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/FilterPolyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filterFromParam = exports.FilterPolyfill = void 0;
    var types_1 = require_types3();
    var util_1 = require_util2();
    var TIMEOUT = 5 * 60 * 1e3;
    var JSONRPC_TEMPLATE = {
      jsonrpc: "2.0",
      id: 0
    };
    var FilterPolyfill = class {
      constructor(provider) {
        this.logFilters = /* @__PURE__ */ new Map();
        this.blockFilters = /* @__PURE__ */ new Set();
        this.pendingTransactionFilters = /* @__PURE__ */ new Set();
        this.cursors = /* @__PURE__ */ new Map();
        this.timeouts = /* @__PURE__ */ new Map();
        this.nextFilterId = (0, types_1.IntNumber)(1);
        this.provider = provider;
      }
      async newFilter(param) {
        const filter2 = filterFromParam(param);
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, filter2.fromBlock);
        console.log(`Installing new log filter(${id2}):`, filter2, "initial cursor position:", cursor);
        this.logFilters.set(id2, filter2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      async newBlockFilter() {
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, "latest");
        console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
        this.blockFilters.add(id2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      async newPendingTransactionFilter() {
        const id2 = this.makeFilterId();
        const cursor = await this.setInitialCursorPosition(id2, "latest");
        console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
        this.pendingTransactionFilters.add(id2);
        this.setFilterTimeout(id2);
        return (0, util_1.hexStringFromIntNumber)(id2);
      }
      uninstallFilter(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        console.log(`Uninstalling filter (${id2})`);
        this.deleteFilter(id2);
        return true;
      }
      getFilterChanges(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        if (this.timeouts.has(id2)) {
          this.setFilterTimeout(id2);
        }
        if (this.logFilters.has(id2)) {
          return this.getLogFilterChanges(id2);
        } else if (this.blockFilters.has(id2)) {
          return this.getBlockFilterChanges(id2);
        } else if (this.pendingTransactionFilters.has(id2)) {
          return this.getPendingTransactionFilterChanges(id2);
        }
        return Promise.resolve(filterNotFoundError());
      }
      async getFilterLogs(filterId) {
        const id2 = (0, util_1.intNumberFromHexString)(filterId);
        const filter2 = this.logFilters.get(id2);
        if (!filter2) {
          return filterNotFoundError();
        }
        return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
      }
      makeFilterId() {
        return (0, types_1.IntNumber)(++this.nextFilterId);
      }
      sendAsyncPromise(request) {
        return new Promise((resolve, reject) => {
          this.provider.sendAsync(request, (err, response) => {
            if (err) {
              return reject(err);
            }
            if (Array.isArray(response) || response == null) {
              return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
            }
            resolve(response);
          });
        });
      }
      deleteFilter(id2) {
        console.log(`Deleting filter (${id2})`);
        this.logFilters.delete(id2);
        this.blockFilters.delete(id2);
        this.pendingTransactionFilters.delete(id2);
        this.cursors.delete(id2);
        this.timeouts.delete(id2);
      }
      async getLogFilterChanges(id2) {
        const filter2 = this.logFilters.get(id2);
        const cursorPosition = this.cursors.get(id2);
        if (!cursorPosition || !filter2) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        if (cursorPosition > filter2.toBlock) {
          return emptyResult();
        }
        console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id2}`);
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
          paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
        ] }));
        if (Array.isArray(response.result)) {
          const blocks = response.result.map((log) => (0, util_1.intNumberFromHexString)(log.blockNumber || "0x0"));
          const highestBlock = Math.max(...blocks);
          if (highestBlock && highestBlock > cursorPosition) {
            const newCursorPosition = (0, types_1.IntNumber)(highestBlock + 1);
            console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
            this.cursors.set(id2, newCursorPosition);
          }
        }
        return response;
      }
      async getBlockFilterChanges(id2) {
        const cursorPosition = this.cursors.get(id2);
        if (!cursorPosition) {
          return filterNotFoundError();
        }
        const currentBlockHeight = await this.getCurrentBlockHeight();
        if (cursorPosition > currentBlockHeight) {
          return emptyResult();
        }
        console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id2})`);
        const blocks = (await Promise.all(
          // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
          (0, util_1.range)(cursorPosition, currentBlockHeight + 1).map((i4) => this.getBlockHashByNumber((0, types_1.IntNumber)(i4)))
        )).filter((hash3) => !!hash3);
        const newCursorPosition = (0, types_1.IntNumber)(cursorPosition + blocks.length);
        console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id2, newCursorPosition);
        return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks });
      }
      async getPendingTransactionFilterChanges(_id) {
        return Promise.resolve(emptyResult());
      }
      async setInitialCursorPosition(id2, startBlock) {
        const currentBlockHeight = await this.getCurrentBlockHeight();
        const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
        this.cursors.set(id2, initialCursorPosition);
        return initialCursorPosition;
      }
      setFilterTimeout(id2) {
        const existing = this.timeouts.get(id2);
        if (existing) {
          window.clearTimeout(existing);
        }
        const timeout2 = window.setTimeout(() => {
          console.log(`Filter (${id2}) timed out`);
          this.deleteFilter(id2);
        }, TIMEOUT);
        this.timeouts.set(id2, timeout2);
      }
      async getCurrentBlockHeight() {
        const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
        return (0, util_1.intNumberFromHexString)((0, util_1.ensureHexString)(result));
      }
      async getBlockHashByNumber(blockNumber) {
        const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1.hexStringFromIntNumber)(blockNumber), false] }));
        if (response.result && typeof response.result.hash === "string") {
          return (0, util_1.ensureHexString)(response.result.hash);
        }
        return null;
      }
    };
    exports.FilterPolyfill = FilterPolyfill;
    function filterFromParam(param) {
      return {
        fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
        toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
        addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
        topics: param.topics || []
      };
    }
    exports.filterFromParam = filterFromParam;
    function paramFromFilter(filter2) {
      const param = {
        fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
        toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
        topics: filter2.topics
      };
      if (filter2.addresses !== null) {
        param.address = filter2.addresses;
      }
      return param;
    }
    function intBlockHeightFromHexBlockHeight(value) {
      if (value === void 0 || value === "latest" || value === "pending") {
        return "latest";
      } else if (value === "earliest") {
        return (0, types_1.IntNumber)(0);
      } else if ((0, util_1.isHexString)(value)) {
        return (0, util_1.intNumberFromHexString)(value);
      }
      throw new Error(`Invalid block option: ${String(value)}`);
    }
    function hexBlockHeightFromIntBlockHeight(value) {
      if (value === "latest") {
        return value;
      }
      return (0, util_1.hexStringFromIntNumber)(value);
    }
    function filterNotFoundError() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
    }
    function emptyResult() {
      return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js
var require_JSONRPC = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/JSONRPC.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JSONRPCMethod = void 0;
    var JSONRPCMethod;
    (function(JSONRPCMethod2) {
      JSONRPCMethod2["eth_accounts"] = "eth_accounts";
      JSONRPCMethod2["eth_coinbase"] = "eth_coinbase";
      JSONRPCMethod2["net_version"] = "net_version";
      JSONRPCMethod2["eth_chainId"] = "eth_chainId";
      JSONRPCMethod2["eth_uninstallFilter"] = "eth_uninstallFilter";
      JSONRPCMethod2["eth_requestAccounts"] = "eth_requestAccounts";
      JSONRPCMethod2["eth_sign"] = "eth_sign";
      JSONRPCMethod2["eth_ecRecover"] = "eth_ecRecover";
      JSONRPCMethod2["personal_sign"] = "personal_sign";
      JSONRPCMethod2["personal_ecRecover"] = "personal_ecRecover";
      JSONRPCMethod2["eth_signTransaction"] = "eth_signTransaction";
      JSONRPCMethod2["eth_sendRawTransaction"] = "eth_sendRawTransaction";
      JSONRPCMethod2["eth_sendTransaction"] = "eth_sendTransaction";
      JSONRPCMethod2["eth_signTypedData_v1"] = "eth_signTypedData_v1";
      JSONRPCMethod2["eth_signTypedData_v2"] = "eth_signTypedData_v2";
      JSONRPCMethod2["eth_signTypedData_v3"] = "eth_signTypedData_v3";
      JSONRPCMethod2["eth_signTypedData_v4"] = "eth_signTypedData_v4";
      JSONRPCMethod2["eth_signTypedData"] = "eth_signTypedData";
      JSONRPCMethod2["cbWallet_arbitrary"] = "walletlink_arbitrary";
      JSONRPCMethod2["wallet_addEthereumChain"] = "wallet_addEthereumChain";
      JSONRPCMethod2["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
      JSONRPCMethod2["wallet_watchAsset"] = "wallet_watchAsset";
      JSONRPCMethod2["eth_subscribe"] = "eth_subscribe";
      JSONRPCMethod2["eth_unsubscribe"] = "eth_unsubscribe";
      JSONRPCMethod2["eth_newFilter"] = "eth_newFilter";
      JSONRPCMethod2["eth_newBlockFilter"] = "eth_newBlockFilter";
      JSONRPCMethod2["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
      JSONRPCMethod2["eth_getFilterChanges"] = "eth_getFilterChanges";
      JSONRPCMethod2["eth_getFilterLogs"] = "eth_getFilterLogs";
    })(JSONRPCMethod = exports.JSONRPCMethod || (exports.JSONRPCMethod = {}));
  }
});

// node_modules/json-rpc-random-id/index.js
var require_json_rpc_random_id = __commonJS({
  "node_modules/json-rpc-random-id/index.js"(exports, module) {
    module.exports = IdIterator;
    function IdIterator(opts) {
      opts = opts || {};
      var max3 = opts.max || Number.MAX_SAFE_INTEGER;
      var idCounter = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max3);
      return function createRandomId() {
        idCounter = idCounter % max3;
        return idCounter++;
      };
    }
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn2, opts) => function() {
      const P4 = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i4 = 0; i4 < arguments.length; i4++) {
        args[i4] = arguments[i4];
      }
      return new P4((resolve, reject) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i4 = 1; i4 < arguments.length; i4++) {
                results[i4 - 1] = arguments[i4];
              }
              if (err) {
                results.unshift(err);
                reject(results);
              } else {
                resolve(results);
              }
            } else if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i4 = 0; i4 < arguments.length; i4++) {
                results[i4] = arguments[i4];
              }
              resolve(results);
            } else {
              resolve(result);
            }
          });
        }
        fn2.apply(this, args);
      });
    };
    module.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter2 = (key2) => {
        const match = (pattern2) => typeof pattern2 === "string" ? key2 === pattern2 : pattern2.test(key2);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key2 in obj) {
        const x5 = obj[key2];
        ret[key2] = typeof x5 === "function" && filter2(key2) ? processFn(x5, opts) : x5;
      }
      return ret;
    };
  }
});

// node_modules/eth-block-tracker/dist/BaseBlockTracker.js
var require_BaseBlockTracker = __commonJS({
  "node_modules/eth-block-tracker/dist/BaseBlockTracker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseBlockTracker = void 0;
    var safe_event_emitter_1 = __importDefault3(require_safe_event_emitter());
    var sec = 1e3;
    var calculateSum = (accumulator, currentValue) => accumulator + currentValue;
    var blockTrackerEvents = ["sync", "latest"];
    var BaseBlockTracker = class extends safe_event_emitter_1.default {
      constructor(opts) {
        super();
        this._blockResetDuration = opts.blockResetDuration || 20 * sec;
        this._currentBlock = null;
        this._isRunning = false;
        this._onNewListener = this._onNewListener.bind(this);
        this._onRemoveListener = this._onRemoveListener.bind(this);
        this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
        this._setupInternalEvents();
      }
      async destroy() {
        this._cancelBlockResetTimeout();
        await this._maybeEnd();
        super.removeAllListeners();
      }
      isRunning() {
        return this._isRunning;
      }
      getCurrentBlock() {
        return this._currentBlock;
      }
      async getLatestBlock() {
        if (this._currentBlock) {
          return this._currentBlock;
        }
        const latestBlock = await new Promise((resolve) => this.once("latest", resolve));
        return latestBlock;
      }
      // dont allow module consumer to remove our internal event listeners
      removeAllListeners(eventName) {
        if (eventName) {
          super.removeAllListeners(eventName);
        } else {
          super.removeAllListeners();
        }
        this._setupInternalEvents();
        this._onRemoveListener();
        return this;
      }
      _setupInternalEvents() {
        this.removeListener("newListener", this._onNewListener);
        this.removeListener("removeListener", this._onRemoveListener);
        this.on("newListener", this._onNewListener);
        this.on("removeListener", this._onRemoveListener);
      }
      _onNewListener(eventName) {
        if (blockTrackerEvents.includes(eventName)) {
          this._maybeStart();
        }
      }
      _onRemoveListener() {
        if (this._getBlockTrackerEventCount() > 0) {
          return;
        }
        this._maybeEnd();
      }
      async _maybeStart() {
        if (this._isRunning) {
          return;
        }
        this._isRunning = true;
        this._cancelBlockResetTimeout();
        await this._start();
        this.emit("_started");
      }
      async _maybeEnd() {
        if (!this._isRunning) {
          return;
        }
        this._isRunning = false;
        this._setupBlockResetTimeout();
        await this._end();
        this.emit("_ended");
      }
      _getBlockTrackerEventCount() {
        return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
      }
      _newPotentialLatest(newBlock) {
        const currentBlock = this._currentBlock;
        if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock)) {
          return;
        }
        this._setCurrentBlock(newBlock);
      }
      _setCurrentBlock(newBlock) {
        const oldBlock = this._currentBlock;
        this._currentBlock = newBlock;
        this.emit("latest", newBlock);
        this.emit("sync", { oldBlock, newBlock });
      }
      _setupBlockResetTimeout() {
        this._cancelBlockResetTimeout();
        this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
        if (this._blockResetTimeout.unref) {
          this._blockResetTimeout.unref();
        }
      }
      _cancelBlockResetTimeout() {
        if (this._blockResetTimeout) {
          clearTimeout(this._blockResetTimeout);
        }
      }
      _resetCurrentBlock() {
        this._currentBlock = null;
      }
    };
    exports.BaseBlockTracker = BaseBlockTracker;
    function hexToInt(hexInt) {
      return Number.parseInt(hexInt, 16);
    }
  }
});

// node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  Struct: () => Struct,
  StructError: () => StructError,
  any: () => any,
  array: () => array,
  assert: () => assert2,
  assign: () => assign,
  bigint: () => bigint,
  boolean: () => boolean,
  coerce: () => coerce2,
  create: () => create2,
  date: () => date,
  defaulted: () => defaulted,
  define: () => define2,
  deprecated: () => deprecated,
  dynamic: () => dynamic,
  empty: () => empty2,
  enums: () => enums,
  func: () => func,
  instance: () => instance,
  integer: () => integer,
  intersection: () => intersection,
  is: () => is2,
  lazy: () => lazy,
  literal: () => literal,
  map: () => map,
  mask: () => mask,
  max: () => max,
  min: () => min,
  never: () => never,
  nonempty: () => nonempty,
  nullable: () => nullable,
  number: () => number,
  object: () => object,
  omit: () => omit,
  optional: () => optional,
  partial: () => partial,
  pattern: () => pattern,
  pick: () => pick,
  record: () => record,
  refine: () => refine,
  regexp: () => regexp,
  set: () => set2,
  size: () => size,
  string: () => string2,
  struct: () => struct,
  trimmed: () => trimmed,
  tuple: () => tuple,
  type: () => type,
  union: () => union,
  unknown: () => unknown,
  validate: () => validate5
});
function isIterable(x5) {
  return isObject(x5) && typeof x5[Symbol.iterator] === "function";
}
function isObject(x5) {
  return typeof x5 === "object" && x5 != null;
}
function isPlainObject(x5) {
  if (Object.prototype.toString.call(x5) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(x5);
  return prototype === null || prototype === Object.prototype;
}
function print(value) {
  if (typeof value === "symbol") {
    return value.toString();
  }
  return typeof value === "string" ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
  const { done, value } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct2, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = { message: result };
  }
  const { path, branch } = context;
  const { type: type2 } = struct2;
  const { refinement, message = `Expected a value of type \`${type2}\`${refinement ? ` with refinement \`${refinement}\`` : ""}, but received: \`${print(value)}\`` } = result;
  return {
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch,
    ...result,
    message
  };
}
function* toFailures(result, context, struct2, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r5 of result) {
    const failure = toFailure(r5, context, struct2, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct2, options = {}) {
  const { path = [], branch = [value], coerce: coerce3 = false, mask: mask2 = false } = options;
  const ctx = { path, branch };
  if (coerce3) {
    value = struct2.coercer(value, ctx);
    if (mask2 && struct2.type !== "type" && isObject(struct2.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key2 in value) {
        if (struct2.schema[key2] === void 0) {
          delete value[key2];
        }
      }
    }
  }
  let status = "valid";
  for (const failure of struct2.validator(value, ctx)) {
    failure.explanation = options.message;
    status = "not_valid";
    yield [failure, void 0];
  }
  for (let [k5, v5, s3] of struct2.entries(value, ctx)) {
    const ts2 = run(v5, s3, {
      path: k5 === void 0 ? path : [...path, k5],
      branch: k5 === void 0 ? branch : [...branch, v5],
      coerce: coerce3,
      mask: mask2,
      message: options.message
    });
    for (const t3 of ts2) {
      if (t3[0]) {
        status = t3[0].refinement != null ? "not_refined" : "not_valid";
        yield [t3[0], void 0];
      } else if (coerce3) {
        v5 = t3[1];
        if (k5 === void 0) {
          value = v5;
        } else if (value instanceof Map) {
          value.set(k5, v5);
        } else if (value instanceof Set) {
          value.add(v5);
        } else if (isObject(value)) {
          if (v5 !== void 0 || k5 in value)
            value[k5] = v5;
        }
      }
    }
  }
  if (status !== "not_valid") {
    for (const failure of struct2.refiner(value, ctx)) {
      failure.explanation = options.message;
      status = "not_refined";
      yield [failure, void 0];
    }
  }
  if (status === "valid") {
    yield [void 0, value];
  }
}
function assert2(value, struct2, message) {
  const result = validate5(value, struct2, { message });
  if (result[0]) {
    throw result[0];
  }
}
function create2(value, struct2, message) {
  const result = validate5(value, struct2, { coerce: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct2, message) {
  const result = validate5(value, struct2, { coerce: true, mask: true, message });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is2(value, struct2) {
  const result = validate5(value, struct2);
  return !result[0];
}
function validate5(value, struct2, options = {}) {
  const tuples = run(value, struct2, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t3 of tuples) {
        if (t3[0]) {
          yield t3[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v5 = tuple2[1];
    return [void 0, v5];
  }
}
function assign(...Structs) {
  const isType = Structs[0].type === "type";
  const schemas = Structs.map((s3) => s3.schema);
  const schema = Object.assign({}, ...schemas);
  return isType ? type(schema) : object(schema);
}
function define2(name2, validator) {
  return new Struct({ type: name2, schema: null, validator });
}
function deprecated(struct2, log) {
  return new Struct({
    ...struct2,
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx),
    validator(value, ctx) {
      if (value === void 0) {
        return true;
      } else {
        log(value, ctx);
        return struct2.validator(value, ctx);
      }
    }
  });
}
function dynamic(fn2) {
  return new Struct({
    type: "dynamic",
    schema: null,
    *entries(value, ctx) {
      const struct2 = fn2(value, ctx);
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      const struct2 = fn2(value, ctx);
      return struct2.refiner(value, ctx);
    }
  });
}
function lazy(fn2) {
  let struct2;
  return new Struct({
    type: "lazy",
    schema: null,
    *entries(value, ctx) {
      struct2 ?? (struct2 = fn2());
      yield* struct2.entries(value, ctx);
    },
    validator(value, ctx) {
      struct2 ?? (struct2 = fn2());
      return struct2.validator(value, ctx);
    },
    coercer(value, ctx) {
      struct2 ?? (struct2 = fn2());
      return struct2.coercer(value, ctx);
    },
    refiner(value, ctx) {
      struct2 ?? (struct2 = fn2());
      return struct2.refiner(value, ctx);
    }
  });
}
function omit(struct2, keys2) {
  const { schema } = struct2;
  const subschema = { ...schema };
  for (const key2 of keys2) {
    delete subschema[key2];
  }
  switch (struct2.type) {
    case "type":
      return type(subschema);
    default:
      return object(subschema);
  }
}
function partial(struct2) {
  const schema = struct2 instanceof Struct ? { ...struct2.schema } : { ...struct2 };
  for (const key2 in schema) {
    schema[key2] = optional(schema[key2]);
  }
  return object(schema);
}
function pick(struct2, keys2) {
  const { schema } = struct2;
  const subschema = {};
  for (const key2 of keys2) {
    subschema[key2] = schema[key2];
  }
  return object(subschema);
}
function struct(name2, validator) {
  console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`.");
  return define2(name2, validator);
}
function any() {
  return define2("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i4, v5] of value.entries()) {
          yield [i4, v5, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
    }
  });
}
function bigint() {
  return define2("bigint", (value) => {
    return typeof value === "bigint";
  });
}
function boolean() {
  return define2("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function date() {
  return define2("date", (value) => {
    return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
  });
}
function enums(values) {
  const schema = {};
  const description = values.map((v5) => print(v5)).join();
  for (const key2 of values) {
    schema[key2] = key2;
  }
  return new Struct({
    type: "enums",
    schema,
    validator(value) {
      return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function func() {
  return define2("func", (value) => {
    return typeof value === "function" || `Expected a function, but received: ${print(value)}`;
  });
}
function instance(Class) {
  return define2("instance", (value) => {
    return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
  });
}
function integer() {
  return define2("integer", (value) => {
    return typeof value === "number" && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
  });
}
function intersection(Structs) {
  return new Struct({
    type: "intersection",
    schema: null,
    *entries(value, ctx) {
      for (const S5 of Structs) {
        yield* S5.entries(value, ctx);
      }
    },
    *validator(value, ctx) {
      for (const S5 of Structs) {
        yield* S5.validator(value, ctx);
      }
    },
    *refiner(value, ctx) {
      for (const S5 of Structs) {
        yield* S5.refiner(value, ctx);
      }
    }
  });
}
function literal(constant) {
  const description = print(constant);
  const t3 = typeof constant;
  return new Struct({
    type: "literal",
    schema: t3 === "string" || t3 === "number" || t3 === "boolean" ? constant : null,
    validator(value) {
      return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
    }
  });
}
function map(Key, Value) {
  return new Struct({
    type: "map",
    schema: null,
    *entries(value) {
      if (Key && Value && value instanceof Map) {
        for (const [k5, v5] of value.entries()) {
          yield [k5, k5, Key];
          yield [k5, v5, Value];
        }
      }
    },
    coercer(value) {
      return value instanceof Map ? new Map(value) : value;
    },
    validator(value) {
      return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
    }
  });
}
function never() {
  return define2("never", () => false);
}
function nullable(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === null || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)
  });
}
function number() {
  return define2("number", (value) => {
    return typeof value === "number" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
  });
}
function object(schema) {
  const knowns = schema ? Object.keys(schema) : [];
  const Never = never();
  return new Struct({
    type: "object",
    schema: schema ? schema : null,
    *entries(value) {
      if (schema && isObject(value)) {
        const unknowns = new Set(Object.keys(value));
        for (const key2 of knowns) {
          unknowns.delete(key2);
          yield [key2, value[key2], schema[key2]];
        }
        for (const key2 of unknowns) {
          yield [key2, value[key2], Never];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function optional(struct2) {
  return new Struct({
    ...struct2,
    validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)
  });
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k5 in value) {
          const v5 = value[k5];
          yield [k5, k5, Key];
          yield [k5, v5, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    }
  });
}
function regexp() {
  return define2("regexp", (value) => {
    return value instanceof RegExp;
  });
}
function set2(Element) {
  return new Struct({
    type: "set",
    schema: null,
    *entries(value) {
      if (Element && value instanceof Set) {
        for (const v5 of value) {
          yield [v5, v5, Element];
        }
      }
    },
    coercer(value) {
      return value instanceof Set ? new Set(value) : value;
    },
    validator(value) {
      return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
    }
  });
}
function string2() {
  return define2("string", (value) => {
    return typeof value === "string" || `Expected a string, but received: ${print(value)}`;
  });
}
function tuple(Structs) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length2 = Math.max(Structs.length, value.length);
        for (let i4 = 0; i4 < length2; i4++) {
          yield [i4, value[i4], Structs[i4] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
    }
  });
}
function type(schema) {
  const keys2 = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k5 of keys2) {
          yield [k5, value[k5], schema[k5]];
        }
      }
    },
    validator(value) {
      return isObject(value) || `Expected an object, but received: ${print(value)}`;
    },
    coercer(value) {
      return isObject(value) ? { ...value } : value;
    }
  });
}
function union(Structs) {
  const description = Structs.map((s3) => s3.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    coercer(value) {
      for (const S5 of Structs) {
        const [error, coerced] = S5.validate(value, { coerce: true });
        if (!error) {
          return coerced;
        }
      }
      return value;
    },
    validator(value, ctx) {
      const failures = [];
      for (const S5 of Structs) {
        const [...tuples] = run(value, S5, ctx);
        const [first2] = tuples;
        if (!first2[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return [
        `Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`,
        ...failures
      ];
    }
  });
}
function unknown() {
  return define2("unknown", () => true);
}
function coerce2(struct2, condition, coercer) {
  return new Struct({
    ...struct2,
    coercer: (value, ctx) => {
      return is2(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);
    }
  });
}
function defaulted(struct2, fallback, options = {}) {
  return coerce2(struct2, unknown(), (x5) => {
    const f5 = typeof fallback === "function" ? fallback() : fallback;
    if (x5 === void 0) {
      return f5;
    }
    if (!options.strict && isPlainObject(x5) && isPlainObject(f5)) {
      const ret = { ...x5 };
      let changed = false;
      for (const key2 in f5) {
        if (ret[key2] === void 0) {
          ret[key2] = f5[key2];
          changed = true;
        }
      }
      if (changed) {
        return ret;
      }
    }
    return x5;
  });
}
function trimmed(struct2) {
  return coerce2(struct2, string2(), (x5) => x5.trim());
}
function empty2(struct2) {
  return refine(struct2, "empty", (value) => {
    const size2 = getSize(value);
    return size2 === 0 || `Expected an empty ${struct2.type} but received one with a size of \`${size2}\``;
  });
}
function getSize(value) {
  if (value instanceof Map || value instanceof Set) {
    return value.size;
  } else {
    return value.length;
  }
}
function max(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "max", (value) => {
    return exclusive ? value < threshold : value <= threshold || `Expected a ${struct2.type} less than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function min(struct2, threshold, options = {}) {
  const { exclusive } = options;
  return refine(struct2, "min", (value) => {
    return exclusive ? value > threshold : value >= threshold || `Expected a ${struct2.type} greater than ${exclusive ? "" : "or equal to "}${threshold} but received \`${value}\``;
  });
}
function nonempty(struct2) {
  return refine(struct2, "nonempty", (value) => {
    const size2 = getSize(value);
    return size2 > 0 || `Expected a nonempty ${struct2.type} but received an empty one`;
  });
}
function pattern(struct2, regexp2) {
  return refine(struct2, "pattern", (value) => {
    return regexp2.test(value) || `Expected a ${struct2.type} matching \`/${regexp2.source}/\` but received "${value}"`;
  });
}
function size(struct2, min3, max3 = min3) {
  const expected = `Expected a ${struct2.type}`;
  const of2 = min3 === max3 ? `of \`${min3}\`` : `between \`${min3}\` and \`${max3}\``;
  return refine(struct2, "size", (value) => {
    if (typeof value === "number" || value instanceof Date) {
      return min3 <= value && value <= max3 || `${expected} ${of2} but received \`${value}\``;
    } else if (value instanceof Map || value instanceof Set) {
      const { size: size2 } = value;
      return min3 <= size2 && size2 <= max3 || `${expected} with a size ${of2} but received one with a size of \`${size2}\``;
    } else {
      const { length: length2 } = value;
      return min3 <= length2 && length2 <= max3 || `${expected} with a length ${of2} but received one with a length of \`${length2}\``;
    }
  });
}
function refine(struct2, name2, refiner) {
  return new Struct({
    ...struct2,
    *refiner(value, ctx) {
      yield* struct2.refiner(value, ctx);
      const result = refiner(value, ctx);
      const failures = toFailures(result, ctx, struct2, value);
      for (const failure of failures) {
        yield { ...failure, refinement: name2 };
      }
    }
  });
}
var StructError, Struct;
var init_dist = __esm({
  "node_modules/@metamask/utils/node_modules/superstruct/dist/index.mjs"() {
    StructError = class extends TypeError {
      constructor(failure, failures) {
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const msg = path.length === 0 ? message : `At path: ${path.join(".")} -- ${message}`;
        super(explanation ?? msg);
        if (explanation != null)
          this.cause = msg;
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = () => {
          return cached ?? (cached = [failure, ...failures()]);
        };
      }
    };
    Struct = class {
      constructor(props) {
        const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {
        } } = props;
        this.type = type2;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
          this.validator = (value, context) => {
            const result = validator(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.validator = () => [];
        }
        if (refiner) {
          this.refiner = (value, context) => {
            const result = refiner(value, context);
            return toFailures(result, context, this, value);
          };
        } else {
          this.refiner = () => [];
        }
      }
      /**
       * Assert that a value passes the struct's validation, throwing if it doesn't.
       */
      assert(value, message) {
        return assert2(value, this, message);
      }
      /**
       * Create a value with the struct's coercion logic, then validate it.
       */
      create(value, message) {
        return create2(value, this, message);
      }
      /**
       * Check if a value passes the struct's validation.
       */
      is(value) {
        return is2(value, this);
      }
      /**
       * Mask a value, coercing and validating it, but returning only the subset of
       * properties defined by the struct's schema.
       */
      mask(value, message) {
        return mask(value, this, message);
      }
      /**
       * Validate a value with the struct's validation logic, returning a tuple
       * representing the result.
       *
       * You may optionally pass `true` for the `withCoercion` argument to coerce
       * the value before attempting to validate it. If you do, the result will
       * contain the coerced result when successful.
       */
      validate(value, options = {}) {
        return validate5(value, this, options);
      }
    };
  }
});

// node_modules/@metamask/utils/dist/assert.js
var require_assert = __commonJS({
  "node_modules/@metamask/utils/dist/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    function isErrorWithMessage(error) {
      return typeof error === "object" && error !== null && "message" in error;
    }
    function isConstructable(fn2) {
      var _a2, _b;
      return Boolean(typeof ((_b = (_a2 = fn2 === null || fn2 === void 0 ? void 0 : fn2.prototype) === null || _a2 === void 0 ? void 0 : _a2.constructor) === null || _b === void 0 ? void 0 : _b.name) === "string");
    }
    function getErrorMessage(error) {
      const message = isErrorWithMessage(error) ? error.message : String(error);
      if (message.endsWith(".")) {
        return message.slice(0, -1);
      }
      return message;
    }
    function getError2(ErrorWrapper, message) {
      if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
          message
        });
      }
      return ErrorWrapper({
        message
      });
    }
    var AssertionError = class extends Error {
      constructor(options) {
        super(options.message);
        this.code = "ERR_ASSERTION";
      }
    };
    exports.AssertionError = AssertionError;
    function assert3(value, message = "Assertion failed.", ErrorWrapper = AssertionError) {
      if (!value) {
        if (message instanceof Error) {
          throw message;
        }
        throw getError2(ErrorWrapper, message);
      }
    }
    exports.assert = assert3;
    function assertStruct(value, struct2, errorPrefix = "Assertion failed", ErrorWrapper = AssertionError) {
      try {
        (0, superstruct_1.assert)(value, struct2);
      } catch (error) {
        throw getError2(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
      }
    }
    exports.assertStruct = assertStruct;
    function assertExhaustive(_object) {
      throw new Error("Invalid branch reached. Should be detected during compilation.");
    }
    exports.assertExhaustive = assertExhaustive;
  }
});

// node_modules/@metamask/utils/dist/base64.js
var require_base64 = __commonJS({
  "node_modules/@metamask/utils/dist/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.base64 = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    var base642 = (struct2, options = {}) => {
      var _a2, _b;
      const paddingRequired = (_a2 = options.paddingRequired) !== null && _a2 !== void 0 ? _a2 : false;
      const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : "base64";
      let letters;
      if (characterSet === "base64") {
        letters = String.raw`[A-Za-z0-9+\/]`;
      } else {
        (0, assert_1.assert)(characterSet === "base64url");
        letters = String.raw`[-_A-Za-z0-9]`;
      }
      let re3;
      if (paddingRequired) {
        re3 = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, "u");
      } else {
        re3 = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, "u");
      }
      return (0, superstruct_1.pattern)(struct2, re3);
    };
    exports.base64 = base642;
  }
});

// node_modules/@metamask/utils/dist/hex.js
var require_hex = __commonJS({
  "node_modules/@metamask/utils/dist/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
    exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
    function isHexString2(value) {
      return (0, superstruct_1.is)(value, exports.HexStruct);
    }
    exports.isHexString = isHexString2;
    function isStrictHexString(value) {
      return (0, superstruct_1.is)(value, exports.StrictHexStruct);
    }
    exports.isStrictHexString = isStrictHexString;
    function assertIsHexString(value) {
      (0, assert_1.assert)(isHexString2(value), "Value must be a hexadecimal string.");
    }
    exports.assertIsHexString = assertIsHexString;
    function assertIsStrictHexString(value) {
      (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
    }
    exports.assertIsStrictHexString = assertIsStrictHexString;
    function add0x(hexadecimal) {
      if (hexadecimal.startsWith("0x")) {
        return hexadecimal;
      }
      if (hexadecimal.startsWith("0X")) {
        return `0x${hexadecimal.substring(2)}`;
      }
      return `0x${hexadecimal}`;
    }
    exports.add0x = add0x;
    function remove0x(hexadecimal) {
      if (hexadecimal.startsWith("0x") || hexadecimal.startsWith("0X")) {
        return hexadecimal.substring(2);
      }
      return hexadecimal;
    }
    exports.remove0x = remove0x;
  }
});

// node_modules/@metamask/utils/dist/bytes.js
var require_bytes = __commonJS({
  "node_modules/@metamask/utils/dist/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
    var assert_1 = require_assert();
    var hex_1 = require_hex();
    var HEX_MINIMUM_NUMBER_CHARACTER = 48;
    var HEX_MAXIMUM_NUMBER_CHARACTER = 58;
    var HEX_CHARACTER_OFFSET = 87;
    function getPrecomputedHexValuesBuilder() {
      const lookupTable = [];
      return () => {
        if (lookupTable.length === 0) {
          for (let i4 = 0; i4 < 256; i4++) {
            lookupTable.push(i4.toString(16).padStart(2, "0"));
          }
        }
        return lookupTable;
      };
    }
    var getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
    function isBytes2(value) {
      return value instanceof Uint8Array;
    }
    exports.isBytes = isBytes2;
    function assertIsBytes(value) {
      (0, assert_1.assert)(isBytes2(value), "Value must be a Uint8Array.");
    }
    exports.assertIsBytes = assertIsBytes;
    function bytesToHex(bytes) {
      assertIsBytes(bytes);
      if (bytes.length === 0) {
        return "0x";
      }
      const lookupTable = getPrecomputedHexValues();
      const hexadecimal = new Array(bytes.length);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        hexadecimal[i4] = lookupTable[bytes[i4]];
      }
      return (0, hex_1.add0x)(hexadecimal.join(""));
    }
    exports.bytesToHex = bytesToHex;
    function bytesToBigInt(bytes) {
      assertIsBytes(bytes);
      const hexadecimal = bytesToHex(bytes);
      return BigInt(hexadecimal);
    }
    exports.bytesToBigInt = bytesToBigInt;
    function bytesToSignedBigInt(bytes) {
      assertIsBytes(bytes);
      let value = BigInt(0);
      for (const byte of bytes) {
        value = (value << BigInt(8)) + BigInt(byte);
      }
      return BigInt.asIntN(bytes.length * 8, value);
    }
    exports.bytesToSignedBigInt = bytesToSignedBigInt;
    function bytesToNumber(bytes) {
      assertIsBytes(bytes);
      const bigint2 = bytesToBigInt(bytes);
      (0, assert_1.assert)(bigint2 <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead.");
      return Number(bigint2);
    }
    exports.bytesToNumber = bytesToNumber;
    function bytesToString(bytes) {
      assertIsBytes(bytes);
      return new TextDecoder().decode(bytes);
    }
    exports.bytesToString = bytesToString;
    function hexToBytes(value) {
      var _a2;
      if (((_a2 = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a2 === void 0 ? void 0 : _a2.call(value)) === "0x") {
        return new Uint8Array();
      }
      (0, hex_1.assertIsHexString)(value);
      const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
      const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
      const bytes = new Uint8Array(normalizedValue.length / 2);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        const c1 = normalizedValue.charCodeAt(i4 * 2);
        const c22 = normalizedValue.charCodeAt(i4 * 2 + 1);
        const n1 = c1 - (c1 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
        const n22 = c22 - (c22 < HEX_MAXIMUM_NUMBER_CHARACTER ? HEX_MINIMUM_NUMBER_CHARACTER : HEX_CHARACTER_OFFSET);
        bytes[i4] = n1 * 16 + n22;
      }
      return bytes;
    }
    exports.hexToBytes = hexToBytes;
    function bigIntToBytes(value) {
      (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
      (0, assert_1.assert)(value >= BigInt(0), "Value must be a non-negative bigint.");
      const hexadecimal = value.toString(16);
      return hexToBytes(hexadecimal);
    }
    exports.bigIntToBytes = bigIntToBytes;
    function bigIntFits(value, bytes) {
      (0, assert_1.assert)(bytes > 0);
      const mask2 = value >> BigInt(31);
      return !((~value & mask2) + (value & ~mask2) >> BigInt(bytes * 8 + ~0));
    }
    function signedBigIntToBytes(value, byteLength) {
      (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
      (0, assert_1.assert)(typeof byteLength === "number", "Byte length must be a number.");
      (0, assert_1.assert)(byteLength > 0, "Byte length must be greater than 0.");
      (0, assert_1.assert)(bigIntFits(value, byteLength), "Byte length is too small to represent the given value.");
      let numberValue = value;
      const bytes = new Uint8Array(byteLength);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        bytes[i4] = Number(BigInt.asUintN(8, numberValue));
        numberValue >>= BigInt(8);
      }
      return bytes.reverse();
    }
    exports.signedBigIntToBytes = signedBigIntToBytes;
    function numberToBytes(value) {
      (0, assert_1.assert)(typeof value === "number", "Value must be a number.");
      (0, assert_1.assert)(value >= 0, "Value must be a non-negative number.");
      (0, assert_1.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToBytes` instead.");
      const hexadecimal = value.toString(16);
      return hexToBytes(hexadecimal);
    }
    exports.numberToBytes = numberToBytes;
    function stringToBytes(value) {
      (0, assert_1.assert)(typeof value === "string", "Value must be a string.");
      return new TextEncoder().encode(value);
    }
    exports.stringToBytes = stringToBytes;
    function valueToBytes(value) {
      if (typeof value === "bigint") {
        return bigIntToBytes(value);
      }
      if (typeof value === "number") {
        return numberToBytes(value);
      }
      if (typeof value === "string") {
        if (value.startsWith("0x")) {
          return hexToBytes(value);
        }
        return stringToBytes(value);
      }
      if (isBytes2(value)) {
        return value;
      }
      throw new TypeError(`Unsupported value type: "${typeof value}".`);
    }
    exports.valueToBytes = valueToBytes;
    function concatBytes(values) {
      const normalizedValues = new Array(values.length);
      let byteLength = 0;
      for (let i4 = 0; i4 < values.length; i4++) {
        const value = valueToBytes(values[i4]);
        normalizedValues[i4] = value;
        byteLength += value.length;
      }
      const bytes = new Uint8Array(byteLength);
      for (let i4 = 0, offset = 0; i4 < normalizedValues.length; i4++) {
        bytes.set(normalizedValues[i4], offset);
        offset += normalizedValues[i4].length;
      }
      return bytes;
    }
    exports.concatBytes = concatBytes;
    function createDataView(bytes) {
      if (typeof Buffer !== "undefined" && bytes instanceof Buffer) {
        const buffer2 = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer2);
      }
      return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    }
    exports.createDataView = createDataView;
  }
});

// node_modules/@metamask/utils/dist/checksum.js
var require_checksum = __commonJS({
  "node_modules/@metamask/utils/dist/checksum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChecksumStruct = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var base64_1 = require_base64();
    exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
  }
});

// node_modules/@metamask/utils/dist/coercers.js
var require_coercers = __commonJS({
  "node_modules/@metamask/utils/dist/coercers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    var bytes_1 = require_bytes();
    var hex_1 = require_hex();
    var NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
    var NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
    var BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
    var BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
    var BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
    var HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
    function createNumber(value) {
      try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a number-like value, got "${value}".`);
        }
        throw error;
      }
    }
    exports.createNumber = createNumber;
    function createBigInt(value) {
      try {
        return (0, superstruct_1.create)(value, BigIntCoercer);
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        throw error;
      }
    }
    exports.createBigInt = createBigInt;
    function createBytes(value) {
      if (typeof value === "string" && value.toLowerCase() === "0x") {
        return new Uint8Array();
      }
      try {
        return (0, superstruct_1.create)(value, BytesCoercer);
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        throw error;
      }
    }
    exports.createBytes = createBytes;
    function createHex(value) {
      if (value instanceof Uint8Array && value.length === 0 || typeof value === "string" && value.toLowerCase() === "0x") {
        return "0x";
      }
      try {
        return (0, superstruct_1.create)(value, HexCoercer);
      } catch (error) {
        if (error instanceof superstruct_1.StructError) {
          throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        throw error;
      }
    }
    exports.createHex = createHex;
  }
});

// node_modules/@metamask/utils/dist/collections.js
var require_collections = __commonJS({
  "node_modules/@metamask/utils/dist/collections.js"(exports) {
    "use strict";
    var __classPrivateFieldSet3 = exports && exports.__classPrivateFieldSet || function(receiver, state3, value, kind, f5) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f5)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state3 === "function" ? receiver !== state3 || !f5 : !state3.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state3.set(receiver, value), value;
    };
    var __classPrivateFieldGet3 = exports && exports.__classPrivateFieldGet || function(receiver, state3, kind, f5) {
      if (kind === "a" && !f5)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state3 === "function" ? receiver !== state3 || !f5 : !state3.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state3.get(receiver);
    };
    var _FrozenMap_map;
    var _FrozenSet_set;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FrozenSet = exports.FrozenMap = void 0;
    var FrozenMap = class {
      constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet3(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
      }
      get size() {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").size;
      }
      [(_FrozenMap_map = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f")[Symbol.iterator]();
      }
      entries() {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").entries();
      }
      forEach(callbackfn, thisArg) {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").forEach((value, key2, _map) => callbackfn.call(thisArg, value, key2, this));
      }
      get(key2) {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").get(key2);
      }
      has(key2) {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").has(key2);
      }
      keys() {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").keys();
      }
      values() {
        return __classPrivateFieldGet3(this, _FrozenMap_map, "f").values();
      }
      toString() {
        return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([key2, value]) => `${String(key2)} => ${String(value)}`).join(", ")} ` : ""}}`;
      }
    };
    exports.FrozenMap = FrozenMap;
    var FrozenSet = class {
      constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet3(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
      }
      get size() {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f").size;
      }
      [(_FrozenSet_set = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f")[Symbol.iterator]();
      }
      entries() {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f").entries();
      }
      forEach(callbackfn, thisArg) {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
      }
      has(value) {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f").has(value);
      }
      keys() {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f").keys();
      }
      values() {
        return __classPrivateFieldGet3(this, _FrozenSet_set, "f").values();
      }
      toString() {
        return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((member) => String(member)).join(", ")} ` : ""}}`;
      }
    };
    exports.FrozenSet = FrozenSet;
    Object.freeze(FrozenMap);
    Object.freeze(FrozenMap.prototype);
    Object.freeze(FrozenSet);
    Object.freeze(FrozenSet.prototype);
  }
});

// node_modules/@metamask/utils/dist/misc.js
var require_misc2 = __commonJS({
  "node_modules/@metamask/utils/dist/misc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
    function isNonEmptyArray(value) {
      return Array.isArray(value) && value.length > 0;
    }
    exports.isNonEmptyArray = isNonEmptyArray;
    function isNullOrUndefined(value) {
      return value === null || value === void 0;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isObject3(value) {
      return Boolean(value) && typeof value === "object" && !Array.isArray(value);
    }
    exports.isObject = isObject3;
    var hasProperty = (objectToCheck, name2) => Object.hasOwnProperty.call(objectToCheck, name2);
    exports.hasProperty = hasProperty;
    var JsonSize;
    (function(JsonSize2) {
      JsonSize2[JsonSize2["Null"] = 4] = "Null";
      JsonSize2[JsonSize2["Comma"] = 1] = "Comma";
      JsonSize2[JsonSize2["Wrapper"] = 1] = "Wrapper";
      JsonSize2[JsonSize2["True"] = 4] = "True";
      JsonSize2[JsonSize2["False"] = 5] = "False";
      JsonSize2[JsonSize2["Quote"] = 1] = "Quote";
      JsonSize2[JsonSize2["Colon"] = 1] = "Colon";
      JsonSize2[JsonSize2["Date"] = 24] = "Date";
    })(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
    exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
    function isPlainObject2(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
      } catch (_6) {
        return false;
      }
    }
    exports.isPlainObject = isPlainObject2;
    function isASCII(character) {
      return character.charCodeAt(0) <= 127;
    }
    exports.isASCII = isASCII;
    function calculateStringSize(value) {
      var _a2;
      const size2 = value.split("").reduce((total, character) => {
        if (isASCII(character)) {
          return total + 1;
        }
        return total + 2;
      }, 0);
      return size2 + ((_a2 = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a2 !== void 0 ? _a2 : []).length;
    }
    exports.calculateStringSize = calculateStringSize;
    function calculateNumberSize(value) {
      return value.toString().length;
    }
    exports.calculateNumberSize = calculateNumberSize;
  }
});

// node_modules/@metamask/utils/dist/json.js
var require_json = __commonJS({
  "node_modules/@metamask/utils/dist/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    var misc_1 = require_misc2();
    exports.JsonStruct = (0, superstruct_1.define)("Json", (value) => {
      const [isValid] = validateJsonAndGetSize(value, true);
      if (!isValid) {
        return "Expected a valid JSON-serializable value";
      }
      return true;
    });
    function isValidJson(value) {
      return (0, superstruct_1.is)(value, exports.JsonStruct);
    }
    exports.isValidJson = isValidJson;
    exports.jsonrpc2 = "2.0";
    exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
    exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
    exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
      code: (0, superstruct_1.integer)(),
      message: (0, superstruct_1.string)(),
      data: (0, superstruct_1.optional)(exports.JsonStruct),
      stack: (0, superstruct_1.optional)((0, superstruct_1.string)())
    });
    exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
    exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
      id: exports.JsonRpcIdStruct,
      jsonrpc: exports.JsonRpcVersionStruct,
      method: (0, superstruct_1.string)(),
      params: exports.JsonRpcParamsStruct
    });
    exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ["id"]);
    function isJsonRpcNotification(value) {
      return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
    }
    exports.isJsonRpcNotification = isJsonRpcNotification;
    function assertIsJsonRpcNotification(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", ErrorWrapper);
    }
    exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
    function isJsonRpcRequest2(value) {
      return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
    }
    exports.isJsonRpcRequest = isJsonRpcRequest2;
    function assertIsJsonRpcRequest(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, "Invalid JSON-RPC request", ErrorWrapper);
    }
    exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
    exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
      id: exports.JsonRpcIdStruct,
      jsonrpc: exports.JsonRpcVersionStruct,
      result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
      error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct)
    });
    exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
      id: exports.JsonRpcIdStruct,
      jsonrpc: exports.JsonRpcVersionStruct,
      result: exports.JsonStruct
    });
    exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
      id: exports.JsonRpcIdStruct,
      jsonrpc: exports.JsonRpcVersionStruct,
      error: exports.JsonRpcErrorStruct
    });
    exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
      exports.JsonRpcSuccessStruct,
      exports.JsonRpcFailureStruct
    ]);
    function isPendingJsonRpcResponse(response) {
      return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
    }
    exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
    function assertIsPendingJsonRpcResponse(response, ErrorWrapper) {
      (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", ErrorWrapper);
    }
    exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
    function isJsonRpcResponse2(response) {
      return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
    }
    exports.isJsonRpcResponse = isJsonRpcResponse2;
    function assertIsJsonRpcResponse(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, "Invalid JSON-RPC response", ErrorWrapper);
    }
    exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
    function isJsonRpcSuccess(value) {
      return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
    }
    exports.isJsonRpcSuccess = isJsonRpcSuccess;
    function assertIsJsonRpcSuccess(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", ErrorWrapper);
    }
    exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
    function isJsonRpcFailure(value) {
      return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
    }
    exports.isJsonRpcFailure = isJsonRpcFailure;
    function assertIsJsonRpcFailure(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", ErrorWrapper);
    }
    exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
    function isJsonRpcError2(value) {
      return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
    }
    exports.isJsonRpcError = isJsonRpcError2;
    function assertIsJsonRpcError(value, ErrorWrapper) {
      (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, "Invalid JSON-RPC error", ErrorWrapper);
    }
    exports.assertIsJsonRpcError = assertIsJsonRpcError;
    function getJsonRpcIdValidator(options) {
      const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
      const isValidJsonRpcId = (id2) => {
        return Boolean(typeof id2 === "number" && (permitFractions || Number.isInteger(id2)) || typeof id2 === "string" && (permitEmptyString || id2.length > 0) || permitNull && id2 === null);
      };
      return isValidJsonRpcId;
    }
    exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
    function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
      const seenObjects = /* @__PURE__ */ new Set();
      function getJsonSerializableInfo(value, skipSizing) {
        if (value === void 0) {
          return [false, 0];
        } else if (value === null) {
          return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        const typeOfValue = typeof value;
        try {
          if (typeOfValue === "function") {
            return [false, 0];
          } else if (typeOfValue === "string" || value instanceof String) {
            return [
              true,
              skipSizing ? 0 : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2
            ];
          } else if (typeOfValue === "boolean" || value instanceof Boolean) {
            if (skipSizing) {
              return [true, 0];
            }
            return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
          } else if (typeOfValue === "number" || value instanceof Number) {
            if (skipSizing) {
              return [true, 0];
            }
            return [true, (0, misc_1.calculateNumberSize)(value)];
          } else if (value instanceof Date) {
            if (skipSizing) {
              return [true, 0];
            }
            return [
              true,
              // Note: Invalid dates will serialize to null
              isNaN(value.getDate()) ? misc_1.JsonSize.Null : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2
            ];
          }
        } catch (_6) {
          return [false, 0];
        }
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
          return [false, 0];
        }
        if (seenObjects.has(value)) {
          return [false, 0];
        }
        seenObjects.add(value);
        try {
          return [
            true,
            Object.entries(value).reduce(
              (sum, [key2, nestedValue], idx, arr) => {
                let [valid, size2] = getJsonSerializableInfo(nestedValue, skipSizing);
                if (!valid) {
                  throw new Error("JSON validation did not pass. Validation process stopped.");
                }
                seenObjects.delete(value);
                if (skipSizing) {
                  return 0;
                }
                const keySize = Array.isArray(value) ? 0 : key2.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                return sum + keySize + size2 + separator;
              },
              // Starts at 2 because the serialized JSON string data (plain text)
              // will minimally contain {}/[]
              skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2
            )
          ];
        } catch (_6) {
          return [false, 0];
        }
      }
      return getJsonSerializableInfo(jsObject, skipSizingProcess);
    }
    exports.validateJsonAndGetSize = validateJsonAndGetSize;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s3 = 1e3;
    var m5 = s3 * 60;
    var h6 = m5 * 60;
    var d4 = h6 * 24;
    var w5 = d4 * 7;
    var y7 = d4 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse3(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n3 = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y7;
        case "weeks":
        case "week":
        case "w":
          return n3 * w5;
        case "days":
        case "day":
        case "d":
          return n3 * d4;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h6;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m5;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s3;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d4) {
        return Math.round(ms2 / d4) + "d";
      }
      if (msAbs >= h6) {
        return Math.round(ms2 / h6) + "h";
      }
      if (msAbs >= m5) {
        return Math.round(ms2 / m5) + "m";
      }
      if (msAbs >= s3) {
        return Math.round(ms2 / s3) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d4) {
        return plural(ms2, msAbs, d4, "day");
      }
      if (msAbs >= h6) {
        return plural(ms2, msAbs, h6, "hour");
      }
      if (msAbs >= m5) {
        return plural(ms2, msAbs, m5, "minute");
      }
      if (msAbs >= s3) {
        return plural(ms2, msAbs, s3, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n3, name2) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms2 / n3) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce3;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key2) => {
        createDebug[key2] = env[key2];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash3 = 0;
        for (let i4 = 0; i4 < namespace.length; i4++) {
          hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i4);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v5) => {
            enableOverride = v5;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i4;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i4 = 0; i4 < len; i4++) {
          if (!split[i4]) {
            continue;
          }
          namespaces = split[i4].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i4;
        let len;
        for (i4 = 0, len = createDebug.skips.length; i4 < len; i4++) {
          if (createDebug.skips[i4].test(name2)) {
            return false;
          }
        }
        for (i4 = 0, len = createDebug.names.length; i4 < len; i4++) {
          if (createDebug.names[i4].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp2) {
        return regexp2.toString().substring(2, regexp2.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce3(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser5 = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c5 = "color: " + this.color;
      args.splice(1, 0, c5, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c5);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r5;
      try {
        r5 = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r5 && typeof process !== "undefined" && "env" in process) {
        r5 = process.env.DEBUG;
      }
      return r5;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common3()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v5) {
      try {
        return JSON.stringify(v5);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/@metamask/utils/dist/logging.js
var require_logging = __commonJS({
  "node_modules/@metamask/utils/dist/logging.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createModuleLogger = exports.createProjectLogger = void 0;
    var debug_1 = __importDefault3(require_browser5());
    var globalLogger = (0, debug_1.default)("metamask");
    function createProjectLogger(projectName) {
      return globalLogger.extend(projectName);
    }
    exports.createProjectLogger = createProjectLogger;
    function createModuleLogger(projectLogger, moduleName) {
      return projectLogger.extend(moduleName);
    }
    exports.createModuleLogger = createModuleLogger;
  }
});

// node_modules/@metamask/utils/dist/number.js
var require_number = __commonJS({
  "node_modules/@metamask/utils/dist/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
    var assert_1 = require_assert();
    var hex_1 = require_hex();
    var numberToHex = (value) => {
      (0, assert_1.assert)(typeof value === "number", "Value must be a number.");
      (0, assert_1.assert)(value >= 0, "Value must be a non-negative number.");
      (0, assert_1.assert)(Number.isSafeInteger(value), "Value is not a safe integer. Use `bigIntToHex` instead.");
      return (0, hex_1.add0x)(value.toString(16));
    };
    exports.numberToHex = numberToHex;
    var bigIntToHex = (value) => {
      (0, assert_1.assert)(typeof value === "bigint", "Value must be a bigint.");
      (0, assert_1.assert)(value >= 0, "Value must be a non-negative bigint.");
      return (0, hex_1.add0x)(value.toString(16));
    };
    exports.bigIntToHex = bigIntToHex;
    var hexToNumber = (value) => {
      (0, hex_1.assertIsHexString)(value);
      const numberValue = parseInt(value, 16);
      (0, assert_1.assert)(Number.isSafeInteger(numberValue), "Value is not a safe integer. Use `hexToBigInt` instead.");
      return numberValue;
    };
    exports.hexToNumber = hexToNumber;
    var hexToBigInt = (value) => {
      (0, hex_1.assertIsHexString)(value);
      return BigInt((0, hex_1.add0x)(value));
    };
    exports.hexToBigInt = hexToBigInt;
  }
});

// node_modules/@metamask/utils/dist/opaque.js
var require_opaque = __commonJS({
  "node_modules/@metamask/utils/dist/opaque.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@metamask/utils/dist/time.js
var require_time2 = __commonJS({
  "node_modules/@metamask/utils/dist/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
    var Duration;
    (function(Duration2) {
      Duration2[Duration2["Millisecond"] = 1] = "Millisecond";
      Duration2[Duration2["Second"] = 1e3] = "Second";
      Duration2[Duration2["Minute"] = 6e4] = "Minute";
      Duration2[Duration2["Hour"] = 36e5] = "Hour";
      Duration2[Duration2["Day"] = 864e5] = "Day";
      Duration2[Duration2["Week"] = 6048e5] = "Week";
      Duration2[Duration2["Year"] = 31536e6] = "Year";
    })(Duration = exports.Duration || (exports.Duration = {}));
    var isNonNegativeInteger = (number2) => Number.isInteger(number2) && number2 >= 0;
    var assertIsNonNegativeInteger = (number2, name2) => {
      if (!isNonNegativeInteger(number2)) {
        throw new Error(`"${name2}" must be a non-negative integer. Received: "${number2}".`);
      }
    };
    function inMilliseconds(count2, duration) {
      assertIsNonNegativeInteger(count2, "count");
      return count2 * duration;
    }
    exports.inMilliseconds = inMilliseconds;
    function timeSince(timestamp2) {
      assertIsNonNegativeInteger(timestamp2, "timestamp");
      return Date.now() - timestamp2;
    }
    exports.timeSince = timeSince;
  }
});

// node_modules/semver/internal/constants.js
var require_constants5 = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants5();
    var debug = require_debug();
    exports = module.exports = {};
    var re3 = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src2 = exports.src = [];
    var t3 = exports.t = {};
    var R3 = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max3] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max3}}`).split(`${token}+`).join(`${token}{1,${max3}}`);
      }
      return value;
    };
    var createToken = (name2, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R3++;
      debug(name2, index, value);
      t3[name2] = index;
      src2[index] = value;
      re3[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src2[t3.NUMERICIDENTIFIER]})\\.(${src2[t3.NUMERICIDENTIFIER]})\\.(${src2[t3.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src2[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t3.NUMERICIDENTIFIERLOOSE]})\\.(${src2[t3.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src2[t3.NUMERICIDENTIFIER]}|${src2[t3.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src2[t3.NUMERICIDENTIFIERLOOSE]}|${src2[t3.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src2[t3.PRERELEASEIDENTIFIER]}(?:\\.${src2[t3.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src2[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src2[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src2[t3.BUILDIDENTIFIER]}(?:\\.${src2[t3.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src2[t3.MAINVERSION]}${src2[t3.PRERELEASE]}?${src2[t3.BUILD]}?`);
    createToken("FULL", `^${src2[t3.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src2[t3.MAINVERSIONLOOSE]}${src2[t3.PRERELEASELOOSE]}?${src2[t3.BUILD]}?`);
    createToken("LOOSE", `^${src2[t3.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src2[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src2[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src2[t3.XRANGEIDENTIFIER]})(?:\\.(${src2[t3.XRANGEIDENTIFIER]})(?:\\.(${src2[t3.XRANGEIDENTIFIER]})(?:${src2[t3.PRERELEASE]})?${src2[t3.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src2[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t3.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src2[t3.XRANGEIDENTIFIERLOOSE]})(?:${src2[t3.PRERELEASELOOSE]})?${src2[t3.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src2[t3.GTLT]}\\s*${src2[t3.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src2[t3.GTLT]}\\s*${src2[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src2[t3.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src2[t3.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src2[t3.LONETILDE]}${src2[t3.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src2[t3.LONETILDE]}${src2[t3.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src2[t3.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src2[t3.LONECARET]}${src2[t3.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src2[t3.LONECARET]}${src2[t3.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src2[t3.GTLT]}\\s*(${src2[t3.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src2[t3.GTLT]}\\s*(${src2[t3.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src2[t3.GTLT]}\\s*(${src2[t3.LOOSEPLAIN]}|${src2[t3.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src2[t3.XRANGEPLAIN]})\\s+-\\s+(${src2[t3.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src2[t3.XRANGEPLAINLOOSE]})\\s+-\\s+(${src2[t3.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a4, b6) => {
      const anum = numeric.test(a4);
      const bnum = numeric.test(b6);
      if (anum && bnum) {
        a4 = +a4;
        b6 = +b6;
      }
      return a4 === b6 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a4 < b6 ? -1 : 1;
    };
    var rcompareIdentifiers = (a4, b6) => compareIdentifiers(b6, a4);
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    var debug = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants5();
    var { safeRe: re3, t: t3 } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version28, options) {
        options = parseOptions(options);
        if (version28 instanceof _SemVer) {
          if (version28.loose === !!options.loose && version28.includePrerelease === !!options.includePrerelease) {
            return version28;
          } else {
            version28 = version28.version;
          }
        } else if (typeof version28 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version28}".`);
        }
        if (version28.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug("SemVer", version28, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m5 = version28.trim().match(options.loose ? re3[t3.LOOSE] : re3[t3.FULL]);
        if (!m5) {
          throw new TypeError(`Invalid Version: ${version28}`);
        }
        this.raw = version28;
        this.major = +m5[1];
        this.minor = +m5[2];
        this.patch = +m5[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m5[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m5[4].split(".").map((id2) => {
            if (/^[0-9]+$/.test(id2)) {
              const num = +id2;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id2;
          });
        }
        this.build = m5[5] ? m5[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i4 = 0;
        do {
          const a4 = this.prerelease[i4];
          const b6 = other.prerelease[i4];
          debug("prerelease compare", i4, a4, b6);
          if (a4 === void 0 && b6 === void 0) {
            return 0;
          } else if (b6 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b6) {
            continue;
          } else {
            return compareIdentifiers(a4, b6);
          }
        } while (++i4);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i4 = 0;
        do {
          const a4 = this.build[i4];
          const b6 = other.build[i4];
          debug("prerelease compare", i4, a4, b6);
          if (a4 === void 0 && b6 === void 0) {
            return 0;
          } else if (b6 === void 0) {
            return 1;
          } else if (a4 === void 0) {
            return -1;
          } else if (a4 === b6) {
            continue;
          } else {
            return compareIdentifiers(a4, b6);
          }
        } while (++i4);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base4 = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base4];
            } else {
              let i4 = this.prerelease.length;
              while (--i4 >= 0) {
                if (typeof this.prerelease[i4] === "number") {
                  this.prerelease[i4]++;
                  i4 = -2;
                }
              }
              if (i4 === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base4);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base4];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    var SemVer = require_semver();
    var parse3 = (version28, options, throwErrors = false) => {
      if (version28 instanceof SemVer) {
        return version28;
      }
      try {
        return new SemVer(version28, options);
      } catch (er3) {
        if (!throwErrors) {
          return null;
        }
        throw er3;
      }
    };
    module.exports = parse3;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    var parse3 = require_parse2();
    var valid = (version28, options) => {
      const v5 = parse3(version28, options);
      return v5 ? v5.version : null;
    };
    module.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    var parse3 = require_parse2();
    var clean = (version28, options) => {
      const s3 = parse3(version28.trim().replace(/^[=v]+/, ""), options);
      return s3 ? s3.version : null;
    };
    module.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    var SemVer = require_semver();
    var inc = (version28, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version28 instanceof SemVer ? version28.version : version28,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er3) {
        return null;
      }
    };
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    var parse3 = require_parse2();
    var diff = (version1, version28) => {
      const v1 = parse3(version1, null, true);
      const v22 = parse3(version28, null, true);
      const comparison = v1.compare(v22);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v22;
      const lowVersion = v1Higher ? v22 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v22.major) {
        return prefix + "major";
      }
      if (v1.minor !== v22.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v22.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    var SemVer = require_semver();
    var major = (a4, loose) => new SemVer(a4, loose).major;
    module.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    var SemVer = require_semver();
    var minor = (a4, loose) => new SemVer(a4, loose).minor;
    module.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    var SemVer = require_semver();
    var patch = (a4, loose) => new SemVer(a4, loose).patch;
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    var parse3 = require_parse2();
    var prerelease = (version28, options) => {
      const parsed = parse3(version28, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    var SemVer = require_semver();
    var compare2 = (a4, b6, loose) => new SemVer(a4, loose).compare(new SemVer(b6, loose));
    module.exports = compare2;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    var compare2 = require_compare();
    var rcompare = (a4, b6, loose) => compare2(b6, a4, loose);
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    var compare2 = require_compare();
    var compareLoose = (a4, b6) => compare2(a4, b6, true);
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    var SemVer = require_semver();
    var compareBuild = (a4, b6, loose) => {
      const versionA = new SemVer(a4, loose);
      const versionB = new SemVer(b6, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a4, b6) => compareBuild(a4, b6, loose));
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a4, b6) => compareBuild(b6, a4, loose));
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    var compare2 = require_compare();
    var gt3 = (a4, b6, loose) => compare2(a4, b6, loose) > 0;
    module.exports = gt3;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    var compare2 = require_compare();
    var lt3 = (a4, b6, loose) => compare2(a4, b6, loose) < 0;
    module.exports = lt3;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    var compare2 = require_compare();
    var eq4 = (a4, b6, loose) => compare2(a4, b6, loose) === 0;
    module.exports = eq4;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    var compare2 = require_compare();
    var neq = (a4, b6, loose) => compare2(a4, b6, loose) !== 0;
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    var compare2 = require_compare();
    var gte = (a4, b6, loose) => compare2(a4, b6, loose) >= 0;
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    var compare2 = require_compare();
    var lte = (a4, b6, loose) => compare2(a4, b6, loose) <= 0;
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    var eq4 = require_eq();
    var neq = require_neq();
    var gt3 = require_gt();
    var gte = require_gte();
    var lt3 = require_lt();
    var lte = require_lte();
    var cmp = (a4, op, b6, loose) => {
      switch (op) {
        case "===":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b6 === "object") {
            b6 = b6.version;
          }
          return a4 === b6;
        case "!==":
          if (typeof a4 === "object") {
            a4 = a4.version;
          }
          if (typeof b6 === "object") {
            b6 = b6.version;
          }
          return a4 !== b6;
        case "":
        case "=":
        case "==":
          return eq4(a4, b6, loose);
        case "!=":
          return neq(a4, b6, loose);
        case ">":
          return gt3(a4, b6, loose);
        case ">=":
          return gte(a4, b6, loose);
        case "<":
          return lt3(a4, b6, loose);
        case "<=":
          return lte(a4, b6, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    var SemVer = require_semver();
    var parse3 = require_parse2();
    var { safeRe: re3, t: t3 } = require_re();
    var coerce3 = (version28, options) => {
      if (version28 instanceof SemVer) {
        return version28;
      }
      if (typeof version28 === "number") {
        version28 = String(version28);
      }
      if (typeof version28 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version28.match(re3[t3.COERCE]);
      } else {
        let next;
        while ((next = re3[t3.COERCERTL].exec(version28)) && (!match || match.index + match[0].length !== version28.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re3[t3.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re3[t3.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse3(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module.exports = coerce3;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i4 = 0, l4 = arguments.length; i4 < l4; i4++) {
          self2.push(arguments[i4]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i4 = 0, l4 = arguments.length; i4 < l4; i4++) {
        push(this, arguments[i4]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i4 = 0, l4 = arguments.length; i4 < l4; i4++) {
        unshift(this, arguments[i4]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i4 = 0; walker !== null; i4++) {
        fn2.call(thisp, walker.value, i4, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn2, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i4 = this.length - 1; walker !== null; i4--) {
        fn2.call(thisp, walker.value, i4, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n3) {
      for (var i4 = 0, walker = this.head; walker !== null && i4 < n3; i4++) {
        walker = walker.next;
      }
      if (i4 === n3 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n3) {
      for (var i4 = 0, walker = this.tail; walker !== null && i4 < n3; i4++) {
        walker = walker.prev;
      }
      if (i4 === n3 && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn2, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn2.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn2, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i4 = 0; walker !== null; i4++) {
        acc = fn2(acc, walker.value, i4);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn2, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i4 = this.length - 1; walker !== null; i4--) {
        acc = fn2(acc, walker.value, i4);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i4 = 0, walker = this.head; walker !== null; i4++) {
        arr[i4] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i4 = 0, walker = this.tail; walker !== null; i4++) {
        arr[i4] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from4, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from4 = from4 || 0;
      if (from4 < 0) {
        from4 += this.length;
      }
      var ret = new Yallist();
      if (to < from4 || to < 0) {
        return ret;
      }
      if (from4 < 0) {
        from4 = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i4 = 0, walker = this.head; walker !== null && i4 < from4; i4++) {
        walker = walker.next;
      }
      for (; walker !== null && i4 < to; i4++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from4, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from4 = from4 || 0;
      if (from4 < 0) {
        from4 += this.length;
      }
      var ret = new Yallist();
      if (to < from4 || to < 0) {
        return ret;
      }
      if (from4 < 0) {
        from4 = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i4 = this.length, walker = this.tail; walker !== null && i4 > to; i4--) {
        walker = walker.prev;
      }
      for (; walker !== null && i4 > from4; i4--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i4 = 0, walker = this.head; walker !== null && i4 < start; i4++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i4 = 0; walker && i4 < deleteCount; i4++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i4 = 0; i4 < nodes.length; i4++) {
        walker = insert(this, walker, nodes[i4]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p6 = walker.prev;
        walker.prev = walker.next;
        walker.next = p6;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er3) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max3 = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn2, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn2, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn2, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k5) => k5.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k5) => k5.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h6) => h6);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key2, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now2 = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key2);
        if (this[CACHE].has(key2)) {
          if (len > this[MAX]) {
            del2(this, this[CACHE].get(key2));
            return false;
          }
          const node = this[CACHE].get(key2);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key2, item.value);
          }
          item.now = now2;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key2);
          trim(this);
          return true;
        }
        const hit = new Entry(key2, value, len, now2, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key2, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key2, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key2) {
        if (!this[CACHE].has(key2))
          return false;
        const hit = this[CACHE].get(key2).value;
        return !isStale(this, hit);
      }
      get(key2) {
        return get2(this, key2, true);
      }
      peek(key2) {
        return get2(this, key2, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del2(this, node);
        return node.value;
      }
      del(key2) {
        del2(this, this[CACHE].get(key2));
      }
      load(arr) {
        this.reset();
        const now2 = Date.now();
        for (let l4 = arr.length - 1; l4 >= 0; l4--) {
          const hit = arr[l4];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now2;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key2) => get2(this, key2, false));
      }
    };
    var get2 = (self2, key2, doUse) => {
      const node = self2[CACHE].get(key2);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del2(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del2(self2, walker);
          walker = prev;
        }
      }
    };
    var del2 = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key2, value, length2, now2, maxAge) {
        this.key = key2;
        this.value = value;
        this.length = length2;
        this.now = now2;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn2, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del2(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn2.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    var Range = class _Range {
      constructor(range2, options) {
        options = parseOptions(options);
        if (range2 instanceof _Range) {
          if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
            return range2;
          } else {
            return new _Range(range2.raw, options);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range2.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r5) => this.parseRange(r5.trim())).filter((c5) => c5.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first2 = this.set[0];
          this.set = this.set.filter((c5) => !isNullSet(c5[0]));
          if (this.set.length === 0) {
            this.set = [first2];
          } else if (this.set.length > 1) {
            for (const c5 of this.set) {
              if (c5.length === 1 && isAny(c5[0])) {
                this.set = [c5];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range2;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr3 = loose ? re3[t3.HYPHENRANGELOOSE] : re3[t3.HYPHENRANGE];
        range2 = range2.replace(hr3, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re3[t3.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re3[t3.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range2);
        range2 = range2.replace(re3[t3.CARETTRIM], caretTrimReplace);
        debug("caret trim", range2);
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re3[t3.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range2, options) {
        if (!(range2 instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version28) {
        if (!version28) {
          return false;
        }
        if (typeof version28 === "string") {
          try {
            version28 = new SemVer(version28, this.options);
          } catch (er3) {
            return false;
          }
        }
        for (let i4 = 0; i4 < this.set.length; i4++) {
          if (testSet(this.set[i4], version28, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      safeRe: re3,
      t: t3,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants5();
    var isNullSet = (c5) => c5.value === "<0.0.0-0";
    var isAny = (c5) => c5.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    };
    var isX = (id2) => !id2 || id2.toLowerCase() === "x" || id2 === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c5) => replaceTilde(c5, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r5 = options.loose ? re3[t3.TILDELOOSE] : re3[t3.TILDE];
      return comp.replace(r5, (_6, M5, m5, p6, pr) => {
        debug("tilde", comp, _6, M5, m5, p6, pr);
        let ret;
        if (isX(M5)) {
          ret = "";
        } else if (isX(m5)) {
          ret = `>=${M5}.0.0 <${+M5 + 1}.0.0-0`;
        } else if (isX(p6)) {
          ret = `>=${M5}.${m5}.0 <${M5}.${+m5 + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M5}.${m5}.${p6}-${pr} <${M5}.${+m5 + 1}.0-0`;
        } else {
          ret = `>=${M5}.${m5}.${p6} <${M5}.${+m5 + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c5) => replaceCaret(c5, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug("caret", comp, options);
      const r5 = options.loose ? re3[t3.CARETLOOSE] : re3[t3.CARET];
      const z5 = options.includePrerelease ? "-0" : "";
      return comp.replace(r5, (_6, M5, m5, p6, pr) => {
        debug("caret", comp, _6, M5, m5, p6, pr);
        let ret;
        if (isX(M5)) {
          ret = "";
        } else if (isX(m5)) {
          ret = `>=${M5}.0.0${z5} <${+M5 + 1}.0.0-0`;
        } else if (isX(p6)) {
          if (M5 === "0") {
            ret = `>=${M5}.${m5}.0${z5} <${M5}.${+m5 + 1}.0-0`;
          } else {
            ret = `>=${M5}.${m5}.0${z5} <${+M5 + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M5 === "0") {
            if (m5 === "0") {
              ret = `>=${M5}.${m5}.${p6}-${pr} <${M5}.${m5}.${+p6 + 1}-0`;
            } else {
              ret = `>=${M5}.${m5}.${p6}-${pr} <${M5}.${+m5 + 1}.0-0`;
            }
          } else {
            ret = `>=${M5}.${m5}.${p6}-${pr} <${+M5 + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M5 === "0") {
            if (m5 === "0") {
              ret = `>=${M5}.${m5}.${p6}${z5} <${M5}.${m5}.${+p6 + 1}-0`;
            } else {
              ret = `>=${M5}.${m5}.${p6}${z5} <${M5}.${+m5 + 1}.0-0`;
            }
          } else {
            ret = `>=${M5}.${m5}.${p6} <${+M5 + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c5) => replaceXRange(c5, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r5 = options.loose ? re3[t3.XRANGELOOSE] : re3[t3.XRANGE];
      return comp.replace(r5, (ret, gtlt, M5, m5, p6, pr) => {
        debug("xRange", comp, ret, gtlt, M5, m5, p6, pr);
        const xM = isX(M5);
        const xm = xM || isX(m5);
        const xp = xm || isX(p6);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m5 = 0;
          }
          p6 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M5 = +M5 + 1;
              m5 = 0;
              p6 = 0;
            } else {
              m5 = +m5 + 1;
              p6 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M5 = +M5 + 1;
            } else {
              m5 = +m5 + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M5}.${m5}.${p6}${pr}`;
        } else if (xm) {
          ret = `>=${M5}.0.0${pr} <${+M5 + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M5}.${m5}.0${pr} <${M5}.${+m5 + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re3[t3.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug("replaceGTE0", comp, options);
      return comp.trim().replace(re3[options.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from4, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from4 = "";
      } else if (isX(fm)) {
        from4 = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from4 = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from4 = `>=${from4}`;
      } else {
        from4 = `>=${from4}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from4} ${to}`.trim();
    };
    var testSet = (set3, version28, options) => {
      for (let i4 = 0; i4 < set3.length; i4++) {
        if (!set3[i4].test(version28)) {
          return false;
        }
      }
      if (version28.prerelease.length && !options.includePrerelease) {
        for (let i4 = 0; i4 < set3.length; i4++) {
          debug(set3[i4].semver);
          if (set3[i4].semver === Comparator.ANY) {
            continue;
          }
          if (set3[i4].semver.prerelease.length > 0) {
            const allowed = set3[i4].semver;
            if (allowed.major === version28.major && allowed.minor === version28.minor && allowed.patch === version28.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r5 = this.options.loose ? re3[t3.COMPARATORLOOSE] : re3[t3.COMPARATOR];
        const m5 = comp.match(r5);
        if (!m5) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m5[1] !== void 0 ? m5[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m5[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m5[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version28) {
        debug("Comparator.test", version28, this.options.loose);
        if (this.semver === ANY || version28 === ANY) {
          return true;
        }
        if (typeof version28 === "string") {
          try {
            version28 = new SemVer(version28, this.options);
          } catch (er3) {
            return false;
          }
        }
        return cmp(version28, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re3, t: t3 } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    var Range = require_range();
    var satisfies = (version28, range2, options) => {
      try {
        range2 = new Range(range2, options);
      } catch (er3) {
        return false;
      }
      return range2.test(version28);
    };
    module.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    var Range = require_range();
    var toComparators = (range2, options) => new Range(range2, options).set.map((comp) => comp.map((c5) => c5.value).join(" ").trim().split(" "));
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = (versions, range2, options) => {
      let max3 = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er3) {
        return null;
      }
      versions.forEach((v5) => {
        if (rangeObj.test(v5)) {
          if (!max3 || maxSV.compare(v5) === -1) {
            max3 = v5;
            maxSV = new SemVer(max3, options);
          }
        }
      });
      return max3;
    };
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = (versions, range2, options) => {
      let min3 = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range2, options);
      } catch (er3) {
        return null;
      }
      versions.forEach((v5) => {
        if (rangeObj.test(v5)) {
          if (!min3 || minSV.compare(v5) === 1) {
            min3 = v5;
            minSV = new SemVer(min3, options);
          }
        }
      });
      return min3;
    };
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    var SemVer = require_semver();
    var Range = require_range();
    var gt3 = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i4 = 0; i4 < range2.set.length; ++i4) {
        const comparators = range2.set[i4];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt3(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt3(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    var Range = require_range();
    var validRange = (range2, options) => {
      try {
        return new Range(range2, options).range || "*";
      } catch (er3) {
        return null;
      }
    };
    module.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt3 = require_gt();
    var lt3 = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version28, range2, hilo, options) => {
      version28 = new SemVer(version28, options);
      range2 = new Range(range2, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt3;
          ltefn = lte;
          ltfn = lt3;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt3;
          ltefn = gte;
          ltfn = gt3;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version28, range2, options)) {
        return false;
      }
      for (let i4 = 0; i4 < range2.set.length; ++i4) {
        const comparators = range2.set[i4];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version28, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version28, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    var outside = require_outside();
    var gtr = (version28, range2, options) => outside(version28, range2, ">", options);
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    var outside = require_outside();
    var ltr = (version28, range2, options) => outside(version28, range2, "<", options);
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    var Range = require_range();
    var intersects = (r1, r22, options) => {
      r1 = new Range(r1, options);
      r22 = new Range(r22, options);
      return r1.intersects(r22, options);
    };
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    module.exports = (versions, range2, options) => {
      const set3 = [];
      let first2 = null;
      let prev = null;
      const v5 = versions.sort((a4, b6) => compare2(a4, b6, options));
      for (const version28 of v5) {
        const included = satisfies(version28, range2, options);
        if (included) {
          prev = version28;
          if (!first2) {
            first2 = version28;
          }
        } else {
          if (prev) {
            set3.push([first2, prev]);
          }
          prev = null;
          first2 = null;
        }
      }
      if (first2) {
        set3.push([first2, null]);
      }
      const ranges = [];
      for (const [min3, max3] of set3) {
        if (min3 === max3) {
          ranges.push(min3);
        } else if (!max3 && min3 === v5[0]) {
          ranges.push("*");
        } else if (!max3) {
          ranges.push(`>=${min3}`);
        } else if (min3 === v5[0]) {
          ranges.push(`<=${max3}`);
        } else {
          ranges.push(`${min3} - ${max3}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare2 = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt3, lt3;
      for (const c5 of sub) {
        if (c5.operator === ">" || c5.operator === ">=") {
          gt3 = higherGT(gt3, c5, options);
        } else if (c5.operator === "<" || c5.operator === "<=") {
          lt3 = lowerLT(lt3, c5, options);
        } else {
          eqSet.add(c5.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt3 && lt3) {
        gtltComp = compare2(gt3.semver, lt3.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt3.operator !== ">=" || lt3.operator !== "<=")) {
          return null;
        }
      }
      for (const eq4 of eqSet) {
        if (gt3 && !satisfies(eq4, String(gt3), options)) {
          return null;
        }
        if (lt3 && !satisfies(eq4, String(lt3), options)) {
          return null;
        }
        for (const c5 of dom) {
          if (!satisfies(eq4, String(c5), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt3 && !options.includePrerelease && lt3.semver.prerelease.length ? lt3.semver : false;
      let needDomGTPre = gt3 && !options.includePrerelease && gt3.semver.prerelease.length ? gt3.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt3.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c5 of dom) {
        hasDomGT = hasDomGT || c5.operator === ">" || c5.operator === ">=";
        hasDomLT = hasDomLT || c5.operator === "<" || c5.operator === "<=";
        if (gt3) {
          if (needDomGTPre) {
            if (c5.semver.prerelease && c5.semver.prerelease.length && c5.semver.major === needDomGTPre.major && c5.semver.minor === needDomGTPre.minor && c5.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c5.operator === ">" || c5.operator === ">=") {
            higher = higherGT(gt3, c5, options);
            if (higher === c5 && higher !== gt3) {
              return false;
            }
          } else if (gt3.operator === ">=" && !satisfies(gt3.semver, String(c5), options)) {
            return false;
          }
        }
        if (lt3) {
          if (needDomLTPre) {
            if (c5.semver.prerelease && c5.semver.prerelease.length && c5.semver.major === needDomLTPre.major && c5.semver.minor === needDomLTPre.minor && c5.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c5.operator === "<" || c5.operator === "<=") {
            lower = lowerLT(lt3, c5, options);
            if (lower === c5 && lower !== lt3) {
              return false;
            }
          } else if (lt3.operator === "<=" && !satisfies(lt3.semver, String(c5), options)) {
            return false;
          }
        }
        if (!c5.operator && (lt3 || gt3) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt3 && hasDomLT && !lt3 && gtltComp !== 0) {
        return false;
      }
      if (lt3 && hasDomGT && !gt3 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a4, b6, options) => {
      if (!a4) {
        return b6;
      }
      const comp = compare2(a4.semver, b6.semver, options);
      return comp > 0 ? a4 : comp < 0 ? b6 : b6.operator === ">" && a4.operator === ">=" ? b6 : a4;
    };
    var lowerLT = (a4, b6, options) => {
      if (!a4) {
        return b6;
      }
      const comp = compare2(a4.semver, b6.semver, options);
      return comp < 0 ? a4 : comp > 0 ? b6 : b6.operator === "<" && a4.operator === "<=" ? b6 : a4;
    };
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    var internalRe = require_re();
    var constants = require_constants5();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse3 = require_parse2();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare2 = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt3 = require_gt();
    var lt3 = require_lt();
    var eq4 = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce3 = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse3,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare: compare2,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt3,
      lt: lt3,
      eq: eq4,
      neq,
      gte,
      lte,
      cmp,
      coerce: coerce3,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/@metamask/utils/dist/versions.js
var require_versions = __commonJS({
  "node_modules/@metamask/utils/dist/versions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
    var semver_1 = require_semver2();
    var superstruct_1 = (init_dist(), __toCommonJS(dist_exports));
    var assert_1 = require_assert();
    exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), "Version", (value) => {
      if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
      }
      return true;
    });
    exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), "Version range", (value) => {
      if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
      }
      return true;
    });
    function isValidSemVerVersion(version28) {
      return (0, superstruct_1.is)(version28, exports.VersionStruct);
    }
    exports.isValidSemVerVersion = isValidSemVerVersion;
    function isValidSemVerRange(versionRange) {
      return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
    }
    exports.isValidSemVerRange = isValidSemVerRange;
    function assertIsSemVerVersion(version28) {
      (0, assert_1.assertStruct)(version28, exports.VersionStruct);
    }
    exports.assertIsSemVerVersion = assertIsSemVerVersion;
    function assertIsSemVerRange(range2) {
      (0, assert_1.assertStruct)(range2, exports.VersionRangeStruct);
    }
    exports.assertIsSemVerRange = assertIsSemVerRange;
    function gtVersion(version1, version28) {
      return (0, semver_1.gt)(version1, version28);
    }
    exports.gtVersion = gtVersion;
    function gtRange(version28, range2) {
      return (0, semver_1.gtr)(version28, range2);
    }
    exports.gtRange = gtRange;
    function satisfiesVersionRange(version28, versionRange) {
      return (0, semver_1.satisfies)(version28, versionRange, {
        includePrerelease: true
      });
    }
    exports.satisfiesVersionRange = satisfiesVersionRange;
  }
});

// node_modules/@metamask/utils/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@metamask/utils/dist/index.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m5, k5);
      if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m5[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o3[k22] = m5[k5];
    });
    var __exportStar3 = exports && exports.__exportStar || function(m5, exports2) {
      for (var p6 in m5)
        if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p6))
          __createBinding3(exports2, m5, p6);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar3(require_assert(), exports);
    __exportStar3(require_base64(), exports);
    __exportStar3(require_bytes(), exports);
    __exportStar3(require_checksum(), exports);
    __exportStar3(require_coercers(), exports);
    __exportStar3(require_collections(), exports);
    __exportStar3(require_hex(), exports);
    __exportStar3(require_json(), exports);
    __exportStar3(require_logging(), exports);
    __exportStar3(require_misc2(), exports);
    __exportStar3(require_number(), exports);
    __exportStar3(require_opaque(), exports);
    __exportStar3(require_time2(), exports);
    __exportStar3(require_versions(), exports);
  }
});

// node_modules/eth-block-tracker/dist/logging-utils.js
var require_logging_utils = __commonJS({
  "node_modules/eth-block-tracker/dist/logging-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createModuleLogger = exports.projectLogger = void 0;
    var utils_12 = require_dist2();
    Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function() {
      return utils_12.createModuleLogger;
    } });
    exports.projectLogger = (0, utils_12.createProjectLogger)("eth-block-tracker");
  }
});

// node_modules/eth-block-tracker/dist/PollingBlockTracker.js
var require_PollingBlockTracker = __commonJS({
  "node_modules/eth-block-tracker/dist/PollingBlockTracker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PollingBlockTracker = void 0;
    var json_rpc_random_id_1 = __importDefault3(require_json_rpc_random_id());
    var pify_1 = __importDefault3(require_pify());
    var BaseBlockTracker_1 = require_BaseBlockTracker();
    var logging_utils_1 = require_logging_utils();
    var log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, "polling-block-tracker");
    var createRandomId = (0, json_rpc_random_id_1.default)();
    var sec = 1e3;
    var PollingBlockTracker = class extends BaseBlockTracker_1.BaseBlockTracker {
      constructor(opts = {}) {
        var _a2;
        if (!opts.provider) {
          throw new Error("PollingBlockTracker - no provider specified.");
        }
        super({
          blockResetDuration: (_a2 = opts.blockResetDuration) !== null && _a2 !== void 0 ? _a2 : opts.pollingInterval
        });
        this._provider = opts.provider;
        this._pollingInterval = opts.pollingInterval || 20 * sec;
        this._retryTimeout = opts.retryTimeout || this._pollingInterval / 10;
        this._keepEventLoopActive = opts.keepEventLoopActive === void 0 ? true : opts.keepEventLoopActive;
        this._setSkipCacheFlag = opts.setSkipCacheFlag || false;
      }
      // trigger block polling
      async checkForLatestBlock() {
        await this._updateLatestBlock();
        return await this.getLatestBlock();
      }
      async _start() {
        this._synchronize();
      }
      async _end() {
      }
      async _synchronize() {
        var _a2;
        while (this._isRunning) {
          try {
            await this._updateLatestBlock();
            const promise = timeout2(this._pollingInterval, !this._keepEventLoopActive);
            this.emit("_waitingForNextIteration");
            await promise;
          } catch (err) {
            const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err}`);
            try {
              this.emit("error", newErr);
            } catch (emitErr) {
              console.error(newErr);
            }
            const promise = timeout2(this._retryTimeout, !this._keepEventLoopActive);
            this.emit("_waitingForNextIteration");
            await promise;
          }
        }
      }
      async _updateLatestBlock() {
        const latestBlock = await this._fetchLatestBlock();
        this._newPotentialLatest(latestBlock);
      }
      async _fetchLatestBlock() {
        const req = {
          jsonrpc: "2.0",
          id: createRandomId(),
          method: "eth_blockNumber",
          params: []
        };
        if (this._setSkipCacheFlag) {
          req.skipCache = true;
        }
        log("Making request", req);
        const res = await (0, pify_1.default)((cb) => this._provider.sendAsync(req, cb))();
        log("Got response", res);
        if (res.error) {
          throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error.message}`);
        }
        return res.result;
      }
    };
    exports.PollingBlockTracker = PollingBlockTracker;
    function timeout2(duration, unref) {
      return new Promise((resolve) => {
        const timeoutRef = setTimeout(resolve, duration);
        if (timeoutRef.unref && unref) {
          timeoutRef.unref();
        }
      });
    }
  }
});

// node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js
var require_SubscribeBlockTracker = __commonJS({
  "node_modules/eth-block-tracker/dist/SubscribeBlockTracker.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscribeBlockTracker = void 0;
    var json_rpc_random_id_1 = __importDefault3(require_json_rpc_random_id());
    var BaseBlockTracker_1 = require_BaseBlockTracker();
    var createRandomId = (0, json_rpc_random_id_1.default)();
    var SubscribeBlockTracker = class extends BaseBlockTracker_1.BaseBlockTracker {
      constructor(opts = {}) {
        if (!opts.provider) {
          throw new Error("SubscribeBlockTracker - no provider specified.");
        }
        super(opts);
        this._provider = opts.provider;
        this._subscriptionId = null;
      }
      async checkForLatestBlock() {
        return await this.getLatestBlock();
      }
      async _start() {
        if (this._subscriptionId === void 0 || this._subscriptionId === null) {
          try {
            const blockNumber = await this._call("eth_blockNumber");
            this._subscriptionId = await this._call("eth_subscribe", "newHeads");
            this._provider.on("data", this._handleSubData.bind(this));
            this._newPotentialLatest(blockNumber);
          } catch (e3) {
            this.emit("error", e3);
          }
        }
      }
      async _end() {
        if (this._subscriptionId !== null && this._subscriptionId !== void 0) {
          try {
            await this._call("eth_unsubscribe", this._subscriptionId);
            this._subscriptionId = null;
          } catch (e3) {
            this.emit("error", e3);
          }
        }
      }
      _call(method, ...params) {
        return new Promise((resolve, reject) => {
          this._provider.sendAsync({
            id: createRandomId(),
            method,
            params,
            jsonrpc: "2.0"
          }, (err, res) => {
            if (err) {
              reject(err);
            } else {
              resolve(res.result);
            }
          });
        });
      }
      _handleSubData(_6, response) {
        var _a2;
        if (response.method === "eth_subscription" && ((_a2 = response.params) === null || _a2 === void 0 ? void 0 : _a2.subscription) === this._subscriptionId) {
          this._newPotentialLatest(response.params.result.number);
        }
      }
    };
    exports.SubscribeBlockTracker = SubscribeBlockTracker;
  }
});

// node_modules/eth-block-tracker/dist/types.js
var require_types4 = __commonJS({
  "node_modules/eth-block-tracker/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/eth-block-tracker/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/eth-block-tracker/dist/index.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o3[k22] = m5[k5];
    });
    var __exportStar3 = exports && exports.__exportStar || function(m5, exports2) {
      for (var p6 in m5)
        if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p6))
          __createBinding3(exports2, m5, p6);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar3(require_PollingBlockTracker(), exports);
    __exportStar3(require_SubscribeBlockTracker(), exports);
    __exportStar3(require_types4(), exports);
  }
});

// node_modules/json-rpc-engine/dist/getUniqueId.js
var require_getUniqueId = __commonJS({
  "node_modules/json-rpc-engine/dist/getUniqueId.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUniqueId = void 0;
    var MAX = 4294967295;
    var idCounter = Math.floor(Math.random() * MAX);
    function getUniqueId() {
      idCounter = (idCounter + 1) % MAX;
      return idCounter;
    }
    exports.getUniqueId = getUniqueId;
  }
});

// node_modules/json-rpc-engine/dist/idRemapMiddleware.js
var require_idRemapMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/idRemapMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createIdRemapMiddleware = void 0;
    var getUniqueId_1 = require_getUniqueId();
    function createIdRemapMiddleware() {
      return (req, res, next, _end) => {
        const originalId = req.id;
        const newId = getUniqueId_1.getUniqueId();
        req.id = newId;
        res.id = newId;
        next((done) => {
          req.id = originalId;
          res.id = originalId;
          done();
        });
      };
    }
    exports.createIdRemapMiddleware = createIdRemapMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/createAsyncMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAsyncMiddleware = void 0;
    function createAsyncMiddleware(asyncMiddleware) {
      return async (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback = null;
        let nextWasCalled = false;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((runReturnHandlersCallback) => {
            returnHandlerCallback = runReturnHandlersCallback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        try {
          await asyncMiddleware(req, res, asyncNext);
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        } catch (error) {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        }
      };
    }
    exports.createAsyncMiddleware = createAsyncMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js
var require_createScaffoldMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/createScaffoldMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createScaffoldMiddleware = void 0;
    function createScaffoldMiddleware(handlers) {
      return (req, res, next, end) => {
        const handler = handlers[req.method];
        if (handler === void 0) {
          return next();
        }
        if (typeof handler === "function") {
          return handler(req, res, next, end);
        }
        res.result = handler;
        return end();
      };
    }
    exports.createScaffoldMiddleware = createScaffoldMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/JsonRpcEngine.js
var require_JsonRpcEngine = __commonJS({
  "node_modules/json-rpc-engine/dist/JsonRpcEngine.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcEngine = void 0;
    var safe_event_emitter_1 = __importDefault3(require_safe_event_emitter());
    var eth_rpc_errors_1 = require_dist();
    var JsonRpcEngine = class _JsonRpcEngine extends safe_event_emitter_1.default {
      constructor() {
        super();
        this._middleware = [];
      }
      /**
       * Add a middleware function to the engine's middleware stack.
       *
       * @param middleware - The middleware function to add.
       */
      push(middleware) {
        this._middleware.push(middleware);
      }
      handle(req, cb) {
        if (cb && typeof cb !== "function") {
          throw new Error('"callback" must be a function if provided.');
        }
        if (Array.isArray(req)) {
          if (cb) {
            return this._handleBatch(req, cb);
          }
          return this._handleBatch(req);
        }
        if (cb) {
          return this._handle(req, cb);
        }
        return this._promiseHandle(req);
      }
      /**
       * Returns this engine as a middleware function that can be pushed to other
       * engines.
       *
       * @returns This engine as a middleware function.
       */
      asMiddleware() {
        return async (req, res, next, end) => {
          try {
            const [middlewareError, isComplete, returnHandlers] = await _JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
            if (isComplete) {
              await _JsonRpcEngine._runReturnHandlers(returnHandlers);
              return end(middlewareError);
            }
            return next(async (handlerCallback) => {
              try {
                await _JsonRpcEngine._runReturnHandlers(returnHandlers);
              } catch (error) {
                return handlerCallback(error);
              }
              return handlerCallback();
            });
          } catch (error) {
            return end(error);
          }
        };
      }
      async _handleBatch(reqs, cb) {
        try {
          const responses = await Promise.all(
            // 1. Begin executing each request in the order received
            reqs.map(this._promiseHandle.bind(this))
          );
          if (cb) {
            return cb(null, responses);
          }
          return responses;
        } catch (error) {
          if (cb) {
            return cb(error);
          }
          throw error;
        }
      }
      /**
       * A promise-wrapped _handle.
       */
      _promiseHandle(req) {
        return new Promise((resolve) => {
          this._handle(req, (_err, res) => {
            resolve(res);
          });
        });
      }
      /**
       * Ensures that the request object is valid, processes it, and passes any
       * error and the response object to the given callback.
       *
       * Does not reject.
       */
      async _handle(callerReq, cb) {
        if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
          return cb(error2, { id: void 0, jsonrpc: "2.0", error: error2 });
        }
        if (typeof callerReq.method !== "string") {
          const error2 = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
          return cb(error2, { id: callerReq.id, jsonrpc: "2.0", error: error2 });
        }
        const req = Object.assign({}, callerReq);
        const res = {
          id: req.id,
          jsonrpc: req.jsonrpc
        };
        let error = null;
        try {
          await this._processRequest(req, res);
        } catch (_error) {
          error = _error;
        }
        if (error) {
          delete res.result;
          if (!res.error) {
            res.error = eth_rpc_errors_1.serializeError(error);
          }
        }
        return cb(error, res);
      }
      /**
       * For the given request and response, runs all middleware and their return
       * handlers, if any, and ensures that internal request processing semantics
       * are satisfied.
       */
      async _processRequest(req, res) {
        const [error, isComplete, returnHandlers] = await _JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        _JsonRpcEngine._checkForCompletion(req, res, isComplete);
        await _JsonRpcEngine._runReturnHandlers(returnHandlers);
        if (error) {
          throw error;
        }
      }
      /**
       * Serially executes the given stack of middleware.
       *
       * @returns An array of any error encountered during middleware execution,
       * a boolean indicating whether the request was completed, and an array of
       * middleware-defined return handlers.
       */
      static async _runAllMiddleware(req, res, middlewareStack) {
        const returnHandlers = [];
        let error = null;
        let isComplete = false;
        for (const middleware of middlewareStack) {
          [error, isComplete] = await _JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
          if (isComplete) {
            break;
          }
        }
        return [error, isComplete, returnHandlers.reverse()];
      }
      /**
       * Runs an individual middleware.
       *
       * @returns An array of any error encountered during middleware exection,
       * and a boolean indicating whether the request should end.
       */
      static _runMiddleware(req, res, middleware, returnHandlers) {
        return new Promise((resolve) => {
          const end = (err) => {
            const error = err || res.error;
            if (error) {
              res.error = eth_rpc_errors_1.serializeError(error);
            }
            resolve([error, true]);
          };
          const next = (returnHandler) => {
            if (res.error) {
              end(res.error);
            } else {
              if (returnHandler) {
                if (typeof returnHandler !== "function") {
                  end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
                }
                returnHandlers.push(returnHandler);
              }
              resolve([null, false]);
            }
          };
          try {
            middleware(req, res, next, end);
          } catch (error) {
            end(error);
          }
        });
      }
      /**
       * Serially executes array of return handlers. The request and response are
       * assumed to be in their scope.
       */
      static async _runReturnHandlers(handlers) {
        for (const handler of handlers) {
          await new Promise((resolve, reject) => {
            handler((err) => err ? reject(err) : resolve());
          });
        }
      }
      /**
       * Throws an error if the response has neither a result nor an error, or if
       * the "isComplete" flag is falsy.
       */
      static _checkForCompletion(req, res, isComplete) {
        if (!("result" in res) && !("error" in res)) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
        }
        if (!isComplete) {
          throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
        }
      }
    };
    exports.JsonRpcEngine = JsonRpcEngine;
    function jsonify(request) {
      return JSON.stringify(request, null, 2);
    }
  }
});

// node_modules/json-rpc-engine/dist/mergeMiddleware.js
var require_mergeMiddleware = __commonJS({
  "node_modules/json-rpc-engine/dist/mergeMiddleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mergeMiddleware = void 0;
    var JsonRpcEngine_1 = require_JsonRpcEngine();
    function mergeMiddleware(middlewareStack) {
      const engine = new JsonRpcEngine_1.JsonRpcEngine();
      middlewareStack.forEach((middleware) => engine.push(middleware));
      return engine.asMiddleware();
    }
    exports.mergeMiddleware = mergeMiddleware;
  }
});

// node_modules/json-rpc-engine/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/json-rpc-engine/dist/index.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o3[k22] = m5[k5];
    });
    var __exportStar3 = exports && exports.__exportStar || function(m5, exports2) {
      for (var p6 in m5)
        if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p6))
          __createBinding3(exports2, m5, p6);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar3(require_idRemapMiddleware(), exports);
    __exportStar3(require_createAsyncMiddleware(), exports);
    __exportStar3(require_createScaffoldMiddleware(), exports);
    __exportStar3(require_getUniqueId(), exports);
    __exportStar3(require_JsonRpcEngine(), exports);
    __exportStar3(require_mergeMiddleware(), exports);
  }
});

// node_modules/async-mutex/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports2 = {};
__export(tslib_es6_exports2, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator2,
  __asyncGenerator: () => __asyncGenerator2,
  __asyncValues: () => __asyncValues2,
  __await: () => __await2,
  __awaiter: () => __awaiter18,
  __classPrivateFieldGet: () => __classPrivateFieldGet2,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet2,
  __createBinding: () => __createBinding2,
  __decorate: () => __decorate36,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar2,
  __extends: () => __extends2,
  __generator: () => __generator2,
  __importDefault: () => __importDefault2,
  __importStar: () => __importStar2,
  __makeTemplateObject: () => __makeTemplateObject2,
  __metadata: () => __metadata2,
  __param: () => __param2,
  __propKey: () => __propKey,
  __read: () => __read2,
  __rest: () => __rest2,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread2,
  __spreadArray: () => __spreadArray2,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2,
  default: () => tslib_es6_default
});
function __extends2(d4, b6) {
  if (typeof b6 !== "function" && b6 !== null)
    throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
  extendStatics2(d4, b6);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
}
function __rest2(s3, e3) {
  var t3 = {};
  for (var p6 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p6) && e3.indexOf(p6) < 0)
      t3[p6] = s3[p6];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p6 = Object.getOwnPropertySymbols(s3); i4 < p6.length; i4++) {
      if (e3.indexOf(p6[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p6[i4]))
        t3[p6[i4]] = s3[p6[i4]];
    }
  return t3;
}
function __decorate36(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
}
function __param2(paramIndex, decorator) {
  return function(target, key2) {
    decorator(target, key2, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f5) {
    if (f5 !== void 0 && typeof f5 !== "function")
      throw new TypeError("Function expected");
    return f5;
  }
  var kind = contextIn.kind, key2 = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _6, done = false;
  for (var i4 = decorators.length - 1; i4 >= 0; i4--) {
    var context = {};
    for (var p6 in contextIn)
      context[p6] = p6 === "access" ? {} : contextIn[p6];
    for (var p6 in contextIn.access)
      context.access[p6] = contextIn.access[p6];
    context.addInitializer = function(f5) {
      if (done)
        throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f5 || null));
    };
    var result = (0, decorators[i4])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key2], context);
    if (kind === "accessor") {
      if (result === void 0)
        continue;
      if (result === null || typeof result !== "object")
        throw new TypeError("Object expected");
      if (_6 = accept(result.get))
        descriptor.get = _6;
      if (_6 = accept(result.set))
        descriptor.set = _6;
      if (_6 = accept(result.init))
        initializers.unshift(_6);
    } else if (_6 = accept(result)) {
      if (kind === "field")
        initializers.unshift(_6);
      else
        descriptor[key2] = _6;
    }
  }
  if (target)
    Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i4 = 0; i4 < initializers.length; i4++) {
    value = useValue ? initializers[i4].call(thisArg, value) : initializers[i4].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x5) {
  return typeof x5 === "symbol" ? x5 : "".concat(x5);
}
function __setFunctionName(f5, name2, prefix) {
  if (typeof name2 === "symbol")
    name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f5, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata2(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter18(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator2(thisArg, body) {
  var _6 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f5, y7, t3, g7;
  return g7 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g7[Symbol.iterator] = function() {
    return this;
  }), g7;
  function verb(n3) {
    return function(v5) {
      return step([n3, v5]);
    };
  }
  function step(op) {
    if (f5)
      throw new TypeError("Generator is already executing.");
    while (g7 && (g7 = 0, op[0] && (_6 = 0)), _6)
      try {
        if (f5 = 1, y7 && (t3 = op[0] & 2 ? y7["return"] : op[0] ? y7["throw"] || ((t3 = y7["return"]) && t3.call(y7), 0) : y7.next) && !(t3 = t3.call(y7, op[1])).done)
          return t3;
        if (y7 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _6.label++;
            return { value: op[1], done: false };
          case 5:
            _6.label++;
            y7 = op[1];
            op = [0];
            continue;
          case 7:
            op = _6.ops.pop();
            _6.trys.pop();
            continue;
          default:
            if (!(t3 = _6.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _6 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _6.label = op[1];
              break;
            }
            if (op[0] === 6 && _6.label < t3[1]) {
              _6.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _6.label < t3[2]) {
              _6.label = t3[2];
              _6.ops.push(op);
              break;
            }
            if (t3[2])
              _6.ops.pop();
            _6.trys.pop();
            continue;
        }
        op = body.call(thisArg, _6);
      } catch (e3) {
        op = [6, e3];
        y7 = 0;
      } finally {
        f5 = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar2(m5, o3) {
  for (var p6 in m5)
    if (p6 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p6))
      __createBinding2(o3, m5, p6);
}
function __values2(o3) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m5 = s3 && o3[s3], i4 = 0;
  if (m5)
    return m5.call(o3);
  if (o3 && typeof o3.length === "number")
    return {
      next: function() {
        if (o3 && i4 >= o3.length)
          o3 = void 0;
        return { value: o3 && o3[i4++], done: !o3 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o3, n3) {
  var m5 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m5)
    return o3;
  var i4 = m5.call(o3), r5, ar2 = [], e3;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r5 = i4.next()).done)
      ar2.push(r5.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r5 && !r5.done && (m5 = i4["return"]))
        m5.call(i4);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread2() {
  for (var ar2 = [], i4 = 0; i4 < arguments.length; i4++)
    ar2 = ar2.concat(__read2(arguments[i4]));
  return ar2;
}
function __spreadArrays2() {
  for (var s3 = 0, i4 = 0, il = arguments.length; i4 < il; i4++)
    s3 += arguments[i4].length;
  for (var r5 = Array(s3), k5 = 0, i4 = 0; i4 < il; i4++)
    for (var a4 = arguments[i4], j7 = 0, jl = a4.length; j7 < jl; j7++, k5++)
      r5[k5] = a4[j7];
  return r5;
}
function __spreadArray2(to, from4, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i4 = 0, l4 = from4.length, ar2; i4 < l4; i4++) {
      if (ar2 || !(i4 in from4)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from4, 0, i4);
        ar2[i4] = from4[i4];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from4));
}
function __await2(v5) {
  return this instanceof __await2 ? (this.v = v5, this) : new __await2(v5);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g7 = generator.apply(thisArg, _arguments || []), i4, q5 = [];
  return i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function verb(n3) {
    if (g7[n3])
      i4[n3] = function(v5) {
        return new Promise(function(a4, b6) {
          q5.push([n3, v5, a4, b6]) > 1 || resume(n3, v5);
        });
      };
  }
  function resume(n3, v5) {
    try {
      step(g7[n3](v5));
    } catch (e3) {
      settle(q5[0][3], e3);
    }
  }
  function step(r5) {
    r5.value instanceof __await2 ? Promise.resolve(r5.value.v).then(fulfill, reject) : settle(q5[0][2], r5);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f5, v5) {
    if (f5(v5), q5.shift(), q5.length)
      resume(q5[0][0], q5[0][1]);
  }
}
function __asyncDelegator2(o3) {
  var i4, p6;
  return i4 = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n3, f5) {
    i4[n3] = o3[n3] ? function(v5) {
      return (p6 = !p6) ? { value: __await2(o3[n3](v5)), done: false } : f5 ? f5(v5) : v5;
    } : f5;
  }
}
function __asyncValues2(o3) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m5 = o3[Symbol.asyncIterator], i4;
  return m5 ? m5.call(o3) : (o3 = typeof __values2 === "function" ? __values2(o3) : o3[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n3) {
    i4[n3] = o3[n3] && function(v5) {
      return new Promise(function(resolve, reject) {
        v5 = o3[n3](v5), settle(resolve, reject, v5.done, v5.value);
      });
    };
  }
  function settle(resolve, reject, d4, v5) {
    Promise.resolve(v5).then(function(v6) {
      resolve({ value: v6, done: d4 });
    }, reject);
  }
}
function __makeTemplateObject2(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar2(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k5 in mod)
      if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
        __createBinding2(result, mod, k5);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet2(receiver, state3, kind, f5) {
  if (kind === "a" && !f5)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state3 === "function" ? receiver !== state3 || !f5 : !state3.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state3.get(receiver);
}
function __classPrivateFieldSet2(receiver, state3, value, kind, f5) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f5)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state3 === "function" ? receiver !== state3 || !f5 : !state3.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state3.set(receiver, value), value;
}
function __classPrivateFieldIn(state3, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state3 === "function" ? receiver === state3 : state3.has(receiver);
}
function __addDisposableResource(env, value, async2) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function")
      throw new TypeError("Object expected.");
    var dispose2;
    if (async2) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose2 = value[Symbol.asyncDispose];
    }
    if (dispose2 === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      dispose2 = value[Symbol.dispose];
    }
    if (typeof dispose2 !== "function")
      throw new TypeError("Object not disposable.");
    env.stack.push({ value, dispose: dispose2, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e3) {
    env.error = env.hasError ? new _SuppressedError(e3, env.error, "An error was suppressed during disposal.") : e3;
    env.hasError = true;
  }
  function next() {
    while (env.stack.length) {
      var rec = env.stack.pop();
      try {
        var result = rec.dispose && rec.dispose.call(rec.value);
        if (rec.async)
          return Promise.resolve(result).then(next, function(e3) {
            fail(e3);
            return next();
          });
      } catch (e3) {
        fail(e3);
      }
    }
    if (env.hasError)
      throw env.error;
  }
  return next();
}
var extendStatics2, __assign2, __createBinding2, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es62 = __esm({
  "node_modules/async-mutex/node_modules/tslib/tslib.es6.mjs"() {
    extendStatics2 = function(d4, b6) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b7) {
        d5.__proto__ = b7;
      } || function(d5, b7) {
        for (var p6 in b7)
          if (Object.prototype.hasOwnProperty.call(b7, p6))
            d5[p6] = b7[p6];
      };
      return extendStatics2(d4, b6);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t3) {
        for (var s3, i4 = 1, n3 = arguments.length; i4 < n3; i4++) {
          s3 = arguments[i4];
          for (var p6 in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p6))
              t3[p6] = s3[p6];
        }
        return t3;
      };
      return __assign2.apply(this, arguments);
    };
    __createBinding2 = Object.create ? function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m5, k5);
      if (!desc || ("get" in desc ? !m5.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m5[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    } : function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o3[k22] = m5[k5];
    };
    __setModuleDefault = Object.create ? function(o3, v5) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v5 });
    } : function(o3, v5) {
      o3["default"] = v5;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e3 = new Error(message);
      return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
    };
    tslib_es6_default = {
      __extends: __extends2,
      __assign: __assign2,
      __rest: __rest2,
      __decorate: __decorate36,
      __param: __param2,
      __metadata: __metadata2,
      __awaiter: __awaiter18,
      __generator: __generator2,
      __createBinding: __createBinding2,
      __exportStar: __exportStar2,
      __values: __values2,
      __read: __read2,
      __spread: __spread2,
      __spreadArrays: __spreadArrays2,
      __spreadArray: __spreadArray2,
      __await: __await2,
      __asyncGenerator: __asyncGenerator2,
      __asyncDelegator: __asyncDelegator2,
      __asyncValues: __asyncValues2,
      __makeTemplateObject: __makeTemplateObject2,
      __importStar: __importStar2,
      __importDefault: __importDefault2,
      __classPrivateFieldGet: __classPrivateFieldGet2,
      __classPrivateFieldSet: __classPrivateFieldSet2,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// node_modules/async-mutex/lib/Semaphore.js
var require_Semaphore = __commonJS({
  "node_modules/async-mutex/lib/Semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var Semaphore = (
      /** @class */
      function() {
        function Semaphore2(_maxConcurrency) {
          this._maxConcurrency = _maxConcurrency;
          this._queue = [];
          if (_maxConcurrency <= 0) {
            throw new Error("semaphore must be initialized to a positive value");
          }
          this._value = _maxConcurrency;
        }
        Semaphore2.prototype.acquire = function() {
          var _this = this;
          var locked = this.isLocked();
          var ticket = new Promise(function(r5) {
            return _this._queue.push(r5);
          });
          if (!locked)
            this._dispatch();
          return ticket;
        };
        Semaphore2.prototype.runExclusive = function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a2, value, release;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this.acquire()];
                case 1:
                  _a2 = _b.sent(), value = _a2[0], release = _a2[1];
                  _b.label = 2;
                case 2:
                  _b.trys.push([2, , 4, 5]);
                  return [4, callback(value)];
                case 3:
                  return [2, _b.sent()];
                case 4:
                  release();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Semaphore2.prototype.isLocked = function() {
          return this._value <= 0;
        };
        Semaphore2.prototype.release = function() {
          if (this._maxConcurrency > 1) {
            throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
          }
          if (this._currentReleaser) {
            var releaser = this._currentReleaser;
            this._currentReleaser = void 0;
            releaser();
          }
        };
        Semaphore2.prototype._dispatch = function() {
          var _this = this;
          var nextConsumer = this._queue.shift();
          if (!nextConsumer)
            return;
          var released = false;
          this._currentReleaser = function() {
            if (released)
              return;
            released = true;
            _this._value++;
            _this._dispatch();
          };
          nextConsumer([this._value--, this._currentReleaser]);
        };
        return Semaphore2;
      }()
    );
    exports.default = Semaphore;
  }
});

// node_modules/async-mutex/lib/Mutex.js
var require_Mutex = __commonJS({
  "node_modules/async-mutex/lib/Mutex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    var Semaphore_1 = require_Semaphore();
    var Mutex = (
      /** @class */
      function() {
        function Mutex2() {
          this._semaphore = new Semaphore_1.default(1);
        }
        Mutex2.prototype.acquire = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var _a2, releaser;
            return tslib_1.__generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  return [4, this._semaphore.acquire()];
                case 1:
                  _a2 = _b.sent(), releaser = _a2[1];
                  return [2, releaser];
              }
            });
          });
        };
        Mutex2.prototype.runExclusive = function(callback) {
          return this._semaphore.runExclusive(function() {
            return callback();
          });
        };
        Mutex2.prototype.isLocked = function() {
          return this._semaphore.isLocked();
        };
        Mutex2.prototype.release = function() {
          this._semaphore.release();
        };
        return Mutex2;
      }()
    );
    exports.default = Mutex;
  }
});

// node_modules/async-mutex/lib/withTimeout.js
var require_withTimeout = __commonJS({
  "node_modules/async-mutex/lib/withTimeout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports2));
    function withTimeout(sync, timeout2, timeoutError) {
      var _this = this;
      if (timeoutError === void 0) {
        timeoutError = new Error("timeout");
      }
      return {
        acquire: function() {
          return new Promise(function(resolve, reject) {
            return tslib_1.__awaiter(_this, void 0, void 0, function() {
              var isTimeout, ticket, release;
              return tslib_1.__generator(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    isTimeout = false;
                    setTimeout(function() {
                      isTimeout = true;
                      reject(timeoutError);
                    }, timeout2);
                    return [4, sync.acquire()];
                  case 1:
                    ticket = _a2.sent();
                    if (isTimeout) {
                      release = Array.isArray(ticket) ? ticket[1] : ticket;
                      release();
                    } else {
                      resolve(ticket);
                    }
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          });
        },
        runExclusive: function(callback) {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            var release, ticket;
            return tslib_1.__generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  release = function() {
                    return void 0;
                  };
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, , 7, 8]);
                  return [4, this.acquire()];
                case 2:
                  ticket = _a2.sent();
                  if (!Array.isArray(ticket))
                    return [3, 4];
                  release = ticket[1];
                  return [4, callback(ticket[0])];
                case 3:
                  return [2, _a2.sent()];
                case 4:
                  release = ticket;
                  return [4, callback()];
                case 5:
                  return [2, _a2.sent()];
                case 6:
                  return [3, 8];
                case 7:
                  release();
                  return [
                    7
                    /*endfinally*/
                  ];
                case 8:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        },
        release: function() {
          sync.release();
        },
        isLocked: function() {
          return sync.isLocked();
        }
      };
    }
    exports.withTimeout = withTimeout;
  }
});

// node_modules/async-mutex/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/async-mutex/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
    var Mutex_1 = require_Mutex();
    Object.defineProperty(exports, "Mutex", { enumerable: true, get: function() {
      return Mutex_1.default;
    } });
    var Semaphore_1 = require_Semaphore();
    Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function() {
      return Semaphore_1.default;
    } });
    var withTimeout_1 = require_withTimeout();
    Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function() {
      return withTimeout_1.withTimeout;
    } });
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i4 = 0; i4 < arguments.length; i4++) {
        var source = arguments[i4];
        for (var key2 in source) {
          if (hasOwnProperty.call(source, key2)) {
            target[key2] = source[key2];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/eth-query/index.js
var require_eth_query = __commonJS({
  "node_modules/eth-query/index.js"(exports, module) {
    var extend = require_immutable();
    var createRandomId = require_json_rpc_random_id()();
    module.exports = EthQuery;
    function EthQuery(provider) {
      const self2 = this;
      self2.currentProvider = provider;
    }
    EthQuery.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
    EthQuery.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
    EthQuery.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
    EthQuery.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
    EthQuery.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
    EthQuery.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
    EthQuery.prototype.syncing = generateFnFor("eth_syncing");
    EthQuery.prototype.coinbase = generateFnFor("eth_coinbase");
    EthQuery.prototype.mining = generateFnFor("eth_mining");
    EthQuery.prototype.hashrate = generateFnFor("eth_hashrate");
    EthQuery.prototype.gasPrice = generateFnFor("eth_gasPrice");
    EthQuery.prototype.accounts = generateFnFor("eth_accounts");
    EthQuery.prototype.blockNumber = generateFnFor("eth_blockNumber");
    EthQuery.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
    EthQuery.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
    EthQuery.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
    EthQuery.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
    EthQuery.prototype.sign = generateFnFor("eth_sign");
    EthQuery.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
    EthQuery.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
    EthQuery.prototype.estimateGas = generateFnFor("eth_estimateGas");
    EthQuery.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
    EthQuery.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
    EthQuery.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
    EthQuery.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
    EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
    EthQuery.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
    EthQuery.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
    EthQuery.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
    EthQuery.prototype.getCompilers = generateFnFor("eth_getCompilers");
    EthQuery.prototype.compileLLL = generateFnFor("eth_compileLLL");
    EthQuery.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
    EthQuery.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
    EthQuery.prototype.newFilter = generateFnFor("eth_newFilter");
    EthQuery.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
    EthQuery.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
    EthQuery.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
    EthQuery.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
    EthQuery.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
    EthQuery.prototype.getLogs = generateFnFor("eth_getLogs");
    EthQuery.prototype.getWork = generateFnFor("eth_getWork");
    EthQuery.prototype.submitWork = generateFnFor("eth_submitWork");
    EthQuery.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
    EthQuery.prototype.sendAsync = function(opts, cb) {
      const self2 = this;
      self2.currentProvider.sendAsync(createPayload(opts), function(err, response) {
        if (!err && response.error)
          err = new Error("EthQuery - RPC Error - " + response.error.message);
        if (err)
          return cb(err);
        cb(null, response.result);
      });
    };
    function generateFnFor(methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function generateFnWithDefaultBlockFor(argCount, methodName) {
      return function() {
        const self2 = this;
        var args = [].slice.call(arguments);
        var cb = args.pop();
        if (args.length < argCount)
          args.push("latest");
        self2.sendAsync({
          method: methodName,
          params: args
        }, cb);
      };
    }
    function createPayload(data3) {
      return extend({
        // defaults
        id: createRandomId(),
        jsonrpc: "2.0",
        params: []
        // user-specified
      }, data3);
    }
  }
});

// node_modules/eth-json-rpc-filters/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "node_modules/eth-json-rpc-filters/node_modules/pify/index.js"(exports, module) {
    "use strict";
    var processFn = (fn2, options, proxy2, unwrapped) => function(...arguments_) {
      const P4 = options.promiseModule;
      return new P4((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self2 = this === proxy2 ? unwrapped : this;
        Reflect.apply(fn2, self2, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module.exports = (input, options) => {
      options = {
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise,
        ...options
      };
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter2 = (target, key2) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key2 in cached) {
          return cached[key2];
        }
        const match = (pattern2) => typeof pattern2 === "string" || typeof key2 === "symbol" ? key2 === pattern2 : pattern2.test(key2);
        const desc = Reflect.getOwnPropertyDescriptor(target, key2);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key2] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy2 = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy2, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key2) {
          const property2 = target[key2];
          if (!filter2(target, key2) || property2 === Function.prototype[key2]) {
            return property2;
          }
          const cached = cache.get(property2);
          if (cached) {
            return cached;
          }
          if (typeof property2 === "function") {
            const pified = processFn(property2, options, proxy2, target);
            cache.set(property2, pified);
            return pified;
          }
          return property2;
        }
      });
      return proxy2;
    };
  }
});

// node_modules/eth-json-rpc-filters/base-filter.js
var require_base_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var BaseFilter = class extends SafeEventEmitter {
      constructor() {
        super();
        this.updates = [];
      }
      async initialize() {
      }
      async update() {
        throw new Error("BaseFilter - no update method specified");
      }
      addResults(newResults) {
        this.updates = this.updates.concat(newResults);
        newResults.forEach((result) => this.emit("update", result));
      }
      addInitialResults(newResults) {
      }
      getChangesAndClear() {
        const updates = this.updates;
        this.updates = [];
        return updates;
      }
    };
    module.exports = BaseFilter;
  }
});

// node_modules/eth-json-rpc-filters/base-filter-history.js
var require_base_filter_history = __commonJS({
  "node_modules/eth-json-rpc-filters/base-filter-history.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var BaseFilterWithHistory = class extends BaseFilter {
      constructor() {
        super();
        this.allResults = [];
      }
      async update() {
        throw new Error("BaseFilterWithHistory - no update method specified");
      }
      addResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addResults(newResults);
      }
      addInitialResults(newResults) {
        this.allResults = this.allResults.concat(newResults);
        super.addInitialResults(newResults);
      }
      getAllResults() {
        return this.allResults;
      }
    };
    module.exports = BaseFilterWithHistory;
  }
});

// node_modules/eth-json-rpc-filters/hexUtils.js
var require_hexUtils = __commonJS({
  "node_modules/eth-json-rpc-filters/hexUtils.js"(exports, module) {
    module.exports = {
      minBlockRef,
      maxBlockRef,
      sortBlockRefs,
      bnToHex,
      blockRefIsNumber,
      hexToInt,
      incrementHexInt,
      intToHex,
      unsafeRandomBytes
    };
    function minBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[0];
    }
    function maxBlockRef(...refs) {
      const sortedRefs = sortBlockRefs(refs);
      return sortedRefs[sortedRefs.length - 1];
    }
    function sortBlockRefs(refs) {
      return refs.sort((refA, refB) => {
        if (refA === "latest" || refB === "earliest")
          return 1;
        if (refB === "latest" || refA === "earliest")
          return -1;
        return hexToInt(refA) - hexToInt(refB);
      });
    }
    function bnToHex(bn2) {
      return "0x" + bn2.toString(16);
    }
    function blockRefIsNumber(blockRef) {
      return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function incrementHexInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      const value = hexToInt(hexString);
      return intToHex(value + 1);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      let hexString = int.toString(16);
      const needsLeftPad = hexString.length % 2;
      if (needsLeftPad)
        hexString = "0" + hexString;
      return "0x" + hexString;
    }
    function unsafeRandomBytes(byteCount) {
      let result = "0x";
      for (let i4 = 0; i4 < byteCount; i4++) {
        result += unsafeRandomNibble();
        result += unsafeRandomNibble();
      }
      return result;
    }
    function unsafeRandomNibble() {
      return Math.floor(Math.random() * 16).toString(16);
    }
  }
});

// node_modules/eth-json-rpc-filters/log-filter.js
var require_log_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/log-filter.js"(exports, module) {
    var EthQuery = require_eth_query();
    var pify = require_pify2();
    var BaseFilterWithHistory = require_base_filter_history();
    var { bnToHex, hexToInt, incrementHexInt, minBlockRef, blockRefIsNumber } = require_hexUtils();
    var LogFilter = class extends BaseFilterWithHistory {
      constructor({ provider, params }) {
        super();
        this.type = "log";
        this.ethQuery = new EthQuery(provider);
        this.params = Object.assign({
          fromBlock: "latest",
          toBlock: "latest",
          address: void 0,
          topics: []
        }, params);
        if (this.params.address) {
          if (!Array.isArray(this.params.address)) {
            this.params.address = [this.params.address];
          }
          this.params.address = this.params.address.map((address) => address.toLowerCase());
        }
      }
      async initialize({ currentBlock }) {
        let fromBlock = this.params.fromBlock;
        if (["latest", "pending"].includes(fromBlock))
          fromBlock = currentBlock;
        if ("earliest" === fromBlock)
          fromBlock = "0x0";
        this.params.fromBlock = fromBlock;
        const toBlock = minBlockRef(this.params.toBlock, currentBlock);
        const params = Object.assign({}, this.params, { toBlock });
        const newLogs = await this._fetchLogs(params);
        this.addInitialResults(newLogs);
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        let fromBlock;
        if (oldBlock) {
          fromBlock = incrementHexInt(oldBlock);
        } else {
          fromBlock = newBlock;
        }
        const params = Object.assign({}, this.params, { fromBlock, toBlock });
        const newLogs = await this._fetchLogs(params);
        const matchingLogs = newLogs.filter((log) => this.matchLog(log));
        this.addResults(matchingLogs);
      }
      async _fetchLogs(params) {
        const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
        return newLogs;
      }
      matchLog(log) {
        if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber))
          return false;
        if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber))
          return false;
        const normalizedLogAddress = log.address && log.address.toLowerCase();
        if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
          return false;
        const topicsMatch = this.params.topics.every((topicPattern, index) => {
          let logTopic = log.topics[index];
          if (!logTopic)
            return false;
          logTopic = logTopic.toLowerCase();
          let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
          const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
          if (subtopicsIncludeWildcard)
            return true;
          subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
          const topicDoesMatch = subtopicsToMatch.includes(logTopic);
          return topicDoesMatch;
        });
        return topicsMatch;
      }
    };
    module.exports = LogFilter;
  }
});

// node_modules/eth-json-rpc-filters/getBlocksForRange.js
var require_getBlocksForRange = __commonJS({
  "node_modules/eth-json-rpc-filters/getBlocksForRange.js"(exports, module) {
    module.exports = getBlocksForRange;
    async function getBlocksForRange({ provider, fromBlock, toBlock }) {
      if (!fromBlock)
        fromBlock = toBlock;
      const fromBlockNumber = hexToInt(fromBlock);
      const toBlockNumber = hexToInt(toBlock);
      const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
      const missingBlockNumbers = Array(blockCountToQuery).fill().map((_6, index) => fromBlockNumber + index).map(intToHex);
      const blockBodies = await Promise.all(
        missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false]))
      );
      return blockBodies;
    }
    function hexToInt(hexString) {
      if (hexString === void 0 || hexString === null)
        return hexString;
      return Number.parseInt(hexString, 16);
    }
    function intToHex(int) {
      if (int === void 0 || int === null)
        return int;
      const hexString = int.toString(16);
      return "0x" + hexString;
    }
    function sendAsync(provider, request) {
      return new Promise((resolve, reject) => {
        provider.sendAsync(request, (error, response) => {
          if (error) {
            reject(error);
          } else if (response.error) {
            reject(response.error);
          } else if (response.result) {
            resolve(response.result);
          } else {
            reject(new Error("Result was empty"));
          }
        });
      });
    }
    async function query(provider, method, params) {
      for (let i4 = 0; i4 < 3; i4++) {
        try {
          return await sendAsync(provider, {
            id: 1,
            jsonrpc: "2.0",
            method,
            params
          });
        } catch (error) {
          console.error(
            `provider.sendAsync failed: ${error.stack || error.message || error}`
          );
        }
      }
      throw new Error(`Block not found for params: ${JSON.stringify(params)}`);
    }
  }
});

// node_modules/eth-json-rpc-filters/block-filter.js
var require_block_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/block-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var BlockFilter = class extends BaseFilter {
      constructor({ provider, params }) {
        super();
        this.type = "block";
        this.provider = provider;
      }
      async update({ oldBlock, newBlock }) {
        const toBlock = newBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blockBodies = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockHashes = blockBodies.map((block) => block.hash);
        this.addResults(blockHashes);
      }
    };
    module.exports = BlockFilter;
  }
});

// node_modules/eth-json-rpc-filters/tx-filter.js
var require_tx_filter = __commonJS({
  "node_modules/eth-json-rpc-filters/tx-filter.js"(exports, module) {
    var BaseFilter = require_base_filter();
    var getBlocksForRange = require_getBlocksForRange();
    var { incrementHexInt } = require_hexUtils();
    var TxFilter = class extends BaseFilter {
      constructor({ provider }) {
        super();
        this.type = "tx";
        this.provider = provider;
      }
      async update({ oldBlock }) {
        const toBlock = oldBlock;
        const fromBlock = incrementHexInt(oldBlock);
        const blocks = await getBlocksForRange({ provider: this.provider, fromBlock, toBlock });
        const blockTxHashes = [];
        for (const block of blocks) {
          blockTxHashes.push(...block.transactions);
        }
        this.addResults(blockTxHashes);
      }
    };
    module.exports = TxFilter;
  }
});

// node_modules/eth-json-rpc-filters/index.js
var require_eth_json_rpc_filters = __commonJS({
  "node_modules/eth-json-rpc-filters/index.js"(exports, module) {
    var Mutex = require_lib2().Mutex;
    var { createAsyncMiddleware, createScaffoldMiddleware } = require_dist4();
    var LogFilter = require_log_filter();
    var BlockFilter = require_block_filter();
    var TxFilter = require_tx_filter();
    var { intToHex, hexToInt } = require_hexUtils();
    module.exports = createEthFilterMiddleware;
    function createEthFilterMiddleware({ blockTracker, provider }) {
      let filterIndex = 0;
      let filters = {};
      const mutex = new Mutex();
      const waitForFree = mutexMiddlewareWrapper({ mutex });
      const middleware = createScaffoldMiddleware({
        // install filters
        eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
        eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
        eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
        // uninstall filters
        eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
        // checking filter changes
        eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
        eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
      });
      const filterUpdater = async ({ oldBlock, newBlock }) => {
        if (filters.length === 0)
          return;
        const releaseLock = await mutex.acquire();
        try {
          await Promise.all(objValues(filters).map(async (filter2) => {
            try {
              await filter2.update({ oldBlock, newBlock });
            } catch (err) {
              console.error(err);
            }
          }));
        } catch (err) {
          console.error(err);
        }
        releaseLock();
      };
      middleware.newLogFilter = newLogFilter;
      middleware.newBlockFilter = newBlockFilter;
      middleware.newPendingTransactionFilter = newPendingTransactionFilter;
      middleware.uninstallFilter = uninstallFilterHandler;
      middleware.getFilterChanges = getFilterChanges;
      middleware.getFilterLogs = getFilterLogs;
      middleware.destroy = () => {
        uninstallAllFilters();
      };
      return middleware;
      async function newLogFilter(params) {
        const filter2 = new LogFilter({ provider, params });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newBlockFilter() {
        const filter2 = new BlockFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function newPendingTransactionFilter() {
        const filter2 = new TxFilter({ provider });
        const filterIndex2 = await installFilter(filter2);
        return filter2;
      }
      async function getFilterChanges(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        const results = filter2.getChangesAndClear();
        return results;
      }
      async function getFilterLogs(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        if (!filter2) {
          throw new Error(`No filter for index "${filterIndex2}"`);
        }
        let results = [];
        if (filter2.type === "log") {
          results = filter2.getAllResults();
        }
        return results;
      }
      async function uninstallFilterHandler(filterIndexHex) {
        const filterIndex2 = hexToInt(filterIndexHex);
        const filter2 = filters[filterIndex2];
        const result = Boolean(filter2);
        if (result) {
          await uninstallFilter(filterIndex2);
        }
        return result;
      }
      async function installFilter(filter2) {
        const prevFilterCount = objValues(filters).length;
        const currentBlock = await blockTracker.getLatestBlock();
        await filter2.initialize({ currentBlock });
        filterIndex++;
        filters[filterIndex] = filter2;
        filter2.id = filterIndex;
        filter2.idHex = intToHex(filterIndex);
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
        return filterIndex;
      }
      async function uninstallFilter(filterIndex2) {
        const prevFilterCount = objValues(filters).length;
        delete filters[filterIndex2];
        const newFilterCount = objValues(filters).length;
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
      }
      async function uninstallAllFilters() {
        const prevFilterCount = objValues(filters).length;
        filters = {};
        updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
      }
      function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
        if (prevFilterCount === 0 && newFilterCount > 0) {
          blockTracker.on("sync", filterUpdater);
          return;
        }
        if (prevFilterCount > 0 && newFilterCount === 0) {
          blockTracker.removeListener("sync", filterUpdater);
          return;
        }
      }
    }
    function toFilterCreationMiddleware(createFilterFn) {
      return toAsyncRpcMiddleware(async (...args) => {
        const filter2 = await createFilterFn(...args);
        const result = intToHex(filter2.id);
        return result;
      });
    }
    function toAsyncRpcMiddleware(asyncFn) {
      return createAsyncMiddleware(async (req, res) => {
        const result = await asyncFn.apply(null, req.params);
        res.result = result;
      });
    }
    function mutexMiddlewareWrapper({ mutex }) {
      return (middleware) => {
        return async (req, res, next, end) => {
          const releaseLock = await mutex.acquire();
          releaseLock();
          middleware(req, res, next, end);
        };
      };
    }
    function objValues(obj, fn2) {
      const values = [];
      for (let key2 in obj) {
        values.push(obj[key2]);
      }
      return values;
    }
  }
});

// node_modules/eth-json-rpc-filters/subscriptionManager.js
var require_subscriptionManager = __commonJS({
  "node_modules/eth-json-rpc-filters/subscriptionManager.js"(exports, module) {
    var SafeEventEmitter = require_safe_event_emitter().default;
    var { createAsyncMiddleware, createScaffoldMiddleware } = require_dist4();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var { unsafeRandomBytes, incrementHexInt } = require_hexUtils();
    var getBlocksForRange = require_getBlocksForRange();
    module.exports = createSubscriptionMiddleware;
    function createSubscriptionMiddleware({ blockTracker, provider }) {
      const subscriptions = {};
      const filterManager = createFilterMiddleware({ blockTracker, provider });
      let isDestroyed = false;
      const events = new SafeEventEmitter();
      const middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe2),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
      });
      middleware.destroy = destroy;
      return { events, middleware };
      async function subscribe2(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const subscriptionType = req.params[0];
        const subId = unsafeRandomBytes(16);
        let sub;
        switch (subscriptionType) {
          case "newHeads":
            sub = createSubNewHeads({ subId });
            break;
          case "logs":
            const filterParams = req.params[1];
            const filter2 = await filterManager.newLogFilter(filterParams);
            sub = createSubFromFilter({ subId, filter: filter2 });
            break;
          default:
            throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
        }
        subscriptions[subId] = sub;
        res.result = subId;
        return;
        function createSubNewHeads({ subId: subId2 }) {
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              blockTracker.removeListener("sync", sub2.update);
            },
            update: async ({ oldBlock, newBlock }) => {
              const toBlock = newBlock;
              const fromBlock = incrementHexInt(oldBlock);
              const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
              const results = rawBlocks.map(normalizeBlock).filter((block) => block !== null);
              results.forEach((value) => {
                _emitSubscriptionResult(subId2, value);
              });
            }
          };
          blockTracker.on("sync", sub2.update);
          return sub2;
        }
        function createSubFromFilter({ subId: subId2, filter: filter2 }) {
          filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
          const sub2 = {
            type: subscriptionType,
            destroy: async () => {
              return await filterManager.uninstallFilter(filter2.idHex);
            }
          };
          return sub2;
        }
      }
      async function unsubscribe(req, res) {
        if (isDestroyed)
          throw new Error(
            "SubscriptionManager - attempting to use after destroying"
          );
        const id2 = req.params[0];
        const subscription = subscriptions[id2];
        if (!subscription) {
          res.result = false;
          return;
        }
        delete subscriptions[id2];
        await subscription.destroy();
        res.result = true;
      }
      function _emitSubscriptionResult(filterIdHex, value) {
        events.emit("notification", {
          jsonrpc: "2.0",
          method: "eth_subscription",
          params: {
            subscription: filterIdHex,
            result: value
          }
        });
      }
      function destroy() {
        events.removeAllListeners();
        for (const id2 in subscriptions) {
          subscriptions[id2].destroy();
          delete subscriptions[id2];
        }
        isDestroyed = true;
      }
    }
    function normalizeBlock(block) {
      if (block === null || block === void 0) {
        return null;
      }
      return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
      };
    }
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js
var require_SubscriptionManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/SubscriptionManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionManager = void 0;
    var eth_block_tracker_1 = require_dist3();
    var createSubscriptionManager = require_subscriptionManager();
    var noop2 = () => {
    };
    var SubscriptionManager = class {
      constructor(provider) {
        const blockTracker = new eth_block_tracker_1.PollingBlockTracker({
          provider,
          pollingInterval: 15 * 1e3,
          setSkipCacheFlag: true
        });
        const { events, middleware } = createSubscriptionManager({
          blockTracker,
          provider
        });
        this.events = events;
        this.subscriptionMiddleware = middleware;
      }
      async handleRequest(request) {
        const result = {};
        await this.subscriptionMiddleware(request, result, noop2, noop2);
        return result;
      }
      destroy() {
        this.subscriptionMiddleware.destroy();
      }
    };
    exports.SubscriptionManager = SubscriptionManager;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js
var require_CoinbaseWalletProvider = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/CoinbaseWalletProvider.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletProvider = void 0;
    var safe_event_emitter_1 = __importDefault3(require_safe_event_emitter());
    var bn_js_1 = __importDefault3(require_bn());
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var errors_1 = require_errors2();
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3Response_1 = require_Web3Response();
    var util_1 = require_util2();
    var eth_eip712_util_1 = __importDefault3(require_eth_eip712_util());
    var FilterPolyfill_1 = require_FilterPolyfill();
    var JSONRPC_1 = require_JSONRPC();
    var SubscriptionManager_1 = require_SubscriptionManager();
    var DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
    var DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
    var CoinbaseWalletProvider = class extends safe_event_emitter_1.default {
      constructor(options) {
        var _a2, _b;
        super();
        this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
        this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
        this._relay = null;
        this._addresses = [];
        this.hasMadeFirstChainChangedEmission = false;
        this.setProviderInfo = this.setProviderInfo.bind(this);
        this.updateProviderInfo = this.updateProviderInfo.bind(this);
        this.getChainId = this.getChainId.bind(this);
        this.setAppInfo = this.setAppInfo.bind(this);
        this.enable = this.enable.bind(this);
        this.close = this.close.bind(this);
        this.send = this.send.bind(this);
        this.sendAsync = this.sendAsync.bind(this);
        this.request = this.request.bind(this);
        this._setAddresses = this._setAddresses.bind(this);
        this.scanQRCode = this.scanQRCode.bind(this);
        this.genericRequest = this.genericRequest.bind(this);
        this._chainIdFromOpts = options.chainId;
        this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
        this._overrideIsMetaMask = options.overrideIsMetaMask;
        this._relayProvider = options.relayProvider;
        this._storage = options.storage;
        this._relayEventManager = options.relayEventManager;
        this.diagnostic = options.diagnosticLogger;
        this.reloadOnDisconnect = true;
        this.isCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
        this.isCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        this.qrUrl = options.qrUrl;
        const chainId = this.getChainId();
        const chainIdStr = (0, util_1.prepend0x)(chainId.toString(16));
        this.emit("connect", { chainIdStr });
        const cachedAddresses = this._storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
        if (cachedAddresses) {
          const addresses = cachedAddresses.split(" ");
          if (addresses[0] !== "") {
            this._addresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
            this.emit("accountsChanged", addresses);
          }
        }
        this._subscriptionManager.events.on("notification", (notification) => {
          this.emit("message", {
            type: notification.method,
            data: notification.params
          });
        });
        if (this._isAuthorized()) {
          void this.initializeRelay();
        }
        window.addEventListener("message", (event) => {
          var _a3;
          if (event.origin !== location.origin || event.source !== window) {
            return;
          }
          if (event.data.type !== "walletLinkMessage")
            return;
          if (event.data.data.action === "dappChainSwitched") {
            const _chainId = event.data.data.chainId;
            const jsonRpcUrl = (_a3 = event.data.data.jsonRpcUrl) !== null && _a3 !== void 0 ? _a3 : this.jsonRpcUrl;
            this.updateProviderInfo(jsonRpcUrl, Number(_chainId));
          }
          if (event.data.data.action === "addressChanged") {
            this._setAddresses([event.data.data.address]);
          }
        });
      }
      /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
      get selectedAddress() {
        return this._addresses[0] || void 0;
      }
      /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
      get networkVersion() {
        return this.getChainId().toString(10);
      }
      /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
      get chainId() {
        return (0, util_1.prepend0x)(this.getChainId().toString(16));
      }
      get isWalletLink() {
        return true;
      }
      /**
       * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
       * true for this method.
       */
      get isMetaMask() {
        return this._overrideIsMetaMask;
      }
      get host() {
        return this.jsonRpcUrl;
      }
      get connected() {
        return true;
      }
      isConnected() {
        return true;
      }
      get jsonRpcUrl() {
        var _a2;
        return (_a2 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a2 !== void 0 ? _a2 : this._jsonRpcUrlFromOpts;
      }
      set jsonRpcUrl(value) {
        this._storage.setItem(DEFAULT_JSON_RPC_URL, value);
      }
      disableReloadOnDisconnect() {
        this.reloadOnDisconnect = false;
      }
      setProviderInfo(jsonRpcUrl, chainId) {
        if (!this.isCoinbaseBrowser) {
          this._chainIdFromOpts = chainId;
          this._jsonRpcUrlFromOpts = jsonRpcUrl;
        }
        this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
      }
      updateProviderInfo(jsonRpcUrl, chainId) {
        this.jsonRpcUrl = jsonRpcUrl;
        const originalChainId = this.getChainId();
        this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
        const chainChanged = (0, util_1.ensureIntNumber)(chainId) !== originalChainId;
        if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
          this.emit("chainChanged", this.getChainId());
          this.hasMadeFirstChainChangedEmission = true;
        }
      }
      async watchAsset(type2, address, symbol, decimals, image, chainId) {
        const relay = await this.initializeRelay();
        const result = await relay.watchAsset(type2, address, symbol, decimals, image, chainId === null || chainId === void 0 ? void 0 : chainId.toString()).promise;
        return !!result.result;
      }
      async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        var _a2, _b;
        if ((0, util_1.ensureIntNumber)(chainId) === this.getChainId()) {
          return false;
        }
        const relay = await this.initializeRelay();
        const isWhitelistedNetworkOrStandalone = relay.inlineAddEthereumChain(chainId.toString());
        if (!this._isAuthorized() && !isWhitelistedNetworkOrStandalone) {
          await relay.requestEthereumAccounts().promise;
        }
        const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
        if (((_a2 = res.result) === null || _a2 === void 0 ? void 0 : _a2.isApproved) === true) {
          this.updateProviderInfo(rpcUrls[0], chainId);
        }
        return ((_b = res.result) === null || _b === void 0 ? void 0 : _b.isApproved) === true;
      }
      async switchEthereumChain(chainId) {
        const relay = await this.initializeRelay();
        const res = await relay.switchEthereumChain(chainId.toString(10), this.selectedAddress || void 0).promise;
        if ((0, Web3Response_1.isErrorResponse)(res) && res.errorCode) {
          if (res.errorCode === errors_1.standardErrorCodes.provider.unsupportedChain) {
            throw errors_1.standardErrors.provider.unsupportedChain(chainId);
          } else {
            throw errors_1.standardErrors.provider.custom({
              message: res.errorMessage,
              code: res.errorCode
            });
          }
        }
        const switchResponse = res.result;
        if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
          this.updateProviderInfo(switchResponse.rpcUrl, chainId);
        }
      }
      setAppInfo(appName, appLogoUrl) {
        void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
      }
      /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
      async enable() {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::enable",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : void 0
        });
        if (this._isAuthorized()) {
          return [...this._addresses];
        }
        return await this.send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
      }
      async close() {
        const relay = await this.initializeRelay();
        relay.resetAndReload();
      }
      send(requestOrMethod, callbackOrParams) {
        try {
          const result = this._send(requestOrMethod, callbackOrParams);
          if (result instanceof Promise) {
            return result.catch((error) => {
              throw (0, errors_1.serializeError)(error, requestOrMethod);
            });
          }
        } catch (error) {
          throw (0, errors_1.serializeError)(error, requestOrMethod);
        }
      }
      _send(requestOrMethod, callbackOrParams) {
        if (typeof requestOrMethod === "string") {
          const method = requestOrMethod;
          const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
          const request = {
            jsonrpc: "2.0",
            id: 0,
            method,
            params
          };
          return this._sendRequestAsync(request).then((res) => res.result);
        }
        if (typeof callbackOrParams === "function") {
          const request = requestOrMethod;
          const callback = callbackOrParams;
          return this._sendAsync(request, callback);
        }
        if (Array.isArray(requestOrMethod)) {
          const requests = requestOrMethod;
          return requests.map((r5) => this._sendRequest(r5));
        }
        const req = requestOrMethod;
        return this._sendRequest(req);
      }
      async sendAsync(request, callback) {
        try {
          return this._sendAsync(request, callback).catch((error) => {
            throw (0, errors_1.serializeError)(error, request);
          });
        } catch (error) {
          return Promise.reject((0, errors_1.serializeError)(error, request));
        }
      }
      async _sendAsync(request, callback) {
        if (typeof callback !== "function") {
          throw new Error("callback is required");
        }
        if (Array.isArray(request)) {
          const arrayCb = callback;
          this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
          return;
        }
        const cb = callback;
        return this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
      }
      async request(args) {
        try {
          return this._request(args).catch((error) => {
            throw (0, errors_1.serializeError)(error, args.method);
          });
        } catch (error) {
          return Promise.reject((0, errors_1.serializeError)(error, args.method));
        }
      }
      async _request(args) {
        if (!args || typeof args !== "object" || Array.isArray(args)) {
          throw errors_1.standardErrors.rpc.invalidRequest({
            message: "Expected a single, non-array, object argument.",
            data: args
          });
        }
        const { method, params } = args;
        if (typeof method !== "string" || method.length === 0) {
          throw errors_1.standardErrors.rpc.invalidRequest({
            message: "'args.method' must be a non-empty string.",
            data: args
          });
        }
        if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
          throw errors_1.standardErrors.rpc.invalidRequest({
            message: "'args.params' must be an object or array if provided.",
            data: args
          });
        }
        const newParams = params === void 0 ? [] : params;
        const id2 = this._relayEventManager.makeRequestId();
        const result = await this._sendRequestAsync({
          method,
          params: newParams,
          jsonrpc: "2.0",
          id: id2
        });
        return result.result;
      }
      async scanQRCode(match) {
        var _a2;
        const relay = await this.initializeRelay();
        const res = await relay.scanQRCode((0, util_1.ensureRegExpString)(match)).promise;
        if (typeof res.result !== "string") {
          throw (0, errors_1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1.Web3Method.scanQRCode);
        }
        return res.result;
      }
      async genericRequest(data3, action) {
        var _a2;
        const relay = await this.initializeRelay();
        const res = await relay.genericRequest(data3, action).promise;
        if (typeof res.result !== "string") {
          throw (0, errors_1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1.Web3Method.generic);
        }
        return res.result;
      }
      async selectProvider(providerOptions) {
        var _a2;
        const relay = await this.initializeRelay();
        const res = await relay.selectProvider(providerOptions).promise;
        if (typeof res.result !== "string") {
          throw (0, errors_1.serializeError)((_a2 = res.errorMessage) !== null && _a2 !== void 0 ? _a2 : "result was not a string", Web3Method_1.Web3Method.selectProvider);
        }
        return res.result;
      }
      supportsSubscriptions() {
        return false;
      }
      subscribe() {
        throw new Error("Subscriptions are not supported");
      }
      unsubscribe() {
        throw new Error("Subscriptions are not supported");
      }
      disconnect() {
        return true;
      }
      _sendRequest(request) {
        const response = {
          jsonrpc: "2.0",
          id: request.id
        };
        const { method } = request;
        response.result = this._handleSynchronousMethods(request);
        if (response.result === void 0) {
          throw new Error(`Coinbase Wallet does not support calling ${method} synchronously without a callback. Please provide a callback parameter to call ${method} asynchronously.`);
        }
        return response;
      }
      _setAddresses(addresses, _6) {
        if (!Array.isArray(addresses)) {
          throw new Error("addresses is not an array");
        }
        const newAddresses = addresses.map((address) => (0, util_1.ensureAddressString)(address));
        if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
          return;
        }
        this._addresses = newAddresses;
        this.emit("accountsChanged", this._addresses);
        this._storage.setItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
      }
      _sendRequestAsync(request) {
        return new Promise((resolve, reject) => {
          try {
            const syncResult = this._handleSynchronousMethods(request);
            if (syncResult !== void 0) {
              return resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: syncResult
              });
            }
            const filterPromise = this._handleAsynchronousFilterMethods(request);
            if (filterPromise !== void 0) {
              filterPromise.then((res) => resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
              return;
            }
            const subscriptionPromise = this._handleSubscriptionMethods(request);
            if (subscriptionPromise !== void 0) {
              subscriptionPromise.then((res) => resolve({
                jsonrpc: "2.0",
                id: request.id,
                result: res.result
              })).catch((err) => reject(err));
              return;
            }
          } catch (err) {
            return reject(err);
          }
          this._handleAsynchronousMethods(request).then((res) => res && resolve(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
        });
      }
      _sendMultipleRequestsAsync(requests) {
        return Promise.all(requests.map((r5) => this._sendRequestAsync(r5)));
      }
      _handleSynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_accounts:
            return this._eth_accounts();
          case JSONRPC_1.JSONRPCMethod.eth_coinbase:
            return this._eth_coinbase();
          case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
            return this._eth_uninstallFilter(params);
          case JSONRPC_1.JSONRPCMethod.net_version:
            return this._net_version();
          case JSONRPC_1.JSONRPCMethod.eth_chainId:
            return this._eth_chainId();
          default:
            return void 0;
        }
      }
      async _handleAsynchronousMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
            return this._eth_requestAccounts();
          case JSONRPC_1.JSONRPCMethod.eth_sign:
            return this._eth_sign(params);
          case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
            return this._eth_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.personal_sign:
            return this._personal_sign(params);
          case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
            return this._personal_ecRecover(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
            return this._eth_signTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
            return this._eth_sendRawTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
            return this._eth_sendTransaction(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
            return this._eth_signTypedData_v1(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
            return this._throwUnsupportedMethodError();
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
            return this._eth_signTypedData_v3(params);
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
          case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
            return this._eth_signTypedData_v4(params);
          case JSONRPC_1.JSONRPCMethod.cbWallet_arbitrary:
            return this._cbwallet_arbitrary(params);
          case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
            return this._wallet_addEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
            return this._wallet_switchEthereumChain(params);
          case JSONRPC_1.JSONRPCMethod.wallet_watchAsset:
            return this._wallet_watchAsset(params);
        }
        const relay = await this.initializeRelay();
        return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
      }
      _handleAsynchronousFilterMethods(request) {
        const { method } = request;
        const params = request.params || [];
        switch (method) {
          case JSONRPC_1.JSONRPCMethod.eth_newFilter:
            return this._eth_newFilter(params);
          case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
            return this._eth_newBlockFilter();
          case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
            return this._eth_newPendingTransactionFilter();
          case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
            return this._eth_getFilterChanges(params);
          case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
            return this._eth_getFilterLogs(params);
        }
        return void 0;
      }
      _handleSubscriptionMethods(request) {
        switch (request.method) {
          case JSONRPC_1.JSONRPCMethod.eth_subscribe:
          case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
            return this._subscriptionManager.handleRequest(request);
        }
        return void 0;
      }
      _isKnownAddress(addressString) {
        try {
          const addressStr = (0, util_1.ensureAddressString)(addressString);
          const lowercaseAddresses = this._addresses.map((address) => (0, util_1.ensureAddressString)(address));
          return lowercaseAddresses.includes(addressStr);
        } catch (_a2) {
        }
        return false;
      }
      _ensureKnownAddress(addressString) {
        var _a2;
        if (!this._isKnownAddress(addressString)) {
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED);
          throw new Error("Unknown Ethereum address");
        }
      }
      _prepareTransactionParams(tx) {
        const fromAddress = tx.from ? (0, util_1.ensureAddressString)(tx.from) : this.selectedAddress;
        if (!fromAddress) {
          throw new Error("Ethereum address is unavailable");
        }
        this._ensureKnownAddress(fromAddress);
        const toAddress = tx.to ? (0, util_1.ensureAddressString)(tx.to) : null;
        const weiValue = tx.value != null ? (0, util_1.ensureBN)(tx.value) : new bn_js_1.default(0);
        const data3 = tx.data ? (0, util_1.ensureBuffer)(tx.data) : Buffer.alloc(0);
        const nonce = tx.nonce != null ? (0, util_1.ensureIntNumber)(tx.nonce) : null;
        const gasPriceInWei = tx.gasPrice != null ? (0, util_1.ensureBN)(tx.gasPrice) : null;
        const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1.ensureBN)(tx.maxFeePerGas) : null;
        const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1.ensureBN)(tx.maxPriorityFeePerGas) : null;
        const gasLimit = tx.gas != null ? (0, util_1.ensureBN)(tx.gas) : null;
        const chainId = this.getChainId();
        return {
          fromAddress,
          toAddress,
          weiValue,
          data: data3,
          nonce,
          gasPriceInWei,
          maxFeePerGas,
          maxPriorityFeePerGas,
          gasLimit,
          chainId
        };
      }
      _isAuthorized() {
        return this._addresses.length > 0;
      }
      _requireAuthorization() {
        if (!this._isAuthorized()) {
          throw errors_1.standardErrors.provider.unauthorized({});
        }
      }
      _throwUnsupportedMethodError() {
        throw errors_1.standardErrors.provider.unsupportedMethod({});
      }
      async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
        this._ensureKnownAddress(address);
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw errors_1.standardErrors.provider.userRejectedRequest("User denied message signature");
          }
          throw err;
        }
      }
      async _ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
        const relay = await this.initializeRelay();
        const res = await relay.ethereumAddressFromSignedMessage(message, signature2, addPrefix).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      _eth_accounts() {
        return [...this._addresses];
      }
      _eth_coinbase() {
        return this.selectedAddress || null;
      }
      _net_version() {
        return this.getChainId().toString(10);
      }
      _eth_chainId() {
        return (0, util_1.hexStringFromIntNumber)(this.getChainId());
      }
      getChainId() {
        const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY);
        if (!chainIdStr) {
          return (0, util_1.ensureIntNumber)(this._chainIdFromOpts);
        }
        const chainId = parseInt(chainIdStr, 10);
        return (0, util_1.ensureIntNumber)(chainId);
      }
      async _eth_requestAccounts() {
        var _a2;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.ETH_ACCOUNTS_STATE, {
          method: "provider::_eth_requestAccounts",
          addresses_length: this._addresses.length,
          sessionIdHash: this._relay ? Session_1.Session.hash(this._relay.session.id) : void 0
        });
        if (this._isAuthorized()) {
          return Promise.resolve({
            jsonrpc: "2.0",
            id: 0,
            result: this._addresses
          });
        }
        let res;
        try {
          const relay = await this.initializeRelay();
          res = await relay.requestEthereumAccounts().promise;
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw errors_1.standardErrors.provider.userRejectedRequest("User denied account authorization");
          }
          throw err;
        }
        if (!res.result) {
          throw new Error("accounts received is empty");
        }
        this._setAddresses(res.result);
        if (!this.isCoinbaseBrowser) {
          await this.switchEthereumChain(this.getChainId());
        }
        return { jsonrpc: "2.0", id: 0, result: this._addresses };
      }
      _eth_sign(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const message = (0, util_1.ensureBuffer)(params[1]);
        return this._signEthereumMessage(message, address, false);
      }
      _eth_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature2 = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature2, false);
      }
      _personal_sign(params) {
        this._requireAuthorization();
        const message = (0, util_1.ensureBuffer)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        return this._signEthereumMessage(message, address, true);
      }
      _personal_ecRecover(params) {
        const message = (0, util_1.ensureBuffer)(params[0]);
        const signature2 = (0, util_1.ensureBuffer)(params[1]);
        return this._ethereumAddressFromSignedMessage(message, signature2, true);
      }
      async _eth_signTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw errors_1.standardErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_sendRawTransaction(params) {
        const signedTransaction = (0, util_1.ensureBuffer)(params[0]);
        const relay = await this.initializeRelay();
        const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
        return { jsonrpc: "2.0", id: 0, result: res.result };
      }
      async _eth_sendTransaction(params) {
        this._requireAuthorization();
        const tx = this._prepareTransactionParams(params[0] || {});
        try {
          const relay = await this.initializeRelay();
          const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
          return { jsonrpc: "2.0", id: 0, result: res.result };
        } catch (err) {
          if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
            throw errors_1.standardErrors.provider.userRejectedRequest("User denied transaction signature");
          }
          throw err;
        }
      }
      async _eth_signTypedData_v1(params) {
        this._requireAuthorization();
        const typedData = (0, util_1.ensureParsedJSONObject)(params[0]);
        const address = (0, util_1.ensureAddressString)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v3(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      async _eth_signTypedData_v4(params) {
        this._requireAuthorization();
        const address = (0, util_1.ensureAddressString)(params[0]);
        const typedData = (0, util_1.ensureParsedJSONObject)(params[1]);
        this._ensureKnownAddress(address);
        const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
        const typedDataJSON = JSON.stringify(typedData, null, 2);
        return this._signEthereumMessage(message, address, false, typedDataJSON);
      }
      /** @deprecated */
      async _cbwallet_arbitrary(params) {
        const action = params[0];
        const data3 = params[1];
        if (typeof data3 !== "string") {
          throw new Error("parameter must be a string");
        }
        if (typeof action !== "object" || action === null) {
          throw new Error("parameter must be an object");
        }
        const result = await this.genericRequest(action, data3);
        return { jsonrpc: "2.0", id: 0, result };
      }
      async _wallet_addEthereumChain(params) {
        var _a2, _b, _c, _d;
        const request = params[0];
        if (((_a2 = request.rpcUrls) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `please pass in at least 1 rpcUrl` }
          };
        }
        if (!request.chainName || request.chainName.trim() === "") {
          throw errors_1.standardErrors.rpc.invalidParams("chainName is a required field");
        }
        if (!request.nativeCurrency) {
          throw errors_1.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
        }
        const chainIdNumber = parseInt(request.chainId, 16);
        const success = await this.addEthereumChain(chainIdNumber, (_b = request.rpcUrls) !== null && _b !== void 0 ? _b : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
        if (success) {
          return { jsonrpc: "2.0", id: 0, result: null };
        } else {
          return {
            jsonrpc: "2.0",
            id: 0,
            error: { code: 2, message: `unable to add ethereum chain` }
          };
        }
      }
      async _wallet_switchEthereumChain(params) {
        const request = params[0];
        await this.switchEthereumChain(parseInt(request.chainId, 16));
        return { jsonrpc: "2.0", id: 0, result: null };
      }
      async _wallet_watchAsset(params) {
        const request = Array.isArray(params) ? params[0] : params;
        if (!request.type) {
          throw errors_1.standardErrors.rpc.invalidParams("Type is required");
        }
        if ((request === null || request === void 0 ? void 0 : request.type) !== "ERC20") {
          throw errors_1.standardErrors.rpc.invalidParams(`Asset of type '${request.type}' is not supported`);
        }
        if (!(request === null || request === void 0 ? void 0 : request.options)) {
          throw errors_1.standardErrors.rpc.invalidParams("Options are required");
        }
        if (!(request === null || request === void 0 ? void 0 : request.options.address)) {
          throw errors_1.standardErrors.rpc.invalidParams("Address is required");
        }
        const chainId = this.getChainId();
        const { address, symbol, image, decimals } = request.options;
        const res = await this.watchAsset(request.type, address, symbol, decimals, image, chainId);
        return { jsonrpc: "2.0", id: 0, result: res };
      }
      _eth_uninstallFilter(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.uninstallFilter(filterId);
      }
      async _eth_newFilter(params) {
        const param = params[0];
        const filterId = await this._filterPolyfill.newFilter(param);
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newBlockFilter() {
        const filterId = await this._filterPolyfill.newBlockFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      async _eth_newPendingTransactionFilter() {
        const filterId = await this._filterPolyfill.newPendingTransactionFilter();
        return { jsonrpc: "2.0", id: 0, result: filterId };
      }
      _eth_getFilterChanges(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterChanges(filterId);
      }
      _eth_getFilterLogs(params) {
        const filterId = (0, util_1.ensureHexString)(params[0]);
        return this._filterPolyfill.getFilterLogs(filterId);
      }
      initializeRelay() {
        if (this._relay) {
          return Promise.resolve(this._relay);
        }
        return this._relayProvider().then((relay) => {
          relay.setAccountsCallback((accounts, isDisconnect) => this._setAddresses(accounts, isDisconnect));
          relay.setChainCallback((chainId, jsonRpcUrl) => {
            this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10));
          });
          relay.setDappDefaultChainCallback(this._chainIdFromOpts);
          this._relay = relay;
          return relay;
        });
      }
    };
    exports.CoinbaseWalletProvider = CoinbaseWalletProvider;
  }
});

// node_modules/preact/dist/preact.module.js
var preact_module_exports = {};
__export(preact_module_exports, {
  Component: () => b4,
  Fragment: () => g5,
  cloneElement: () => E5,
  createContext: () => F4,
  createElement: () => y5,
  createRef: () => _4,
  h: () => y5,
  hydrate: () => B3,
  isValidElement: () => t,
  options: () => l2,
  render: () => q3,
  toChildArray: () => $3
});
function v3(n3, l4) {
  for (var u5 in l4)
    n3[u5] = l4[u5];
  return n3;
}
function p4(n3) {
  var l4 = n3.parentNode;
  l4 && l4.removeChild(n3);
}
function y5(l4, u5, t3) {
  var i4, o3, r5, f5 = {};
  for (r5 in u5)
    "key" == r5 ? i4 = u5[r5] : "ref" == r5 ? o3 = u5[r5] : f5[r5] = u5[r5];
  if (arguments.length > 2 && (f5.children = arguments.length > 3 ? n2.call(arguments, 2) : t3), "function" == typeof l4 && null != l4.defaultProps)
    for (r5 in l4.defaultProps)
      void 0 === f5[r5] && (f5[r5] = l4.defaultProps[r5]);
  return d2(l4, f5, i4, o3, null);
}
function d2(n3, t3, i4, o3, r5) {
  var f5 = { type: n3, props: t3, key: i4, ref: o3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r5 ? ++u3 : r5, __i: -1, __u: 0 };
  return null == r5 && null != l2.vnode && l2.vnode(f5), f5;
}
function _4() {
  return { current: null };
}
function g5(n3) {
  return n3.children;
}
function b4(n3, l4) {
  this.props = n3, this.context = l4;
}
function m3(n3, l4) {
  if (null == l4)
    return n3.__ ? m3(n3.__, n3.__i + 1) : null;
  for (var u5; l4 < n3.__k.length; l4++)
    if (null != (u5 = n3.__k[l4]) && null != u5.__e)
      return u5.__e;
  return "function" == typeof n3.type ? m3(n3) : null;
}
function k3(n3) {
  var l4, u5;
  if (null != (n3 = n3.__) && null != n3.__c) {
    for (n3.__e = n3.__c.base = null, l4 = 0; l4 < n3.__k.length; l4++)
      if (null != (u5 = n3.__k[l4]) && null != u5.__e) {
        n3.__e = n3.__c.base = u5.__e;
        break;
      }
    return k3(n3);
  }
}
function w3(n3) {
  (!n3.__d && (n3.__d = true) && i2.push(n3) && !x3.__r++ || o !== l2.debounceRendering) && ((o = l2.debounceRendering) || r2)(x3);
}
function x3() {
  var n3, u5, t3, o3, r5, e3, c5, s3, a4;
  for (i2.sort(f3); n3 = i2.shift(); )
    n3.__d && (u5 = i2.length, o3 = void 0, e3 = (r5 = (t3 = n3).__v).__e, s3 = [], a4 = [], (c5 = t3.__P) && ((o3 = v3({}, r5)).__v = r5.__v + 1, l2.vnode && l2.vnode(o3), L3(c5, o3, r5, t3.__n, void 0 !== c5.ownerSVGElement, 32 & r5.__u ? [e3] : null, s3, null == e3 ? m3(r5) : e3, !!(32 & r5.__u), a4), o3.__.__k[o3.__i] = o3, M4(s3, o3, a4), o3.__e != e3 && k3(o3)), i2.length > u5 && i2.sort(f3));
  x3.__r = 0;
}
function C(n3, l4, u5, t3, i4, o3, r5, f5, e3, a4, h6) {
  var v5, p6, y7, d4, _6, g7 = t3 && t3.__k || s, b6 = l4.length;
  for (u5.__d = e3, P2(u5, l4, g7), e3 = u5.__d, v5 = 0; v5 < b6; v5++)
    null != (y7 = u5.__k[v5]) && "boolean" != typeof y7 && "function" != typeof y7 && (p6 = -1 === y7.__i ? c3 : g7[y7.__i] || c3, y7.__i = v5, L3(n3, y7, p6, i4, o3, r5, f5, e3, a4, h6), d4 = y7.__e, y7.ref && p6.ref != y7.ref && (p6.ref && z3(p6.ref, null, y7), h6.push(y7.ref, y7.__c || d4, y7)), null == _6 && null != d4 && (_6 = d4), 65536 & y7.__u || p6.__k === y7.__k ? e3 = S4(y7, e3, n3) : "function" == typeof y7.type && void 0 !== y7.__d ? e3 = y7.__d : d4 && (e3 = d4.nextSibling), y7.__d = void 0, y7.__u &= -196609);
  u5.__d = e3, u5.__e = _6;
}
function P2(n3, l4, u5) {
  var t3, i4, o3, r5, f5, e3 = l4.length, c5 = u5.length, s3 = c5, a4 = 0;
  for (n3.__k = [], t3 = 0; t3 < e3; t3++)
    null != (i4 = n3.__k[t3] = null == (i4 = l4[t3]) || "boolean" == typeof i4 || "function" == typeof i4 ? null : "string" == typeof i4 || "number" == typeof i4 || "bigint" == typeof i4 || i4.constructor == String ? d2(null, i4, null, null, i4) : h4(i4) ? d2(g5, { children: i4 }, null, null, null) : i4.__b > 0 ? d2(i4.type, i4.props, i4.key, i4.ref ? i4.ref : null, i4.__v) : i4) ? (i4.__ = n3, i4.__b = n3.__b + 1, f5 = H2(i4, u5, r5 = t3 + a4, s3), i4.__i = f5, o3 = null, -1 !== f5 && (s3--, (o3 = u5[f5]) && (o3.__u |= 131072)), null == o3 || null === o3.__v ? (-1 == f5 && a4--, "function" != typeof i4.type && (i4.__u |= 65536)) : f5 !== r5 && (f5 === r5 + 1 ? a4++ : f5 > r5 ? s3 > e3 - r5 ? a4 += f5 - r5 : a4-- : a4 = f5 < r5 && f5 == r5 - 1 ? f5 - r5 : 0, f5 !== t3 + a4 && (i4.__u |= 65536))) : (o3 = u5[t3]) && null == o3.key && o3.__e && (o3.__e == n3.__d && (n3.__d = m3(o3)), N14(o3, o3, false), u5[t3] = null, s3--);
  if (s3)
    for (t3 = 0; t3 < c5; t3++)
      null != (o3 = u5[t3]) && 0 == (131072 & o3.__u) && (o3.__e == n3.__d && (n3.__d = m3(o3)), N14(o3, o3));
}
function S4(n3, l4, u5) {
  var t3, i4;
  if ("function" == typeof n3.type) {
    for (t3 = n3.__k, i4 = 0; t3 && i4 < t3.length; i4++)
      t3[i4] && (t3[i4].__ = n3, l4 = S4(t3[i4], l4, u5));
    return l4;
  }
  return n3.__e != l4 && (u5.insertBefore(n3.__e, l4 || null), l4 = n3.__e), l4 && l4.nextSibling;
}
function $3(n3, l4) {
  return l4 = l4 || [], null == n3 || "boolean" == typeof n3 || (h4(n3) ? n3.some(function(n4) {
    $3(n4, l4);
  }) : l4.push(n3)), l4;
}
function H2(n3, l4, u5, t3) {
  var i4 = n3.key, o3 = n3.type, r5 = u5 - 1, f5 = u5 + 1, e3 = l4[u5];
  if (null === e3 || e3 && i4 == e3.key && o3 === e3.type)
    return u5;
  if (t3 > (null != e3 && 0 == (131072 & e3.__u) ? 1 : 0))
    for (; r5 >= 0 || f5 < l4.length; ) {
      if (r5 >= 0) {
        if ((e3 = l4[r5]) && 0 == (131072 & e3.__u) && i4 == e3.key && o3 === e3.type)
          return r5;
        r5--;
      }
      if (f5 < l4.length) {
        if ((e3 = l4[f5]) && 0 == (131072 & e3.__u) && i4 == e3.key && o3 === e3.type)
          return f5;
        f5++;
      }
    }
  return -1;
}
function I2(n3, l4, u5) {
  "-" === l4[0] ? n3.setProperty(l4, null == u5 ? "" : u5) : n3[l4] = null == u5 ? "" : "number" != typeof u5 || a2.test(l4) ? u5 : u5 + "px";
}
function T2(n3, l4, u5, t3, i4) {
  var o3;
  n:
    if ("style" === l4)
      if ("string" == typeof u5)
        n3.style.cssText = u5;
      else {
        if ("string" == typeof t3 && (n3.style.cssText = t3 = ""), t3)
          for (l4 in t3)
            u5 && l4 in u5 || I2(n3.style, l4, "");
        if (u5)
          for (l4 in u5)
            t3 && u5[l4] === t3[l4] || I2(n3.style, l4, u5[l4]);
      }
    else if ("o" === l4[0] && "n" === l4[1])
      o3 = l4 !== (l4 = l4.replace(/(PointerCapture)$|Capture$/, "$1")), l4 = l4.toLowerCase() in n3 ? l4.toLowerCase().slice(2) : l4.slice(2), n3.l || (n3.l = {}), n3.l[l4 + o3] = u5, u5 ? t3 ? u5.u = t3.u : (u5.u = Date.now(), n3.addEventListener(l4, o3 ? D5 : A3, o3)) : n3.removeEventListener(l4, o3 ? D5 : A3, o3);
    else {
      if (i4)
        l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l4 && "height" !== l4 && "href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && "rowSpan" !== l4 && "colSpan" !== l4 && "role" !== l4 && l4 in n3)
        try {
          n3[l4] = null == u5 ? "" : u5;
          break n;
        } catch (n4) {
        }
      "function" == typeof u5 || (null == u5 || false === u5 && "-" !== l4[4] ? n3.removeAttribute(l4) : n3.setAttribute(l4, u5));
    }
}
function A3(n3) {
  var u5 = this.l[n3.type + false];
  if (n3.t) {
    if (n3.t <= u5.u)
      return;
  } else
    n3.t = Date.now();
  return u5(l2.event ? l2.event(n3) : n3);
}
function D5(n3) {
  return this.l[n3.type + true](l2.event ? l2.event(n3) : n3);
}
function L3(n3, u5, t3, i4, o3, r5, f5, e3, c5, s3) {
  var a4, p6, y7, d4, _6, m5, k5, w5, x5, P4, S5, $4, H3, I3, T4, A5 = u5.type;
  if (void 0 !== u5.constructor)
    return null;
  128 & t3.__u && (c5 = !!(32 & t3.__u), r5 = [e3 = u5.__e = t3.__e]), (a4 = l2.__b) && a4(u5);
  n:
    if ("function" == typeof A5)
      try {
        if (w5 = u5.props, x5 = (a4 = A5.contextType) && i4[a4.__c], P4 = a4 ? x5 ? x5.props.value : a4.__ : i4, t3.__c ? k5 = (p6 = u5.__c = t3.__c).__ = p6.__E : ("prototype" in A5 && A5.prototype.render ? u5.__c = p6 = new A5(w5, P4) : (u5.__c = p6 = new b4(w5, P4), p6.constructor = A5, p6.render = O6), x5 && x5.sub(p6), p6.props = w5, p6.state || (p6.state = {}), p6.context = P4, p6.__n = i4, y7 = p6.__d = true, p6.__h = [], p6._sb = []), null == p6.__s && (p6.__s = p6.state), null != A5.getDerivedStateFromProps && (p6.__s == p6.state && (p6.__s = v3({}, p6.__s)), v3(p6.__s, A5.getDerivedStateFromProps(w5, p6.__s))), d4 = p6.props, _6 = p6.state, p6.__v = u5, y7)
          null == A5.getDerivedStateFromProps && null != p6.componentWillMount && p6.componentWillMount(), null != p6.componentDidMount && p6.__h.push(p6.componentDidMount);
        else {
          if (null == A5.getDerivedStateFromProps && w5 !== d4 && null != p6.componentWillReceiveProps && p6.componentWillReceiveProps(w5, P4), !p6.__e && (null != p6.shouldComponentUpdate && false === p6.shouldComponentUpdate(w5, p6.__s, P4) || u5.__v === t3.__v)) {
            for (u5.__v !== t3.__v && (p6.props = w5, p6.state = p6.__s, p6.__d = false), u5.__e = t3.__e, u5.__k = t3.__k, u5.__k.forEach(function(n4) {
              n4 && (n4.__ = u5);
            }), S5 = 0; S5 < p6._sb.length; S5++)
              p6.__h.push(p6._sb[S5]);
            p6._sb = [], p6.__h.length && f5.push(p6);
            break n;
          }
          null != p6.componentWillUpdate && p6.componentWillUpdate(w5, p6.__s, P4), null != p6.componentDidUpdate && p6.__h.push(function() {
            p6.componentDidUpdate(d4, _6, m5);
          });
        }
        if (p6.context = P4, p6.props = w5, p6.__P = n3, p6.__e = false, $4 = l2.__r, H3 = 0, "prototype" in A5 && A5.prototype.render) {
          for (p6.state = p6.__s, p6.__d = false, $4 && $4(u5), a4 = p6.render(p6.props, p6.state, p6.context), I3 = 0; I3 < p6._sb.length; I3++)
            p6.__h.push(p6._sb[I3]);
          p6._sb = [];
        } else
          do {
            p6.__d = false, $4 && $4(u5), a4 = p6.render(p6.props, p6.state, p6.context), p6.state = p6.__s;
          } while (p6.__d && ++H3 < 25);
        p6.state = p6.__s, null != p6.getChildContext && (i4 = v3(v3({}, i4), p6.getChildContext())), y7 || null == p6.getSnapshotBeforeUpdate || (m5 = p6.getSnapshotBeforeUpdate(d4, _6)), C(n3, h4(T4 = null != a4 && a4.type === g5 && null == a4.key ? a4.props.children : a4) ? T4 : [T4], u5, t3, i4, o3, r5, f5, e3, c5, s3), p6.base = u5.__e, u5.__u &= -161, p6.__h.length && f5.push(p6), k5 && (p6.__E = p6.__ = null);
      } catch (n4) {
        u5.__v = null, c5 || null != r5 ? (u5.__e = e3, u5.__u |= c5 ? 160 : 32, r5[r5.indexOf(e3)] = null) : (u5.__e = t3.__e, u5.__k = t3.__k), l2.__e(n4, u5, t3);
      }
    else
      null == r5 && u5.__v === t3.__v ? (u5.__k = t3.__k, u5.__e = t3.__e) : u5.__e = j5(t3.__e, u5, t3, i4, o3, r5, f5, c5, s3);
  (a4 = l2.diffed) && a4(u5);
}
function M4(n3, u5, t3) {
  u5.__d = void 0;
  for (var i4 = 0; i4 < t3.length; i4++)
    z3(t3[i4], t3[++i4], t3[++i4]);
  l2.__c && l2.__c(u5, n3), n3.some(function(u6) {
    try {
      n3 = u6.__h, u6.__h = [], n3.some(function(n4) {
        n4.call(u6);
      });
    } catch (n4) {
      l2.__e(n4, u6.__v);
    }
  });
}
function j5(l4, u5, t3, i4, o3, r5, f5, e3, s3) {
  var a4, v5, y7, d4, _6, g7, b6, k5 = t3.props, w5 = u5.props, x5 = u5.type;
  if ("svg" === x5 && (o3 = true), null != r5) {
    for (a4 = 0; a4 < r5.length; a4++)
      if ((_6 = r5[a4]) && "setAttribute" in _6 == !!x5 && (x5 ? _6.localName === x5 : 3 === _6.nodeType)) {
        l4 = _6, r5[a4] = null;
        break;
      }
  }
  if (null == l4) {
    if (null === x5)
      return document.createTextNode(w5);
    l4 = o3 ? document.createElementNS("http://www.w3.org/2000/svg", x5) : document.createElement(x5, w5.is && w5), r5 = null, e3 = false;
  }
  if (null === x5)
    k5 === w5 || e3 && l4.data === w5 || (l4.data = w5);
  else {
    if (r5 = r5 && n2.call(l4.childNodes), k5 = t3.props || c3, !e3 && null != r5)
      for (k5 = {}, a4 = 0; a4 < l4.attributes.length; a4++)
        k5[(_6 = l4.attributes[a4]).name] = _6.value;
    for (a4 in k5)
      _6 = k5[a4], "children" == a4 || ("dangerouslySetInnerHTML" == a4 ? y7 = _6 : "key" === a4 || a4 in w5 || T2(l4, a4, null, _6, o3));
    for (a4 in w5)
      _6 = w5[a4], "children" == a4 ? d4 = _6 : "dangerouslySetInnerHTML" == a4 ? v5 = _6 : "value" == a4 ? g7 = _6 : "checked" == a4 ? b6 = _6 : "key" === a4 || e3 && "function" != typeof _6 || k5[a4] === _6 || T2(l4, a4, _6, k5[a4], o3);
    if (v5)
      e3 || y7 && (v5.__html === y7.__html || v5.__html === l4.innerHTML) || (l4.innerHTML = v5.__html), u5.__k = [];
    else if (y7 && (l4.innerHTML = ""), C(l4, h4(d4) ? d4 : [d4], u5, t3, i4, o3 && "foreignObject" !== x5, r5, f5, r5 ? r5[0] : t3.__k && m3(t3, 0), e3, s3), null != r5)
      for (a4 = r5.length; a4--; )
        null != r5[a4] && p4(r5[a4]);
    e3 || (a4 = "value", void 0 !== g7 && (g7 !== l4[a4] || "progress" === x5 && !g7 || "option" === x5 && g7 !== k5[a4]) && T2(l4, a4, g7, k5[a4], false), a4 = "checked", void 0 !== b6 && b6 !== l4[a4] && T2(l4, a4, b6, k5[a4], false));
  }
  return l4;
}
function z3(n3, u5, t3) {
  try {
    "function" == typeof n3 ? n3(u5) : n3.current = u5;
  } catch (n4) {
    l2.__e(n4, t3);
  }
}
function N14(n3, u5, t3) {
  var i4, o3;
  if (l2.unmount && l2.unmount(n3), (i4 = n3.ref) && (i4.current && i4.current !== n3.__e || z3(i4, null, u5)), null != (i4 = n3.__c)) {
    if (i4.componentWillUnmount)
      try {
        i4.componentWillUnmount();
      } catch (n4) {
        l2.__e(n4, u5);
      }
    i4.base = i4.__P = null, n3.__c = void 0;
  }
  if (i4 = n3.__k)
    for (o3 = 0; o3 < i4.length; o3++)
      i4[o3] && N14(i4[o3], u5, t3 || "function" != typeof n3.type);
  t3 || null == n3.__e || p4(n3.__e), n3.__ = n3.__e = n3.__d = void 0;
}
function O6(n3, l4, u5) {
  return this.constructor(n3, u5);
}
function q3(u5, t3, i4) {
  var o3, r5, f5, e3;
  l2.__ && l2.__(u5, t3), r5 = (o3 = "function" == typeof i4) ? null : i4 && i4.__k || t3.__k, f5 = [], e3 = [], L3(t3, u5 = (!o3 && i4 || t3).__k = y5(g5, null, [u5]), r5 || c3, c3, void 0 !== t3.ownerSVGElement, !o3 && i4 ? [i4] : r5 ? null : t3.firstChild ? n2.call(t3.childNodes) : null, f5, !o3 && i4 ? i4 : r5 ? r5.__e : t3.firstChild, o3, e3), M4(f5, u5, e3);
}
function B3(n3, l4) {
  q3(n3, l4, B3);
}
function E5(l4, u5, t3) {
  var i4, o3, r5, f5, e3 = v3({}, l4.props);
  for (r5 in l4.type && l4.type.defaultProps && (f5 = l4.type.defaultProps), u5)
    "key" == r5 ? i4 = u5[r5] : "ref" == r5 ? o3 = u5[r5] : e3[r5] = void 0 === u5[r5] && void 0 !== f5 ? f5[r5] : u5[r5];
  return arguments.length > 2 && (e3.children = arguments.length > 3 ? n2.call(arguments, 2) : t3), d2(l4.type, e3, i4 || l4.key, o3 || l4.ref, null);
}
function F4(n3, l4) {
  var u5 = { __c: l4 = "__cC" + e++, __: n3, Consumer: function(n4, l5) {
    return n4.children(l5);
  }, Provider: function(n4) {
    var u6, t3;
    return this.getChildContext || (u6 = [], (t3 = {})[l4] = this, this.getChildContext = function() {
      return t3;
    }, this.shouldComponentUpdate = function(n5) {
      this.props.value !== n5.value && u6.some(function(n6) {
        n6.__e = true, w3(n6);
      });
    }, this.sub = function(n5) {
      u6.push(n5);
      var l5 = n5.componentWillUnmount;
      n5.componentWillUnmount = function() {
        u6.splice(u6.indexOf(n5), 1), l5 && l5.call(n5);
      };
    }), n4.children;
  } };
  return u5.Provider.__ = u5.Consumer.contextType = u5;
}
var n2, l2, u3, t, i2, o, r2, f3, e, c3, s, a2, h4;
var init_preact_module = __esm({
  "node_modules/preact/dist/preact.module.js"() {
    c3 = {};
    s = [];
    a2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
    h4 = Array.isArray;
    n2 = s.slice, l2 = { __e: function(n3, l4, u5, t3) {
      for (var i4, o3, r5; l4 = l4.__; )
        if ((i4 = l4.__c) && !i4.__)
          try {
            if ((o3 = i4.constructor) && null != o3.getDerivedStateFromError && (i4.setState(o3.getDerivedStateFromError(n3)), r5 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n3, t3 || {}), r5 = i4.__d), r5)
              return i4.__E = i4;
          } catch (l5) {
            n3 = l5;
          }
      throw n3;
    } }, u3 = 0, t = function(n3) {
      return null != n3 && null == n3.constructor;
    }, b4.prototype.setState = function(n3, l4) {
      var u5;
      u5 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v3({}, this.state), "function" == typeof n3 && (n3 = n3(v3({}, u5), this.props)), n3 && v3(u5, n3), null != n3 && this.__v && (l4 && this._sb.push(l4), w3(this));
    }, b4.prototype.forceUpdate = function(n3) {
      this.__v && (this.__e = true, n3 && this.__h.push(n3), w3(this));
    }, b4.prototype.render = g5, i2 = [], r2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f3 = function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }, x3.__r = 0, e = 0;
  }
});

// node_modules/rxjs/_esm5/internal/util/isFunction.js
function isFunction(x5) {
  return typeof x5 === "function";
}
var init_isFunction = __esm({
  "node_modules/rxjs/_esm5/internal/util/isFunction.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/config.js
var _enable_super_gross_mode_that_will_cause_bad_things, config;
var init_config = __esm({
  "node_modules/rxjs/_esm5/internal/config.js"() {
    _enable_super_gross_mode_that_will_cause_bad_things = false;
    config = {
      Promise: void 0,
      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          var error = new Error();
          console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log("RxJS: Back to a better error behavior. Thank you. <3");
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/hostReportError.js
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var init_hostReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/hostReportError.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/Observer.js
var empty3;
var init_Observer = __esm({
  "node_modules/rxjs/_esm5/internal/Observer.js"() {
    init_config();
    init_hostReportError();
    empty3 = {
      closed: true,
      next: function(value) {
      },
      error: function(err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      },
      complete: function() {
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray;
var init_isArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArray.js"() {
    isArray = function() {
      return Array.isArray || function(x5) {
        return x5 && typeof x5.length === "number";
      };
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/isObject.js
function isObject2(x5) {
  return x5 !== null && typeof x5 === "object";
}
var init_isObject = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObject.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionErrorImpl, UnsubscriptionError;
var init_UnsubscriptionError = __esm({
  "node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js"() {
    UnsubscriptionErrorImpl = function() {
      function UnsubscriptionErrorImpl2(errors) {
        Error.call(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i4) {
          return i4 + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
        return this;
      }
      UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl2;
    }();
    UnsubscriptionError = UnsubscriptionErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/Subscription.js
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var Subscription;
var init_Subscription = __esm({
  "node_modules/rxjs/_esm5/internal/Subscription.js"() {
    init_isArray();
    init_isObject();
    init_isFunction();
    init_UnsubscriptionError();
    Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._ctorUnsubscribe = true;
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var errors;
        if (this.closed) {
          return;
        }
        var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription2) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (var index = 0; index < _parentOrParents.length; ++index) {
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
          }
        }
        if (isFunction(_unsubscribe)) {
          if (_ctorUnsubscribe) {
            this._unsubscribe = void 0;
          }
          try {
            _unsubscribe.call(this);
          } catch (e3) {
            errors = e3 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e3.errors) : [e3];
          }
        }
        if (isArray(_subscriptions)) {
          var index = -1;
          var len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject2(sub)) {
              try {
                sub.unsubscribe();
              } catch (e3) {
                errors = errors || [];
                if (e3 instanceof UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e3.errors));
                } else {
                  errors.push(e3);
                }
              }
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) {
          return Subscription2.EMPTY;
        }
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription2)) {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription2) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.EMPTY = function(empty5) {
        empty5.closed = true;
        return empty5;
      }(new Subscription2());
      return Subscription2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber;
var init_rxSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js"() {
    rxSubscriber = function() {
      return typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
    }();
  }
});

// node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber, SafeSubscriber;
var init_Subscriber = __esm({
  "node_modules/rxjs/_esm5/internal/Subscriber.js"() {
    init_tslib_es6();
    init_isFunction();
    init_Observer();
    init_Subscription();
    init_rxSubscriber();
    init_config();
    init_hostReportError();
    Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
          case 0:
            _this.destination = empty3;
            break;
          case 1:
            if (!destinationOrNext) {
              _this.destination = empty3;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (destinationOrNext instanceof Subscriber2) {
                _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this.destination = destinationOrNext;
                destinationOrNext.add(_this);
              } else {
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext);
              }
              break;
            }
          default:
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
            break;
        }
        return _this;
      }
      Subscriber2.prototype[rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error, complete) {
        var subscriber = new Subscriber2(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value) {
        this.destination.next(value);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      };
      return Subscriber2;
    }(Subscription);
    SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== empty3) {
            context = Object.create(observerOrNext);
            if (isFunction(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
      }
      SafeSubscriber2.prototype.next = function(value) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn2, value) {
        try {
          fn2.call(this._context, value);
        } catch (err) {
          this.unsubscribe();
          if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError(err);
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn2, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
          throw new Error("bad call");
        }
        try {
          fn2.call(this._context, value);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError(err);
            return true;
          }
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/canReportError.js
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
var init_canReportError = __esm({
  "node_modules/rxjs/_esm5/internal/util/canReportError.js"() {
    init_Subscriber();
  }
});

// node_modules/rxjs/_esm5/internal/util/toSubscriber.js
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty3);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var init_toSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/util/toSubscriber.js"() {
    init_Subscriber();
    init_rxSubscriber();
    init_Observer();
  }
});

// node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable;
var init_observable = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/observable.js"() {
    observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/identity.js
function identity3(x5) {
  return x5;
}
var init_identity = __esm({
  "node_modules/rxjs/_esm5/internal/util/identity.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity3;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}
var init_pipe = __esm({
  "node_modules/rxjs/_esm5/internal/util/pipe.js"() {
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/Observable.js
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var Observable;
var init_Observable = __esm({
  "node_modules/rxjs/_esm5/internal/Observable.js"() {
    init_canReportError();
    init_toSubscriber();
    init_observable();
    init_pipe();
    init_config();
    Observable = function() {
      function Observable2(subscribe2) {
        this._isScalar = false;
        if (subscribe2) {
          this._subscribe = subscribe2;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable2 = new Observable2();
        observable2.source = this;
        observable2.operator = operator;
        return observable2;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var subscription;
          subscription = _this.subscribe(function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
      };
      Observable2.prototype[observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve, reject) {
          var value;
          _this.subscribe(function(x5) {
            return value = x5;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve(value);
          });
        });
      };
      Observable2.create = function(subscribe2) {
        return new Observable2(subscribe2);
      };
      return Observable2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedErrorImpl, ObjectUnsubscribedError;
var init_ObjectUnsubscribedError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js"() {
    ObjectUnsubscribedErrorImpl = function() {
      function ObjectUnsubscribedErrorImpl2() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
      }
      ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl2;
    }();
    ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription;
var init_SubjectSubscription = __esm({
  "node_modules/rxjs/_esm5/internal/SubjectSubscription.js"() {
    init_tslib_es6();
    init_Subscription();
    SubjectSubscription = function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/Subject.js
var SubjectSubscriber, Subject, AnonymousSubject;
var init_Subject = __esm({
  "node_modules/rxjs/_esm5/internal/Subject.js"() {
    init_tslib_es6();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    init_rxSubscriber();
    SubjectSubscriber = function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
      }
      return SubjectSubscriber2;
    }(Subscriber);
    Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype[rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i4 = 0; i4 < len; i4++) {
            copy[i4].next(value);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i4 = 0; i4 < len; i4++) {
          copy[i4].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i4 = 0; i4 < len; i4++) {
          copy[i4].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable2 = new Observable();
        observable2.source = this;
        return observable2;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable);
    AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/operators/refCount.js
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator, RefCountSubscriber;
var init_refCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/refCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    RefCountOperator = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable, connectableObservableDescriptor, ConnectableSubscriber, RefCountOperator2, RefCountSubscriber2;
var init_ConnectableObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js"() {
    init_tslib_es6();
    init_Subject();
    init_Observable();
    init_Subscriber();
    init_Subscription();
    init_refCount();
    ConnectableObservable = function(_super) {
      __extends(ConnectableObservable2, _super);
      function ConnectableObservable2(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
      }
      ConnectableObservable2.prototype._subscribe = function(subscriber) {
        return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable2.prototype.getSubject = function() {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }
        return this._subject;
      };
      ConnectableObservable2.prototype.connect = function() {
        var connection = this._connection;
        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new Subscription();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
          if (connection.closed) {
            this._connection = null;
            connection = Subscription.EMPTY;
          }
        }
        return connection;
      };
      ConnectableObservable2.prototype.refCount = function() {
        return refCount()(this);
      };
      return ConnectableObservable2;
    }(Observable);
    connectableObservableDescriptor = function() {
      var connectableProto = ConnectableObservable.prototype;
      return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
      };
    }();
    ConnectableSubscriber = function(_super) {
      __extends(ConnectableSubscriber2, _super);
      function ConnectableSubscriber2(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      ConnectableSubscriber2.prototype._error = function(err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber2.prototype._complete = function() {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
      };
      ConnectableSubscriber2.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (connectable) {
          this.connectable = null;
          var connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;
          if (connection) {
            connection.unsubscribe();
          }
        }
      };
      return ConnectableSubscriber2;
    }(SubjectSubscriber);
    RefCountOperator2 = function() {
      function RefCountOperator3(connectable) {
        this.connectable = connectable;
      }
      RefCountOperator3.prototype.call = function(subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber2(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }
        return subscription;
      };
      return RefCountOperator3;
    }();
    RefCountSubscriber2 = function(_super) {
      __extends(RefCountSubscriber3, _super);
      function RefCountSubscriber3(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
      }
      RefCountSubscriber3.prototype._unsubscribe = function() {
        var connectable = this.connectable;
        if (!connectable) {
          this.connection = null;
          return;
        }
        this.connectable = null;
        var refCount2 = connectable._refCount;
        if (refCount2 <= 0) {
          this.connection = null;
          return;
        }
        connectable._refCount = refCount2 - 1;
        if (refCount2 > 1) {
          this.connection = null;
          return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      };
      return RefCountSubscriber3;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/groupBy.js
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator, GroupBySubscriber, GroupDurationSubscriber, GroupedObservable, InnerRefCountSubscription;
var init_groupBy = __esm({
  "node_modules/rxjs/_esm5/internal/operators/groupBy.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    init_Observable();
    init_Subject();
    GroupByOperator = function() {
      function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }
      GroupByOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
      };
      return GroupByOperator2;
    }();
    GroupBySubscriber = function(_super) {
      __extends(GroupBySubscriber2, _super);
      function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
      }
      GroupBySubscriber2.prototype._next = function(value) {
        var key2;
        try {
          key2 = this.keySelector(value);
        } catch (err) {
          this.error(err);
          return;
        }
        this._group(value, key2);
      };
      GroupBySubscriber2.prototype._group = function(value, key2) {
        var groups = this.groups;
        if (!groups) {
          groups = this.groups = /* @__PURE__ */ new Map();
        }
        var group = groups.get(key2);
        var element;
        if (this.elementSelector) {
          try {
            element = this.elementSelector(value);
          } catch (err) {
            this.error(err);
          }
        } else {
          element = value;
        }
        if (!group) {
          group = this.subjectSelector ? this.subjectSelector() : new Subject();
          groups.set(key2, group);
          var groupedObservable = new GroupedObservable(key2, group, this);
          this.destination.next(groupedObservable);
          if (this.durationSelector) {
            var duration = void 0;
            try {
              duration = this.durationSelector(new GroupedObservable(key2, group));
            } catch (err) {
              this.error(err);
              return;
            }
            this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
          }
        }
        if (!group.closed) {
          group.next(element);
        }
      };
      GroupBySubscriber2.prototype._error = function(err) {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key2) {
            group.error(err);
          });
          groups.clear();
        }
        this.destination.error(err);
      };
      GroupBySubscriber2.prototype._complete = function() {
        var groups = this.groups;
        if (groups) {
          groups.forEach(function(group, key2) {
            group.complete();
          });
          groups.clear();
        }
        this.destination.complete();
      };
      GroupBySubscriber2.prototype.removeGroup = function(key2) {
        this.groups.delete(key2);
      };
      GroupBySubscriber2.prototype.unsubscribe = function() {
        if (!this.closed) {
          this.attemptedToUnsubscribe = true;
          if (this.count === 0) {
            _super.prototype.unsubscribe.call(this);
          }
        }
      };
      return GroupBySubscriber2;
    }(Subscriber);
    GroupDurationSubscriber = function(_super) {
      __extends(GroupDurationSubscriber2, _super);
      function GroupDurationSubscriber2(key2, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key2;
        _this.group = group;
        _this.parent = parent;
        return _this;
      }
      GroupDurationSubscriber2.prototype._next = function(value) {
        this.complete();
      };
      GroupDurationSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, parent = _a2.parent, key2 = _a2.key;
        this.key = this.parent = null;
        if (parent) {
          parent.removeGroup(key2);
        }
      };
      return GroupDurationSubscriber2;
    }(Subscriber);
    GroupedObservable = function(_super) {
      __extends(GroupedObservable2, _super);
      function GroupedObservable2(key2, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key2;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
      }
      GroupedObservable2.prototype._subscribe = function(subscriber) {
        var subscription = new Subscription();
        var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
          subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
      };
      return GroupedObservable2;
    }(Observable);
    InnerRefCountSubscription = function(_super) {
      __extends(InnerRefCountSubscription2, _super);
      function InnerRefCountSubscription2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
      }
      InnerRefCountSubscription2.prototype.unsubscribe = function() {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
          _super.prototype.unsubscribe.call(this);
          parent.count -= 1;
          if (parent.count === 0 && parent.attemptedToUnsubscribe) {
            parent.unsubscribe();
          }
        }
      };
      return InnerRefCountSubscription2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/BehaviorSubject.js
var BehaviorSubject;
var init_BehaviorSubject = __esm({
  "node_modules/rxjs/_esm5/internal/BehaviorSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_ObjectUnsubscribedError();
    BehaviorSubject = function(_super) {
      __extends(BehaviorSubject2, _super);
      function BehaviorSubject2(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
      }
      Object.defineProperty(BehaviorSubject2.prototype, "value", {
        get: function() {
          return this.getValue();
        },
        enumerable: true,
        configurable: true
      });
      BehaviorSubject2.prototype._subscribe = function(subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }
        return subscription;
      };
      BehaviorSubject2.prototype.getValue = function() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else {
          return this._value;
        }
      };
      BehaviorSubject2.prototype.next = function(value) {
        _super.prototype.next.call(this, this._value = value);
      };
      return BehaviorSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/Action.js
var Action;
var init_Action = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/Action.js"() {
    init_tslib_es6();
    init_Subscription();
    Action = function(_super) {
      __extends(Action2, _super);
      function Action2(scheduler, work) {
        return _super.call(this) || this;
      }
      Action2.prototype.schedule = function(state3, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return this;
      };
      return Action2;
    }(Subscription);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
var AsyncAction;
var init_AsyncAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js"() {
    init_tslib_es6();
    init_Action();
    AsyncAction = function(_super) {
      __extends(AsyncAction2, _super);
      function AsyncAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
      }
      AsyncAction2.prototype.schedule = function(state3, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (this.closed) {
          return this;
        }
        this.state = state3;
        var id2 = this.id;
        var scheduler = this.scheduler;
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, delay2);
        }
        this.pending = true;
        this.delay = delay2;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
        return this;
      };
      AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay2);
      };
      AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && this.delay === delay2 && this.pending === false) {
          return id2;
        }
        clearInterval(id2);
        return void 0;
      };
      AsyncAction2.prototype.execute = function(state3, delay2) {
        if (this.closed) {
          return new Error("executing a cancelled action");
        }
        this.pending = false;
        var error = this._execute(state3, delay2);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      };
      AsyncAction2.prototype._execute = function(state3, delay2) {
        var errored = false;
        var errorValue = void 0;
        try {
          this.work(state3);
        } catch (e3) {
          errored = true;
          errorValue = !!e3 && e3 || new Error(e3);
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      };
      AsyncAction2.prototype._unsubscribe = function() {
        var id2 = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
          actions.splice(index, 1);
        }
        if (id2 != null) {
          this.id = this.recycleAsyncId(scheduler, id2, null);
        }
        this.delay = null;
      };
      return AsyncAction2;
    }(Action);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
var QueueAction;
var init_QueueAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    QueueAction = function(_super) {
      __extends(QueueAction2, _super);
      function QueueAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      QueueAction2.prototype.schedule = function(state3, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 > 0) {
          return _super.prototype.schedule.call(this, state3, delay2);
        }
        this.delay = delay2;
        this.state = state3;
        this.scheduler.flush(this);
        return this;
      };
      QueueAction2.prototype.execute = function(state3, delay2) {
        return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state3, delay2) : this._execute(state3, delay2);
      };
      QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        return scheduler.flush(this);
      };
      return QueueAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler;
var init_Scheduler = __esm({
  "node_modules/rxjs/_esm5/internal/Scheduler.js"() {
    Scheduler = function() {
      function Scheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler2.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now2;
      }
      Scheduler2.prototype.schedule = function(work, delay2, state3) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state3, delay2);
      };
      Scheduler2.now = function() {
        return Date.now();
      };
      return Scheduler2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler;
var init_AsyncScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js"() {
    init_tslib_es6();
    init_Scheduler();
    AsyncScheduler = function(_super) {
      __extends(AsyncScheduler2, _super);
      function AsyncScheduler2(SchedulerAction, now2) {
        if (now2 === void 0) {
          now2 = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
            return AsyncScheduler2.delegate.now();
          } else {
            return now2();
          }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = void 0;
        return _this;
      }
      AsyncScheduler2.prototype.schedule = function(work, delay2, state3) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
          return AsyncScheduler2.delegate.schedule(work, delay2, state3);
        } else {
          return _super.prototype.schedule.call(this, work, delay2, state3);
        }
      };
      AsyncScheduler2.prototype.flush = function(action) {
        var actions = this.actions;
        if (this.active) {
          actions.push(action);
          return;
        }
        var error;
        this.active = true;
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsyncScheduler2;
    }(Scheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler;
var init_QueueScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    QueueScheduler = function(_super) {
      __extends(QueueScheduler2, _super);
      function QueueScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/queue.js
var queueScheduler, queue;
var init_queue = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/queue.js"() {
    init_QueueAction();
    init_QueueScheduler();
    queueScheduler = new QueueScheduler(QueueAction);
    queue = queueScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/observable/empty.js
function empty4(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
var EMPTY;
var init_empty = __esm({
  "node_modules/rxjs/_esm5/internal/observable/empty.js"() {
    init_Observable();
    EMPTY = new Observable(function(subscriber) {
      return subscriber.complete();
    });
  }
});

// node_modules/rxjs/_esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && typeof value.schedule === "function";
}
var init_isScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/util/isScheduler.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray;
var init_subscribeToArray = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToArray.js"() {
    subscribeToArray = function(array2) {
      return function(subscriber) {
        for (var i4 = 0, len = array2.length; i4 < len && !subscriber.closed; i4++) {
          subscriber.next(array2[i4]);
        }
        subscriber.complete();
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i4 = 0;
    sub.add(scheduler.schedule(function() {
      if (i4 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i4++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
var init_scheduleArray = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromArray.js
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
var init_fromArray = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromArray.js"() {
    init_Observable();
    init_subscribeToArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
var init_of = __esm({
  "node_modules/rxjs/_esm5/internal/observable/of.js"() {
    init_isScheduler();
    init_fromArray();
    init_scheduleArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/throwError.js
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, { error, subscriber });
    });
  }
}
function dispatch(_a2) {
  var error = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error);
}
var init_throwError = __esm({
  "node_modules/rxjs/_esm5/internal/observable/throwError.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/Notification.js
var NotificationKind, Notification;
var init_Notification = __esm({
  "node_modules/rxjs/_esm5/internal/Notification.js"() {
    init_empty();
    init_of();
    init_throwError();
    (function(NotificationKind2) {
      NotificationKind2["NEXT"] = "N";
      NotificationKind2["ERROR"] = "E";
      NotificationKind2["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));
    Notification = function() {
      function Notification2(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }
      Notification2.prototype.observe = function(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);
          case "E":
            return observer.error && observer.error(this.error);
          case "C":
            return observer.complete && observer.complete();
        }
      };
      Notification2.prototype.do = function(next, error, complete) {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return next && next(this.value);
          case "E":
            return error && error(this.error);
          case "C":
            return complete && complete();
        }
      };
      Notification2.prototype.accept = function(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === "function") {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      };
      Notification2.prototype.toObservable = function() {
        var kind = this.kind;
        switch (kind) {
          case "N":
            return of(this.value);
          case "E":
            return throwError(this.error);
          case "C":
            return empty4();
        }
        throw new Error("unexpected notification kind value");
      };
      Notification2.createNext = function(value) {
        if (typeof value !== "undefined") {
          return new Notification2("N", value);
        }
        return Notification2.undefinedValueNotification;
      };
      Notification2.createError = function(err) {
        return new Notification2("E", void 0, err);
      };
      Notification2.createComplete = function() {
        return Notification2.completeNotification;
      };
      Notification2.completeNotification = new Notification2("C");
      Notification2.undefinedValueNotification = new Notification2("N", void 0);
      return Notification2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage;
var init_observeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/observeOn.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    ObserveOnOperator = function() {
      function ObserveOnOperator2(scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      ObserveOnOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      };
      return ObserveOnOperator2;
    }();
    ObserveOnSubscriber = function(_super) {
      __extends(ObserveOnSubscriber2, _super);
      function ObserveOnSubscriber2(destination, scheduler, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay2;
        return _this;
      }
      ObserveOnSubscriber2.dispatch = function(arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber2.prototype._next = function(value) {
        this.scheduleMessage(Notification.createNext(value));
      };
      ObserveOnSubscriber2.prototype._error = function(err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
      };
      ObserveOnSubscriber2.prototype._complete = function() {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
      };
      return ObserveOnSubscriber2;
    }(Subscriber);
    ObserveOnMessage = function() {
      function ObserveOnMessage2(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }
      return ObserveOnMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/ReplaySubject.js
var ReplaySubject, ReplayEvent;
var init_ReplaySubject = __esm({
  "node_modules/rxjs/_esm5/internal/ReplaySubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_queue();
    init_Subscription();
    init_observeOn();
    init_ObjectUnsubscribedError();
    init_SubjectSubscription();
    ReplaySubject = function(_super) {
      __extends(ReplaySubject2, _super);
      function ReplaySubject2(bufferSize, windowTime2, scheduler) {
        if (bufferSize === void 0) {
          bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime2 === void 0) {
          windowTime2 = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
        if (windowTime2 === Number.POSITIVE_INFINITY) {
          _this._infiniteTimeWindow = true;
          _this.next = _this.nextInfiniteTimeWindow;
        } else {
          _this.next = _this.nextTimeWindow;
        }
        return _this;
      }
      ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value) {
        if (!this.isStopped) {
          var _events = this._events;
          _events.push(value);
          if (_events.length > this._bufferSize) {
            _events.shift();
          }
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype.nextTimeWindow = function(value) {
        if (!this.isStopped) {
          this._events.push(new ReplayEvent(this._getNow(), value));
          this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
      };
      ReplaySubject2.prototype._subscribe = function(subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        } else if (this.isStopped || this.hasError) {
          subscription = Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
          subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
          for (var i4 = 0; i4 < len && !subscriber.closed; i4++) {
            subscriber.next(_events[i4]);
          }
        } else {
          for (var i4 = 0; i4 < len && !subscriber.closed; i4++) {
            subscriber.next(_events[i4].value);
          }
        }
        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }
        return subscription;
      };
      ReplaySubject2.prototype._getNow = function() {
        return (this.scheduler || queue).now();
      };
      ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
        var now2 = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
          if (now2 - _events[spliceCount].time < _windowTime) {
            break;
          }
          spliceCount++;
        }
        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }
        return _events;
      };
      return ReplaySubject2;
    }(Subject);
    ReplayEvent = function() {
      function ReplayEvent2(time, value) {
        this.time = time;
        this.value = value;
      }
      return ReplayEvent2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/AsyncSubject.js
var AsyncSubject;
var init_AsyncSubject = __esm({
  "node_modules/rxjs/_esm5/internal/AsyncSubject.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    AsyncSubject = function(_super) {
      __extends(AsyncSubject2, _super);
      function AsyncSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
      }
      AsyncSubject2.prototype._subscribe = function(subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription.EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
      };
      AsyncSubject2.prototype.next = function(value) {
        if (!this.hasCompleted) {
          this.value = value;
          this.hasNext = true;
        }
      };
      AsyncSubject2.prototype.error = function(error) {
        if (!this.hasCompleted) {
          _super.prototype.error.call(this, error);
        }
      };
      AsyncSubject2.prototype.complete = function() {
        this.hasCompleted = true;
        if (this.hasNext) {
          _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
      };
      return AsyncSubject2;
    }(Subject);
  }
});

// node_modules/rxjs/_esm5/internal/util/Immediate.js
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var nextHandle, RESOLVED, activeHandles, Immediate;
var init_Immediate = __esm({
  "node_modules/rxjs/_esm5/internal/util/Immediate.js"() {
    nextHandle = 1;
    RESOLVED = function() {
      return Promise.resolve();
    }();
    activeHandles = {};
    Immediate = {
      setImmediate: function(cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function() {
          return findAndClearHandle(handle) && cb();
        });
        return handle;
      },
      clearImmediate: function(handle) {
        findAndClearHandle(handle);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
var AsapAction;
var init_AsapAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js"() {
    init_tslib_es6();
    init_Immediate();
    init_AsyncAction();
    AsapAction = function(_super) {
      __extends(AsapAction2, _super);
      function AsapAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
      };
      AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
        }
        if (scheduler.actions.length === 0) {
          Immediate.clearImmediate(id2);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AsapAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler;
var init_AsapScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AsapScheduler = function(_super) {
      __extends(AsapScheduler2, _super);
      function AsapScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AsapScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AsapScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/asap.js
var asapScheduler, asap;
var init_asap = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/asap.js"() {
    init_AsapAction();
    init_AsapScheduler();
    asapScheduler = new AsapScheduler(AsapAction);
    asap = asapScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/async.js
var asyncScheduler, async;
var init_async = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/async.js"() {
    init_AsyncAction();
    init_AsyncScheduler();
    asyncScheduler = new AsyncScheduler(AsyncAction);
    async = asyncScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction;
var init_AnimationFrameAction = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameAction.js"() {
    init_tslib_es6();
    init_AsyncAction();
    AnimationFrameAction = function(_super) {
      __extends(AnimationFrameAction2, _super);
      function AnimationFrameAction2(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
      }
      AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0) {
          return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
          return scheduler.flush(null);
        }));
      };
      AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
          return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
        }
        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id2);
          scheduler.scheduled = void 0;
        }
        return void 0;
      };
      return AnimationFrameAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler;
var init_AnimationFrameScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/AnimationFrameScheduler.js"() {
    init_tslib_es6();
    init_AsyncScheduler();
    AnimationFrameScheduler = function(_super) {
      __extends(AnimationFrameScheduler2, _super);
      function AnimationFrameScheduler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AnimationFrameScheduler2.prototype.flush = function(action) {
        this.active = true;
        this.scheduled = void 0;
        var actions = this.actions;
        var error;
        var index = -1;
        var count2 = actions.length;
        action = action || actions.shift();
        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count2 && (action = actions.shift()));
        this.active = false;
        if (error) {
          while (++index < count2 && (action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      return AnimationFrameScheduler2;
    }(AsyncScheduler);
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler, animationFrame;
var init_animationFrame = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/animationFrame.js"() {
    init_AnimationFrameAction();
    init_AnimationFrameScheduler();
    animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);
    animationFrame = animationFrameScheduler;
  }
});

// node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler, VirtualAction;
var init_VirtualTimeScheduler = __esm({
  "node_modules/rxjs/_esm5/internal/scheduler/VirtualTimeScheduler.js"() {
    init_tslib_es6();
    init_AsyncAction();
    init_AsyncScheduler();
    VirtualTimeScheduler = function(_super) {
      __extends(VirtualTimeScheduler2, _super);
      function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
          SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
          maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function() {
          return _this.frame;
        }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
      }
      VirtualTimeScheduler2.prototype.flush = function() {
        var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }
        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }
          throw error;
        }
      };
      VirtualTimeScheduler2.frameTimeFactor = 10;
      return VirtualTimeScheduler2;
    }(AsyncScheduler);
    VirtualAction = function(_super) {
      __extends(VirtualAction2, _super);
      function VirtualAction2(scheduler, work, index) {
        if (index === void 0) {
          index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
      }
      VirtualAction2.prototype.schedule = function(state3, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (!this.id) {
          return _super.prototype.schedule.call(this, state3, delay2);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state3, delay2);
      };
      VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        this.delay = scheduler.frame + delay2;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction2.sortActions);
        return true;
      };
      VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        return void 0;
      };
      VirtualAction2.prototype._execute = function(state3, delay2) {
        if (this.active === true) {
          return _super.prototype._execute.call(this, state3, delay2);
        }
      };
      VirtualAction2.sortActions = function(a4, b6) {
        if (a4.delay === b6.delay) {
          if (a4.index === b6.index) {
            return 0;
          } else if (a4.index > b6.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a4.delay > b6.delay) {
          return 1;
        } else {
          return -1;
        }
      };
      return VirtualAction2;
    }(AsyncAction);
  }
});

// node_modules/rxjs/_esm5/internal/util/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/rxjs/_esm5/internal/util/noop.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var init_isObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isObservable.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeErrorImpl, ArgumentOutOfRangeError;
var init_ArgumentOutOfRangeError = __esm({
  "node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js"() {
    ArgumentOutOfRangeErrorImpl = function() {
      function ArgumentOutOfRangeErrorImpl2() {
        Error.call(this);
        this.message = "argument out of range";
        this.name = "ArgumentOutOfRangeError";
        return this;
      }
      ArgumentOutOfRangeErrorImpl2.prototype = Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl2;
    }();
    ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/EmptyError.js
var EmptyErrorImpl, EmptyError;
var init_EmptyError = __esm({
  "node_modules/rxjs/_esm5/internal/util/EmptyError.js"() {
    EmptyErrorImpl = function() {
      function EmptyErrorImpl2() {
        Error.call(this);
        this.message = "no elements in sequence";
        this.name = "EmptyError";
        return this;
      }
      EmptyErrorImpl2.prototype = Object.create(Error.prototype);
      return EmptyErrorImpl2;
    }();
    EmptyError = EmptyErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/util/TimeoutError.js
var TimeoutErrorImpl, TimeoutError;
var init_TimeoutError = __esm({
  "node_modules/rxjs/_esm5/internal/util/TimeoutError.js"() {
    TimeoutErrorImpl = function() {
      function TimeoutErrorImpl2() {
        Error.call(this);
        this.message = "Timeout has occurred";
        this.name = "TimeoutError";
        return this;
      }
      TimeoutErrorImpl2.prototype = Object.create(Error.prototype);
      return TimeoutErrorImpl2;
    }();
    TimeoutError = TimeoutErrorImpl;
  }
});

// node_modules/rxjs/_esm5/internal/operators/map.js
function map2(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator, MapSubscriber;
var init_map = __esm({
  "node_modules/rxjs/_esm5/internal/operators/map.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapOperator = function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    MapSubscriber = function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      MapSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindCallback.js
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map2(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state3 = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch2, 0, state3);
      }
    });
  };
}
function dispatch2(state3) {
  var _this = this;
  var self2 = this;
  var args = state3.args, subscriber = state3.subscriber, params = state3.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext, 0, { value, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext(state3) {
  var value = state3.value, subject = state3.subject;
  subject.next(value);
  subject.complete();
}
var init_bindCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isArray();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map2(function(args2) {
          return isArray(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch3, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch3(state3) {
  var _this = this;
  var params = state3.params, subscriber = state3.subscriber, context = state3.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext2, 0, { value, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext2(arg) {
  var value = arg.value, subject = arg.subject;
  subject.next(value);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var init_bindNodeCallback = __esm({
  "node_modules/rxjs/_esm5/internal/observable/bindNodeCallback.js"() {
    init_Observable();
    init_AsyncSubject();
    init_map();
    init_canReportError();
    init_isScheduler();
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber;
var init_OuterSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/OuterSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    OuterSubscriber = function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber;
var init_InnerSubscriber = __esm({
  "node_modules/rxjs/_esm5/internal/InnerSubscriber.js"() {
    init_tslib_es6();
    init_Subscriber();
    InnerSubscriber = function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }
      InnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
var subscribeToPromise;
var init_subscribeToPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js"() {
    init_hostReportError();
    subscribeToPromise = function(promise) {
      return function(subscriber) {
        promise.then(function(value) {
          if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, hostReportError);
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator;
var init_iterator = __esm({
  "node_modules/rxjs/_esm5/internal/symbol/iterator.js"() {
    iterator = getSymbolIterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
var subscribeToIterable;
var init_subscribeToIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js"() {
    init_iterator();
    subscribeToIterable = function(iterable) {
      return function(subscriber) {
        var iterator2 = iterable[iterator]();
        do {
          var item = void 0;
          try {
            item = iterator2.next();
          } catch (err) {
            subscriber.error(err);
            return subscriber;
          }
          if (item.done) {
            subscriber.complete();
            break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
            break;
          }
        } while (true);
        if (typeof iterator2.return === "function") {
          subscriber.add(function() {
            if (iterator2.return) {
              iterator2.return();
            }
          });
        }
        return subscriber;
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
var subscribeToObservable;
var init_subscribeToObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js"() {
    init_observable();
    subscribeToObservable = function(obj) {
      return function(subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== "function") {
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        } else {
          return obs.subscribe(subscriber);
        }
      };
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike;
var init_isArrayLike = __esm({
  "node_modules/rxjs/_esm5/internal/util/isArrayLike.js"() {
    isArrayLike = function(x5) {
      return x5 && typeof x5.length === "number" && typeof x5 !== "function";
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/isPromise.js
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var init_isPromise = __esm({
  "node_modules/rxjs/_esm5/internal/util/isPromise.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeTo.js
var subscribeTo;
var init_subscribeTo = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeTo.js"() {
    init_subscribeToArray();
    init_subscribeToPromise();
    init_subscribeToIterable();
    init_subscribeToObservable();
    init_isArrayLike();
    init_isPromise();
    init_isObject();
    init_iterator();
    init_observable();
    subscribeTo = function(result) {
      if (!!result && typeof result[observable] === "function") {
        return subscribeToObservable(result);
      } else if (isArrayLike(result)) {
        return subscribeToArray(result);
      } else if (isPromise(result)) {
        return subscribeToPromise(result);
      } else if (!!result && typeof result[iterator] === "function") {
        return subscribeToIterable(result);
      } else {
        var value = isObject2(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
      }
    };
  }
});

// node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var init_subscribeToResult = __esm({
  "node_modules/rxjs/_esm5/internal/util/subscribeToResult.js"() {
    init_InnerSubscriber();
    init_subscribeTo();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/combineLatest.js
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var NONE, CombineLatestOperator, CombineLatestSubscriber;
var init_combineLatest = __esm({
  "node_modules/rxjs/_esm5/internal/observable/combineLatest.js"() {
    init_tslib_es6();
    init_isScheduler();
    init_isArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    init_fromArray();
    NONE = {};
    CombineLatestOperator = function() {
      function CombineLatestOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      CombineLatestOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
      };
      return CombineLatestOperator2;
    }();
    CombineLatestSubscriber = function(_super) {
      __extends(CombineLatestSubscriber2, _super);
      function CombineLatestSubscriber2(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
      }
      CombineLatestSubscriber2.prototype._next = function(observable2) {
        this.values.push(NONE);
        this.observables.push(observable2);
      };
      CombineLatestSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;
          for (var i4 = 0; i4 < len; i4++) {
            var observable2 = observables[i4];
            this.add(subscribeToResult(this, observable2, void 0, i4));
          }
        }
      };
      CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      };
      CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
          if (this.resultSelector) {
            this._tryResultSelector(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      };
      CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
        var result;
        try {
          result = this.resultSelector.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return CombineLatestSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable2 = input[observable]();
      sub.add(observable2.subscribe({
        next: function(value) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleObservable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js"() {
    init_Observable();
    init_Subscription();
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
var init_schedulePromise = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator2;
    sub.add(function() {
      if (iterator2 && typeof iterator2.return === "function") {
        iterator2.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator2 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value;
        var done;
        try {
          var result = iterator2.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
var init_scheduleIterable = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js"() {
    init_Observable();
    init_Subscription();
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
var init_isInteropObservable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isInteropObservable.js"() {
    init_observable();
  }
});

// node_modules/rxjs/_esm5/internal/util/isIterable.js
function isIterable2(input) {
  return input && typeof input[iterator] === "function";
}
var init_isIterable = __esm({
  "node_modules/rxjs/_esm5/internal/util/isIterable.js"() {
    init_iterator();
  }
});

// node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable2(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
var init_scheduled = __esm({
  "node_modules/rxjs/_esm5/internal/scheduled/scheduled.js"() {
    init_scheduleObservable();
    init_schedulePromise();
    init_scheduleArray();
    init_scheduleIterable();
    init_isInteropObservable();
    init_isPromise();
    init_isArrayLike();
    init_isIterable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/from.js
function from3(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var init_from = __esm({
  "node_modules/rxjs/_esm5/internal/observable/from.js"() {
    init_Observable();
    init_subscribeTo();
    init_scheduled();
  }
});

// node_modules/rxjs/_esm5/internal/innerSubscribe.js
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }
  return subscription;
}
var SimpleInnerSubscriber, ComplexInnerSubscriber, SimpleOuterSubscriber, ComplexOuterSubscriber;
var init_innerSubscribe = __esm({
  "node_modules/rxjs/_esm5/internal/innerSubscribe.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_subscribeTo();
    SimpleInnerSubscriber = function(_super) {
      __extends(SimpleInnerSubscriber2, _super);
      function SimpleInnerSubscriber2(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
      }
      SimpleInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(value);
      };
      SimpleInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      SimpleInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete();
        this.unsubscribe();
      };
      return SimpleInnerSubscriber2;
    }(Subscriber);
    ComplexInnerSubscriber = function(_super) {
      __extends(ComplexInnerSubscriber2, _super);
      function ComplexInnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
      }
      ComplexInnerSubscriber2.prototype._next = function(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
      };
      ComplexInnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error);
        this.unsubscribe();
      };
      ComplexInnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return ComplexInnerSubscriber2;
    }(Subscriber);
    SimpleOuterSubscriber = function(_super) {
      __extends(SimpleOuterSubscriber2, _super);
      function SimpleOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      SimpleOuterSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      SimpleOuterSubscriber2.prototype.notifyComplete = function() {
        this.destination.complete();
      };
      return SimpleOuterSubscriber2;
    }(Subscriber);
    ComplexOuterSubscriber = function(_super) {
      __extends(ComplexOuterSubscriber2, _super);
      function ComplexOuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ComplexOuterSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
      };
      ComplexOuterSubscriber2.prototype.notifyError = function(error) {
        this.destination.error(error);
      };
      ComplexOuterSubscriber2.prototype.notifyComplete = function(_innerSub) {
        this.destination.complete();
      };
      return ComplexOuterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a4, i4) {
        return from3(project(a4, i4)).pipe(map2(function(b6, ii) {
          return resultSelector(a4, b6, i4, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator, MergeMapSubscriber, flatMap;
var init_mergeMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    MergeMapOperator = function() {
      function MergeMapOperator2(project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
      }
      MergeMapOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator2;
    }();
    MergeMapSubscriber = function(_super) {
      __extends(MergeMapSubscriber2, _super);
      function MergeMapSubscriber2(destination, project, concurrent) {
        if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeMapSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      };
      MergeMapSubscriber2.prototype._tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.active++;
        this._innerSub(result);
      };
      MergeMapSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      MergeMapSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      };
      return MergeMapSubscriber2;
    }(SimpleOuterSubscriber);
    flatMap = mergeMap;
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity3, concurrent);
}
var init_mergeAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeAll.js"() {
    init_mergeMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}
var init_concatAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatAll.js"() {
    init_mergeAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/concat.js
function concat3() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
var init_concat = __esm({
  "node_modules/rxjs/_esm5/internal/observable/concat.js"() {
    init_of();
    init_concatAll();
  }
});

// node_modules/rxjs/_esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from3(input) : empty4();
    return source.subscribe(subscriber);
  });
}
var init_defer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/defer.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/forkJoin.js
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject2(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys2 = Object.keys(first_1);
      return forkJoinInternal(keys2.map(function(key2) {
        return first_1[key2];
      }), keys2);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map2(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys2) {
  return new Observable(function(subscriber) {
    var len = sources.length;
    if (len === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i5) {
      var source = from3(sources[i5]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i5] = value;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len || !hasValue) {
            if (emitted === len) {
              subscriber.next(keys2 ? keys2.reduce(function(result, key2, i6) {
                return result[key2] = values[i6], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i4 = 0; i4 < len; i4++) {
      _loop_1(i4);
    }
  });
}
var init_forkJoin = __esm({
  "node_modules/rxjs/_esm5/internal/observable/forkJoin.js"() {
    init_Observable();
    init_isArray();
    init_map();
    init_isObject();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEvent.js
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map2(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e3) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e3);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i4 = 0, len = sourceObj.length; i4 < len; i4++) {
      setupSubscription(sourceObj[i4], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
var toString3;
var init_fromEvent = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEvent.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
    toString3 = function() {
      return Object.prototype.toString;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map2(function(args) {
      return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e3 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e3[_i] = arguments[_i];
      }
      return subscriber.next(e3.length === 1 ? e3[0] : e3);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
var init_fromEventPattern = __esm({
  "node_modules/rxjs/_esm5/internal/observable/fromEventPattern.js"() {
    init_Observable();
    init_isArray();
    init_isFunction();
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/observable/generate.js
function generate2(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity3;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity3;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state3 = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state: state3
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state3);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value = void 0;
      try {
        value = resultSelector(state3);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value);
      if (subscriber.closed) {
        break;
      }
      try {
        state3 = iterate(state3);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch4(state3) {
  var subscriber = state3.subscriber, condition = state3.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state3.needIterate) {
    try {
      state3.state = state3.iterate(state3.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state3.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state3.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value;
  try {
    value = state3.resultSelector(state3.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state3);
}
var init_generate = __esm({
  "node_modules/rxjs/_esm5/internal/observable/generate.js"() {
    init_Observable();
    init_identity();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/iif.js
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
var init_iif = __esm({
  "node_modules/rxjs/_esm5/internal/observable/iif.js"() {
    init_defer();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/util/isNumeric.js
function isNumeric(val) {
  return !isArray(val) && val - parseFloat(val) + 1 >= 0;
}
var init_isNumeric = __esm({
  "node_modules/rxjs/_esm5/internal/util/isNumeric.js"() {
    init_isArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/interval.js
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch5, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch5(state3) {
  var subscriber = state3.subscriber, counter = state3.counter, period = state3.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
var init_interval = __esm({
  "node_modules/rxjs/_esm5/internal/observable/interval.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
  }
});

// node_modules/rxjs/_esm5/internal/observable/merge.js
function merge() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var init_merge = __esm({
  "node_modules/rxjs/_esm5/internal/observable/merge.js"() {
    init_Observable();
    init_isScheduler();
    init_mergeAll();
    init_fromArray();
  }
});

// node_modules/rxjs/_esm5/internal/observable/never.js
function never2() {
  return NEVER;
}
var NEVER;
var init_never = __esm({
  "node_modules/rxjs/_esm5/internal/observable/never.js"() {
    init_Observable();
    init_noop();
    NEVER = new Observable(noop);
  }
});

// node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray(first2)) {
    return onErrorResumeNext.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber));
    };
    return from3(first2).subscribe({
      next: function(value) {
        subscriber.next(value);
      },
      error: subNext,
      complete: subNext
    });
  });
}
var init_onErrorResumeNext = __esm({
  "node_modules/rxjs/_esm5/internal/observable/onErrorResumeNext.js"() {
    init_Observable();
    init_from();
    init_isArray();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/pairs.js
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys2 = Object.keys(obj);
      for (var i4 = 0; i4 < keys2.length && !subscriber.closed; i4++) {
        var key2 = keys2[i4];
        if (obj.hasOwnProperty(key2)) {
          subscriber.next([key2, obj[key2]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys2 = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch6, 0, { keys: keys2, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch6(state3) {
  var keys2 = state3.keys, index = state3.index, subscriber = state3.subscriber, subscription = state3.subscription, obj = state3.obj;
  if (!subscriber.closed) {
    if (index < keys2.length) {
      var key2 = keys2[index];
      subscriber.next([key2, obj[key2]]);
      subscription.add(this.schedule({ keys: keys2, index: index + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
var init_pairs = __esm({
  "node_modules/rxjs/_esm5/internal/observable/pairs.js"() {
    init_Observable();
    init_Subscription();
  }
});

// node_modules/rxjs/_esm5/internal/util/not.js
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
var init_not = __esm({
  "node_modules/rxjs/_esm5/internal/util/not.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator, FilterSubscriber;
var init_filter = __esm({
  "node_modules/rxjs/_esm5/internal/operators/filter.js"() {
    init_tslib_es6();
    init_Subscriber();
    FilterOperator = function() {
      function FilterOperator2(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }
      FilterOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator2;
    }();
    FilterSubscriber = function(_super) {
      __extends(FilterSubscriber2, _super);
      function FilterSubscriber2(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
      }
      FilterSubscriber2.prototype._next = function(value) {
        var result;
        try {
          result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.destination.next(value);
        }
      };
      return FilterSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/partition.js
function partition(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
var init_partition = __esm({
  "node_modules/rxjs/_esm5/internal/observable/partition.js"() {
    init_not();
    init_subscribeTo();
    init_filter();
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/race.js
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator, RaceSubscriber;
var init_race = __esm({
  "node_modules/rxjs/_esm5/internal/observable/race.js"() {
    init_tslib_es6();
    init_isArray();
    init_fromArray();
    init_OuterSubscriber();
    init_subscribeToResult();
    RaceOperator = function() {
      function RaceOperator2() {
      }
      RaceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      };
      return RaceOperator2;
    }();
    RaceSubscriber = function(_super) {
      __extends(RaceSubscriber2, _super);
      function RaceSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
      }
      RaceSubscriber2.prototype._next = function(observable2) {
        this.observables.push(observable2);
      };
      RaceSubscriber2.prototype._complete = function() {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
          this.destination.complete();
        } else {
          for (var i4 = 0; i4 < len && !this.hasFirst; i4++) {
            var observable2 = observables[i4];
            var subscription = subscribeToResult(this, observable2, void 0, i4);
            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }
            this.add(subscription);
          }
          this.observables = null;
        }
      };
      RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
          this.hasFirst = true;
          for (var i4 = 0; i4 < this.subscriptions.length; i4++) {
            if (i4 !== outerIndex) {
              var subscription = this.subscriptions[i4];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }
          this.subscriptions = null;
        }
        this.destination.next(innerValue);
      };
      return RaceSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/observable/range.js
function range(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch7, 0, {
        index,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch7(state3) {
  var start = state3.start, index = state3.index, count2 = state3.count, subscriber = state3.subscriber;
  if (index >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state3.index = index + 1;
  state3.start = start + 1;
  this.schedule(state3);
}
var init_range = __esm({
  "node_modules/rxjs/_esm5/internal/observable/range.js"() {
    init_Observable();
  }
});

// node_modules/rxjs/_esm5/internal/observable/timer.js
function timer2(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch8, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch8(state3) {
  var index = state3.index, period = state3.period, subscriber = state3.subscriber;
  subscriber.next(index);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state3.index = index + 1;
  this.schedule(state3, period);
}
var init_timer = __esm({
  "node_modules/rxjs/_esm5/internal/observable/timer.js"() {
    init_Observable();
    init_async();
    init_isNumeric();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/using.js
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from3(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
var init_using = __esm({
  "node_modules/rxjs/_esm5/internal/observable/using.js"() {
    init_Observable();
    init_from();
    init_empty();
  }
});

// node_modules/rxjs/_esm5/internal/observable/zip.js
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator, ZipSubscriber, StaticIterator, StaticArrayIterator, ZipBufferIterator;
var init_zip = __esm({
  "node_modules/rxjs/_esm5/internal/observable/zip.js"() {
    init_tslib_es6();
    init_fromArray();
    init_isArray();
    init_Subscriber();
    init_iterator();
    init_innerSubscribe();
    ZipOperator = function() {
      function ZipOperator2(resultSelector) {
        this.resultSelector = resultSelector;
      }
      ZipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
      };
      return ZipOperator2;
    }();
    ZipSubscriber = function(_super) {
      __extends(ZipSubscriber2, _super);
      function ZipSubscriber2(destination, resultSelector, values) {
        if (values === void 0) {
          values = /* @__PURE__ */ Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
        return _this;
      }
      ZipSubscriber2.prototype._next = function(value) {
        var iterators = this.iterators;
        if (isArray(value)) {
          iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator] === "function") {
          iterators.push(new StaticIterator(value[iterator]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
      };
      ZipSubscriber2.prototype._complete = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
          this.destination.complete();
          return;
        }
        this.active = len;
        for (var i4 = 0; i4 < len; i4++) {
          var iterator2 = iterators[i4];
          if (iterator2.stillUnsubscribed) {
            var destination = this.destination;
            destination.add(iterator2.subscribe());
          } else {
            this.active--;
          }
        }
      };
      ZipSubscriber2.prototype.notifyInactive = function() {
        this.active--;
        if (this.active === 0) {
          this.destination.complete();
        }
      };
      ZipSubscriber2.prototype.checkIterators = function() {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i4 = 0; i4 < len; i4++) {
          var iterator2 = iterators[i4];
          if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
            return;
          }
        }
        var shouldComplete = false;
        var args = [];
        for (var i4 = 0; i4 < len; i4++) {
          var iterator2 = iterators[i4];
          var result = iterator2.next();
          if (iterator2.hasCompleted()) {
            shouldComplete = true;
          }
          if (result.done) {
            destination.complete();
            return;
          }
          args.push(result.value);
        }
        if (this.resultSelector) {
          this._tryresultSelector(args);
        } else {
          destination.next(args);
        }
        if (shouldComplete) {
          destination.complete();
        }
      };
      ZipSubscriber2.prototype._tryresultSelector = function(args) {
        var result;
        try {
          result = this.resultSelector.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return ZipSubscriber2;
    }(Subscriber);
    StaticIterator = function() {
      function StaticIterator2(iterator2) {
        this.iterator = iterator2;
        this.nextResult = iterator2.next();
      }
      StaticIterator2.prototype.hasValue = function() {
        return true;
      };
      StaticIterator2.prototype.next = function() {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      };
      StaticIterator2.prototype.hasCompleted = function() {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
      };
      return StaticIterator2;
    }();
    StaticArrayIterator = function() {
      function StaticArrayIterator2(array2) {
        this.array = array2;
        this.index = 0;
        this.length = 0;
        this.length = array2.length;
      }
      StaticArrayIterator2.prototype[iterator] = function() {
        return this;
      };
      StaticArrayIterator2.prototype.next = function(value) {
        var i4 = this.index++;
        var array2 = this.array;
        return i4 < this.length ? { value: array2[i4], done: false } : { value: null, done: true };
      };
      StaticArrayIterator2.prototype.hasValue = function() {
        return this.array.length > this.index;
      };
      StaticArrayIterator2.prototype.hasCompleted = function() {
        return this.array.length === this.index;
      };
      return StaticArrayIterator2;
    }();
    ZipBufferIterator = function(_super) {
      __extends(ZipBufferIterator2, _super);
      function ZipBufferIterator2(destination, parent, observable2) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable2;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
      }
      ZipBufferIterator2.prototype[iterator] = function() {
        return this;
      };
      ZipBufferIterator2.prototype.next = function() {
        var buffer2 = this.buffer;
        if (buffer2.length === 0 && this.isComplete) {
          return { value: null, done: true };
        } else {
          return { value: buffer2.shift(), done: false };
        }
      };
      ZipBufferIterator2.prototype.hasValue = function() {
        return this.buffer.length > 0;
      };
      ZipBufferIterator2.prototype.hasCompleted = function() {
        return this.buffer.length === 0 && this.isComplete;
      };
      ZipBufferIterator2.prototype.notifyComplete = function() {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      };
      ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      };
      ZipBufferIterator2.prototype.subscribe = function() {
        return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
      };
      return ZipBufferIterator2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/index.js
var esm5_exports = {};
__export(esm5_exports, {
  ArgumentOutOfRangeError: () => ArgumentOutOfRangeError,
  AsyncSubject: () => AsyncSubject,
  BehaviorSubject: () => BehaviorSubject,
  ConnectableObservable: () => ConnectableObservable,
  EMPTY: () => EMPTY,
  EmptyError: () => EmptyError,
  GroupedObservable: () => GroupedObservable,
  NEVER: () => NEVER,
  Notification: () => Notification,
  NotificationKind: () => NotificationKind,
  ObjectUnsubscribedError: () => ObjectUnsubscribedError,
  Observable: () => Observable,
  ReplaySubject: () => ReplaySubject,
  Scheduler: () => Scheduler,
  Subject: () => Subject,
  Subscriber: () => Subscriber,
  Subscription: () => Subscription,
  TimeoutError: () => TimeoutError,
  UnsubscriptionError: () => UnsubscriptionError,
  VirtualAction: () => VirtualAction,
  VirtualTimeScheduler: () => VirtualTimeScheduler,
  animationFrame: () => animationFrame,
  animationFrameScheduler: () => animationFrameScheduler,
  asap: () => asap,
  asapScheduler: () => asapScheduler,
  async: () => async,
  asyncScheduler: () => asyncScheduler,
  bindCallback: () => bindCallback,
  bindNodeCallback: () => bindNodeCallback,
  combineLatest: () => combineLatest,
  concat: () => concat3,
  config: () => config,
  defer: () => defer,
  empty: () => empty4,
  forkJoin: () => forkJoin,
  from: () => from3,
  fromEvent: () => fromEvent,
  fromEventPattern: () => fromEventPattern,
  generate: () => generate2,
  identity: () => identity3,
  iif: () => iif,
  interval: () => interval,
  isObservable: () => isObservable,
  merge: () => merge,
  never: () => never2,
  noop: () => noop,
  observable: () => observable,
  of: () => of,
  onErrorResumeNext: () => onErrorResumeNext,
  pairs: () => pairs,
  partition: () => partition,
  pipe: () => pipe,
  queue: () => queue,
  queueScheduler: () => queueScheduler,
  race: () => race,
  range: () => range,
  scheduled: () => scheduled,
  throwError: () => throwError,
  timer: () => timer2,
  using: () => using,
  zip: () => zip
});
var init_esm5 = __esm({
  "node_modules/rxjs/_esm5/index.js"() {
    init_Observable();
    init_ConnectableObservable();
    init_groupBy();
    init_observable();
    init_Subject();
    init_BehaviorSubject();
    init_ReplaySubject();
    init_AsyncSubject();
    init_asap();
    init_async();
    init_queue();
    init_animationFrame();
    init_VirtualTimeScheduler();
    init_Scheduler();
    init_Subscription();
    init_Subscriber();
    init_Notification();
    init_pipe();
    init_noop();
    init_identity();
    init_isObservable();
    init_ArgumentOutOfRangeError();
    init_EmptyError();
    init_ObjectUnsubscribedError();
    init_UnsubscriptionError();
    init_TimeoutError();
    init_bindCallback();
    init_bindNodeCallback();
    init_combineLatest();
    init_concat();
    init_defer();
    init_empty();
    init_forkJoin();
    init_from();
    init_fromEvent();
    init_fromEventPattern();
    init_generate();
    init_iif();
    init_interval();
    init_merge();
    init_never();
    init_of();
    init_onErrorResumeNext();
    init_pairs();
    init_partition();
    init_race();
    init_range();
    init_throwError();
    init_timer();
    init_using();
    init_zip();
    init_scheduled();
    init_empty();
    init_never();
    init_config();
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r3(e3) {
  var t3, f5, n3 = "";
  if ("string" == typeof e3 || "number" == typeof e3)
    n3 += e3;
  else if ("object" == typeof e3)
    if (Array.isArray(e3))
      for (t3 = 0; t3 < e3.length; t3++)
        e3[t3] && (f5 = r3(e3[t3])) && (n3 && (n3 += " "), n3 += f5);
    else
      for (t3 in e3)
        e3[t3] && (n3 && (n3 += " "), n3 += t3);
  return n3;
}
function clsx() {
  for (var e3, t3, f5 = 0, n3 = ""; f5 < arguments.length; )
    (e3 = arguments[f5++]) && (t3 = r3(e3)) && (n3 && (n3 += " "), n3 += t3);
  return n3;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/preact/hooks/dist/hooks.module.js
var hooks_module_exports = {};
__export(hooks_module_exports, {
  useCallback: () => T3,
  useContext: () => q4,
  useDebugValue: () => x4,
  useEffect: () => p5,
  useErrorBoundary: () => P3,
  useId: () => V4,
  useImperativeHandle: () => A4,
  useLayoutEffect: () => y6,
  useMemo: () => F5,
  useReducer: () => s2,
  useRef: () => _5,
  useState: () => h5
});
function d3(t3, u5) {
  l2.__h && l2.__h(r4, t3, o2 || u5), o2 = 0;
  var i4 = r4.__H || (r4.__H = { __: [], __h: [] });
  return t3 >= i4.__.length && i4.__.push({ __V: c4 }), i4.__[t3];
}
function h5(n3) {
  return o2 = 1, s2(B4, n3);
}
function s2(n3, u5, i4) {
  var o3 = d3(t2++, 2);
  if (o3.t = n3, !o3.__c && (o3.__ = [i4 ? i4(u5) : B4(void 0, u5), function(n4) {
    var t3 = o3.__N ? o3.__N[0] : o3.__[0], r5 = o3.t(t3, n4);
    t3 !== r5 && (o3.__N = [r5, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = r4, !r4.u)) {
    var f5 = function(n4, t3, r5) {
      if (!o3.__c.__H)
        return true;
      var u6 = o3.__c.__H.__.filter(function(n5) {
        return n5.__c;
      });
      if (u6.every(function(n5) {
        return !n5.__N;
      }))
        return !c5 || c5.call(this, n4, t3, r5);
      var i5 = false;
      return u6.forEach(function(n5) {
        if (n5.__N) {
          var t4 = n5.__[0];
          n5.__ = n5.__N, n5.__N = void 0, t4 !== n5.__[0] && (i5 = true);
        }
      }), !(!i5 && o3.__c.props === n4) && (!c5 || c5.call(this, n4, t3, r5));
    };
    r4.u = true;
    var c5 = r4.shouldComponentUpdate, e3 = r4.componentWillUpdate;
    r4.componentWillUpdate = function(n4, t3, r5) {
      if (this.__e) {
        var u6 = c5;
        c5 = void 0, f5(n4, t3, r5), c5 = u6;
      }
      e3 && e3.call(this, n4, t3, r5);
    }, r4.shouldComponentUpdate = f5;
  }
  return o3.__N || o3.__;
}
function p5(u5, i4) {
  var o3 = d3(t2++, 3);
  !l2.__s && z4(o3.__H, i4) && (o3.__ = u5, o3.i = i4, r4.__H.__h.push(o3));
}
function y6(u5, i4) {
  var o3 = d3(t2++, 4);
  !l2.__s && z4(o3.__H, i4) && (o3.__ = u5, o3.i = i4, r4.__h.push(o3));
}
function _5(n3) {
  return o2 = 5, F5(function() {
    return { current: n3 };
  }, []);
}
function A4(n3, t3, r5) {
  o2 = 6, y6(function() {
    return "function" == typeof n3 ? (n3(t3()), function() {
      return n3(null);
    }) : n3 ? (n3.current = t3(), function() {
      return n3.current = null;
    }) : void 0;
  }, null == r5 ? r5 : r5.concat(n3));
}
function F5(n3, r5) {
  var u5 = d3(t2++, 7);
  return z4(u5.__H, r5) ? (u5.__V = n3(), u5.i = r5, u5.__h = n3, u5.__V) : u5.__;
}
function T3(n3, t3) {
  return o2 = 8, F5(function() {
    return n3;
  }, t3);
}
function q4(n3) {
  var u5 = r4.context[n3.__c], i4 = d3(t2++, 9);
  return i4.c = n3, u5 ? (null == i4.__ && (i4.__ = true, u5.sub(r4)), u5.props.value) : n3.__;
}
function x4(t3, r5) {
  l2.useDebugValue && l2.useDebugValue(r5 ? r5(t3) : t3);
}
function P3(n3) {
  var u5 = d3(t2++, 10), i4 = h5();
  return u5.__ = n3, r4.componentDidCatch || (r4.componentDidCatch = function(n4, t3) {
    u5.__ && u5.__(n4, t3), i4[1](n4);
  }), [i4[0], function() {
    i4[1](void 0);
  }];
}
function V4() {
  var n3 = d3(t2++, 11);
  if (!n3.__) {
    for (var u5 = r4.__v; null !== u5 && !u5.__m && null !== u5.__; )
      u5 = u5.__;
    var i4 = u5.__m || (u5.__m = [0, 0]);
    n3.__ = "P" + i4[0] + "-" + i4[1]++;
  }
  return n3.__;
}
function b5() {
  for (var t3; t3 = f4.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k4), t3.__H.__h.forEach(w4), t3.__H.__h = [];
      } catch (r5) {
        t3.__H.__h = [], l2.__e(r5, t3.__v);
      }
}
function j6(n3) {
  var t3, r5 = function() {
    clearTimeout(u5), g6 && cancelAnimationFrame(t3), setTimeout(n3);
  }, u5 = setTimeout(r5, 100);
  g6 && (t3 = requestAnimationFrame(r5));
}
function k4(n3) {
  var t3 = r4, u5 = n3.__c;
  "function" == typeof u5 && (n3.__c = void 0, u5()), r4 = t3;
}
function w4(n3) {
  var t3 = r4;
  n3.__c = n3.__(), r4 = t3;
}
function z4(n3, t3) {
  return !n3 || n3.length !== t3.length || t3.some(function(t4, r5) {
    return t4 !== n3[r5];
  });
}
function B4(n3, t3) {
  return "function" == typeof t3 ? t3(n3) : t3;
}
var t2, r4, u4, i3, o2, f4, c4, e2, a3, v4, l3, m4, g6;
var init_hooks_module = __esm({
  "node_modules/preact/hooks/dist/hooks.module.js"() {
    init_preact_module();
    o2 = 0;
    f4 = [];
    c4 = [];
    e2 = l2.__b;
    a3 = l2.__r;
    v4 = l2.diffed;
    l3 = l2.__c;
    m4 = l2.unmount;
    l2.__b = function(n3) {
      r4 = null, e2 && e2(n3);
    }, l2.__r = function(n3) {
      a3 && a3(n3), t2 = 0;
      var i4 = (r4 = n3.__c).__H;
      i4 && (u4 === r4 ? (i4.__h = [], r4.__h = [], i4.__.forEach(function(n4) {
        n4.__N && (n4.__ = n4.__N), n4.__V = c4, n4.__N = n4.i = void 0;
      })) : (i4.__h.forEach(k4), i4.__h.forEach(w4), i4.__h = [], t2 = 0)), u4 = r4;
    }, l2.diffed = function(t3) {
      v4 && v4(t3);
      var o3 = t3.__c;
      o3 && o3.__H && (o3.__H.__h.length && (1 !== f4.push(o3) && i3 === l2.requestAnimationFrame || ((i3 = l2.requestAnimationFrame) || j6)(b5)), o3.__H.__.forEach(function(n3) {
        n3.i && (n3.__H = n3.i), n3.__V !== c4 && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c4;
      })), u4 = r4 = null;
    }, l2.__c = function(t3, r5) {
      r5.some(function(t4) {
        try {
          t4.__h.forEach(k4), t4.__h = t4.__h.filter(function(n3) {
            return !n3.__ || w4(n3);
          });
        } catch (u5) {
          r5.some(function(n3) {
            n3.__h && (n3.__h = []);
          }), r5 = [], l2.__e(u5, t4.__v);
        }
      }), l3 && l3(t3, r5);
    }, l2.unmount = function(t3) {
      m4 && m4(t3);
      var r5, u5 = t3.__c;
      u5 && u5.__H && (u5.__H.__.forEach(function(n3) {
        try {
          k4(n3);
        } catch (n4) {
          r5 = n4;
        }
      }), u5.__H = void 0, r5 && l2.__e(r5, u5.__v));
    };
    g6 = "function" == typeof requestAnimationFrame;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/CloseIcon.js
var require_CloseIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/CloseIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloseIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function CloseIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
      );
    }
    exports.CloseIcon = CloseIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-round-svg.js
var require_coinbase_round_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-round-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMTQuMDM3IDE4LjkyNmMtMi43NSAwLTQuOTA3LTIuMjA1LTQuOTA3LTQuOTI2IDAtMi43MiAyLjIzLTQuOTI2IDQuOTA3LTQuOTI2YTQuODY2IDQuODY2IDAgMCAxIDQuODMzIDQuMTE4aDQuOTgyYy0uNDQ2LTUuMDczLTQuNjg0LTkuMDQ0LTkuODE1LTkuMDQ0QzguNjEgNC4xNDggNC4xNDkgOC41NiA0LjE0OSAxNHM0LjM4NyA5Ljg1MiA5Ljg5IDkuODUyYzUuMjA0IDAgOS4zNjgtMy45NyA5LjgxNC05LjA0M0gxOC44N2E0Ljg2NiA0Ljg2NiAwIDAgMS00LjgzMyA0LjExN1oiIGZpbGw9IiNmZmYiLz48L3N2Zz4=`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-wallet-round-svg.js
var require_coinbase_wallet_round_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/coinbase-wallet-round-svg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMTQiIGN5PSIxNCIgcj0iMTQiIGZpbGw9IiMwMDUyRkYiLz48cGF0aCBkPSJNMjMuODUyIDE0QTkuODM0IDkuODM0IDAgMCAxIDE0IDIzLjg1MiA5LjgzNCA5LjgzNCAwIDAgMSA0LjE0OCAxNCA5LjgzNCA5LjgzNCAwIDAgMSAxNCA0LjE0OCA5LjgzNCA5LjgzNCAwIDAgMSAyMy44NTIgMTRaIiBmaWxsPSIjZmZmIi8+PHBhdGggZD0iTTExLjE4NSAxMi41MDRjMC0uNDU2IDAtLjcxLjA5OC0uODYyLjA5OC0uMTUyLjE5Ni0uMzA0LjM0My0uMzU1LjE5Ni0uMTAyLjM5Mi0uMTAyLjg4MS0uMTAyaDIuOTg2Yy40OSAwIC42ODYgMCAuODgyLjEwMi4xNDYuMTAxLjI5My4yMDMuMzQyLjM1NS4wOTguMjAzLjA5OC40MDYuMDk4Ljg2MnYyLjk5MmMwIC40NTcgMCAuNzEtLjA5OC44NjMtLjA5OC4xNTItLjE5NS4zMDQtLjM0Mi4zNTUtLjE5Ni4xMDEtLjM5Mi4xMDEtLjg4Mi4xMDFoLTIuOTg2Yy0uNDkgMC0uNjg1IDAtLjg4LS4xMDEtLjE0OC0uMTAyLS4yOTUtLjIwMy0uMzQ0LS4zNTUtLjA5OC0uMjAzLS4wOTgtLjQwNi0uMDk4LS44NjN2LTIuOTkyWiIgZmlsbD0iIzAwNTJGRiIvPjwvc3ZnPg==`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRCodeIcon.js
var require_QRCodeIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRCodeIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCodeIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function QRCodeIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M8.2271 1.77124L7.0271 1.77124V2.97124H8.2271V1.77124Z" }),
        (0, preact_1.h)("path", { d: "M5.44922 0.199219L5.44922 4.54922L9.79922 4.54922V0.199219L5.44922 0.199219ZM8.89922 3.64922L6.34922 3.64922L6.34922 1.09922L8.89922 1.09922V3.64922Z" }),
        (0, preact_1.h)("path", { d: "M2.97124 1.77124L1.77124 1.77124L1.77124 2.97124H2.97124V1.77124Z" }),
        (0, preact_1.h)("path", { d: "M0.199219 4.54922L4.54922 4.54922L4.54922 0.199219L0.199219 0.199219L0.199219 4.54922ZM1.09922 1.09922L3.64922 1.09922L3.64922 3.64922L1.09922 3.64922L1.09922 1.09922Z" }),
        (0, preact_1.h)("path", { d: "M2.97124 7.0271H1.77124L1.77124 8.2271H2.97124V7.0271Z" }),
        (0, preact_1.h)("path", { d: "M0.199219 9.79922H4.54922L4.54922 5.44922L0.199219 5.44922L0.199219 9.79922ZM1.09922 6.34922L3.64922 6.34922L3.64922 8.89922H1.09922L1.09922 6.34922Z" }),
        (0, preact_1.h)("path", { d: "M8.89922 7.39912H7.99922V5.40112H5.44922L5.44922 9.79912H6.34922L6.34922 6.30112H7.09922V8.29912H9.79922V5.40112H8.89922V7.39912Z" }),
        (0, preact_1.h)("path", { d: "M7.99912 8.89917H7.09912V9.79917H7.99912V8.89917Z" }),
        (0, preact_1.h)("path", { d: "M9.79917 8.89917H8.89917V9.79917H9.79917V8.89917Z" })
      );
    }
    exports.QRCodeIcon = QRCodeIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoCoinbase.js
var require_QRLogoCoinbase = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoCoinbase.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var svg = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M50 100C77.6142 100 100 77.6142 100 50C100 22.3858 77.6142 0 50 0C22.3858 0 0 22.3858 0 50C0 77.6142 22.3858 100 50 100Z" fill="white"/>
        <path d="M50.512 94C74.2907 94 93.5673 74.5244 93.5673 50.5C93.5673 26.4756 74.2907 7 50.512 7C26.7332 7 7.45667 26.4756 7.45667 50.5C7.45667 74.5244 26.7332 94 50.512 94Z" fill="#0052FF"/>
        <path d="M50.6248 65.4335C42.3697 65.4335 35.8996 58.7469 35.8996 50.5C35.8996 42.2531 42.5928 35.5664 50.6248 35.5664C57.9873 35.5664 64.0111 40.9157 65.1267 48.0481H80.0749C78.7363 32.6688 66.0191 20.6328 50.6248 20.6328C34.3379 20.6328 20.9514 34.0062 20.9514 50.5C20.9514 66.9936 34.1148 80.3671 50.6248 80.3671C66.2422 80.3671 78.7363 68.331 80.0749 52.9516H65.1267C64.0111 60.0841 57.9873 65.4335 50.6248 65.4335Z" fill="white"/>
    </svg>
`;
    exports.default = svg;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoWallet.js
var require_QRLogoWallet = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/QRLogoWallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `
    <svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="50" cy="50" r="50" fill="white"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
        <circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
        <path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
    </svg>
`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/StatusDotIcon.js
var require_StatusDotIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/StatusDotIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StatusDotIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function StatusDotIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "10", height: "10", viewBox: "0 0 10 10", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M2.29995 4.99995C2.29995 5.57985 1.82985 6.04995 1.24995 6.04995C0.670052 6.04995 0.199951 5.57985 0.199951 4.99995C0.199951 4.42005 0.670052 3.94995 1.24995 3.94995C1.82985 3.94995 2.29995 4.42005 2.29995 4.99995ZM4.99995 6.04995C5.57985 6.04995 6.04995 5.57985 6.04995 4.99995C6.04995 4.42005 5.57985 3.94995 4.99995 3.94995C4.42005 3.94995 3.94995 4.42005 3.94995 4.99995C3.94995 5.57985 4.42005 6.04995 4.99995 6.04995ZM8.74995 6.04995C9.32985 6.04995 9.79995 5.57985 9.79995 4.99995C9.79995 4.42005 9.32985 3.94995 8.74995 3.94995C8.17005 3.94995 7.69995 4.42005 7.69995 4.99995C7.69995 5.57985 8.17005 6.04995 8.74995 6.04995Z" })
      );
    }
    exports.StatusDotIcon = StatusDotIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js
var require_qrcode_svg = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/vendor-js/qrcode-svg/index.js"(exports, module) {
    function QR8bitByte(data3) {
      this.mode = QRMode.MODE_8BIT_BYTE;
      this.data = data3;
      this.parsedData = [];
      for (var i5 = 0, l4 = this.data.length; i5 < l4; i5++) {
        var byteArray = [];
        var code2 = this.data.charCodeAt(i5);
        if (code2 > 65536) {
          byteArray[0] = 240 | (code2 & 1835008) >>> 18;
          byteArray[1] = 128 | (code2 & 258048) >>> 12;
          byteArray[2] = 128 | (code2 & 4032) >>> 6;
          byteArray[3] = 128 | code2 & 63;
        } else if (code2 > 2048) {
          byteArray[0] = 224 | (code2 & 61440) >>> 12;
          byteArray[1] = 128 | (code2 & 4032) >>> 6;
          byteArray[2] = 128 | code2 & 63;
        } else if (code2 > 128) {
          byteArray[0] = 192 | (code2 & 1984) >>> 6;
          byteArray[1] = 128 | code2 & 63;
        } else {
          byteArray[0] = code2;
        }
        this.parsedData.push(byteArray);
      }
      this.parsedData = Array.prototype.concat.apply([], this.parsedData);
      if (this.parsedData.length != this.data.length) {
        this.parsedData.unshift(191);
        this.parsedData.unshift(187);
        this.parsedData.unshift(239);
      }
    }
    QR8bitByte.prototype = {
      getLength: function(buffer2) {
        return this.parsedData.length;
      },
      write: function(buffer2) {
        for (var i5 = 0, l4 = this.parsedData.length; i5 < l4; i5++) {
          buffer2.put(this.parsedData[i5], 8);
        }
      }
    };
    function QRCodeModel(typeNumber, errorCorrectLevel) {
      this.typeNumber = typeNumber;
      this.errorCorrectLevel = errorCorrectLevel;
      this.modules = null;
      this.moduleCount = 0;
      this.dataCache = null;
      this.dataList = [];
    }
    QRCodeModel.prototype = { addData: function(data3) {
      var newData = new QR8bitByte(data3);
      this.dataList.push(newData);
      this.dataCache = null;
    }, isDark: function(row, col) {
      if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
        throw new Error(row + "," + col);
      }
      return this.modules[row][col];
    }, getModuleCount: function() {
      return this.moduleCount;
    }, make: function() {
      this.makeImpl(false, this.getBestMaskPattern());
    }, makeImpl: function(test, maskPattern) {
      this.moduleCount = this.typeNumber * 4 + 17;
      this.modules = new Array(this.moduleCount);
      for (var row = 0; row < this.moduleCount; row++) {
        this.modules[row] = new Array(this.moduleCount);
        for (var col = 0; col < this.moduleCount; col++) {
          this.modules[row][col] = null;
        }
      }
      this.setupPositionProbePattern(0, 0);
      this.setupPositionProbePattern(this.moduleCount - 7, 0);
      this.setupPositionProbePattern(0, this.moduleCount - 7);
      this.setupPositionAdjustPattern();
      this.setupTimingPattern();
      this.setupTypeInfo(test, maskPattern);
      if (this.typeNumber >= 7) {
        this.setupTypeNumber(test);
      }
      if (this.dataCache == null) {
        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
      }
      this.mapData(this.dataCache, maskPattern);
    }, setupPositionProbePattern: function(row, col) {
      for (var r5 = -1; r5 <= 7; r5++) {
        if (row + r5 <= -1 || this.moduleCount <= row + r5)
          continue;
        for (var c5 = -1; c5 <= 7; c5++) {
          if (col + c5 <= -1 || this.moduleCount <= col + c5)
            continue;
          if (0 <= r5 && r5 <= 6 && (c5 == 0 || c5 == 6) || 0 <= c5 && c5 <= 6 && (r5 == 0 || r5 == 6) || 2 <= r5 && r5 <= 4 && 2 <= c5 && c5 <= 4) {
            this.modules[row + r5][col + c5] = true;
          } else {
            this.modules[row + r5][col + c5] = false;
          }
        }
      }
    }, getBestMaskPattern: function() {
      var minLostPoint = 0;
      var pattern2 = 0;
      for (var i5 = 0; i5 < 8; i5++) {
        this.makeImpl(true, i5);
        var lostPoint = QRUtil.getLostPoint(this);
        if (i5 == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern2 = i5;
        }
      }
      return pattern2;
    }, createMovieClip: function(target_mc, instance_name, depth) {
      var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
      var cs3 = 1;
      this.make();
      for (var row = 0; row < this.modules.length; row++) {
        var y7 = row * cs3;
        for (var col = 0; col < this.modules[row].length; col++) {
          var x5 = col * cs3;
          var dark = this.modules[row][col];
          if (dark) {
            qr_mc.beginFill(0, 100);
            qr_mc.moveTo(x5, y7);
            qr_mc.lineTo(x5 + cs3, y7);
            qr_mc.lineTo(x5 + cs3, y7 + cs3);
            qr_mc.lineTo(x5, y7 + cs3);
            qr_mc.endFill();
          }
        }
      }
      return qr_mc;
    }, setupTimingPattern: function() {
      for (var r5 = 8; r5 < this.moduleCount - 8; r5++) {
        if (this.modules[r5][6] != null) {
          continue;
        }
        this.modules[r5][6] = r5 % 2 == 0;
      }
      for (var c5 = 8; c5 < this.moduleCount - 8; c5++) {
        if (this.modules[6][c5] != null) {
          continue;
        }
        this.modules[6][c5] = c5 % 2 == 0;
      }
    }, setupPositionAdjustPattern: function() {
      var pos = QRUtil.getPatternPosition(this.typeNumber);
      for (var i5 = 0; i5 < pos.length; i5++) {
        for (var j7 = 0; j7 < pos.length; j7++) {
          var row = pos[i5];
          var col = pos[j7];
          if (this.modules[row][col] != null) {
            continue;
          }
          for (var r5 = -2; r5 <= 2; r5++) {
            for (var c5 = -2; c5 <= 2; c5++) {
              if (r5 == -2 || r5 == 2 || c5 == -2 || c5 == 2 || r5 == 0 && c5 == 0) {
                this.modules[row + r5][col + c5] = true;
              } else {
                this.modules[row + r5][col + c5] = false;
              }
            }
          }
        }
      }
    }, setupTypeNumber: function(test) {
      var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
      for (var i5 = 0; i5 < 18; i5++) {
        var mod = !test && (bits >> i5 & 1) == 1;
        this.modules[Math.floor(i5 / 3)][i5 % 3 + this.moduleCount - 8 - 3] = mod;
      }
      for (var i5 = 0; i5 < 18; i5++) {
        var mod = !test && (bits >> i5 & 1) == 1;
        this.modules[i5 % 3 + this.moduleCount - 8 - 3][Math.floor(i5 / 3)] = mod;
      }
    }, setupTypeInfo: function(test, maskPattern) {
      var data3 = this.errorCorrectLevel << 3 | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data3);
      for (var i5 = 0; i5 < 15; i5++) {
        var mod = !test && (bits >> i5 & 1) == 1;
        if (i5 < 6) {
          this.modules[i5][8] = mod;
        } else if (i5 < 8) {
          this.modules[i5 + 1][8] = mod;
        } else {
          this.modules[this.moduleCount - 15 + i5][8] = mod;
        }
      }
      for (var i5 = 0; i5 < 15; i5++) {
        var mod = !test && (bits >> i5 & 1) == 1;
        if (i5 < 8) {
          this.modules[8][this.moduleCount - i5 - 1] = mod;
        } else if (i5 < 9) {
          this.modules[8][15 - i5 - 1 + 1] = mod;
        } else {
          this.modules[8][15 - i5 - 1] = mod;
        }
      }
      this.modules[this.moduleCount - 8][8] = !test;
    }, mapData: function(data3, maskPattern) {
      var inc = -1;
      var row = this.moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      for (var col = this.moduleCount - 1; col > 0; col -= 2) {
        if (col == 6)
          col--;
        while (true) {
          for (var c5 = 0; c5 < 2; c5++) {
            if (this.modules[row][col - c5] == null) {
              var dark = false;
              if (byteIndex < data3.length) {
                dark = (data3[byteIndex] >>> bitIndex & 1) == 1;
              }
              var mask2 = QRUtil.getMask(maskPattern, row, col - c5);
              if (mask2) {
                dark = !dark;
              }
              this.modules[row][col - c5] = dark;
              bitIndex--;
              if (bitIndex == -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || this.moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    } };
    QRCodeModel.PAD0 = 236;
    QRCodeModel.PAD1 = 17;
    QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
      var buffer2 = new QRBitBuffer();
      for (var i5 = 0; i5 < dataList.length; i5++) {
        var data3 = dataList[i5];
        buffer2.put(data3.mode, 4);
        buffer2.put(data3.getLength(), QRUtil.getLengthInBits(data3.mode, typeNumber));
        data3.write(buffer2);
      }
      var totalDataCount = 0;
      for (var i5 = 0; i5 < rsBlocks.length; i5++) {
        totalDataCount += rsBlocks[i5].dataCount;
      }
      if (buffer2.getLengthInBits() > totalDataCount * 8) {
        throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
      }
      if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer2.put(0, 4);
      }
      while (buffer2.getLengthInBits() % 8 != 0) {
        buffer2.putBit(false);
      }
      while (true) {
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD0, 8);
        if (buffer2.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer2.put(QRCodeModel.PAD1, 8);
      }
      return QRCodeModel.createBytes(buffer2, rsBlocks);
    };
    QRCodeModel.createBytes = function(buffer2, rsBlocks) {
      var offset = 0;
      var maxDcCount = 0;
      var maxEcCount = 0;
      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);
      for (var r5 = 0; r5 < rsBlocks.length; r5++) {
        var dcCount = rsBlocks[r5].dataCount;
        var ecCount = rsBlocks[r5].totalCount - dcCount;
        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);
        dcdata[r5] = new Array(dcCount);
        for (var i5 = 0; i5 < dcdata[r5].length; i5++) {
          dcdata[r5][i5] = 255 & buffer2.buffer[i5 + offset];
        }
        offset += dcCount;
        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = new QRPolynomial(dcdata[r5], rsPoly.getLength() - 1);
        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r5] = new Array(rsPoly.getLength() - 1);
        for (var i5 = 0; i5 < ecdata[r5].length; i5++) {
          var modIndex = i5 + modPoly.getLength() - ecdata[r5].length;
          ecdata[r5][i5] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
        }
      }
      var totalCodeCount = 0;
      for (var i5 = 0; i5 < rsBlocks.length; i5++) {
        totalCodeCount += rsBlocks[i5].totalCount;
      }
      var data3 = new Array(totalCodeCount);
      var index = 0;
      for (var i5 = 0; i5 < maxDcCount; i5++) {
        for (var r5 = 0; r5 < rsBlocks.length; r5++) {
          if (i5 < dcdata[r5].length) {
            data3[index++] = dcdata[r5][i5];
          }
        }
      }
      for (var i5 = 0; i5 < maxEcCount; i5++) {
        for (var r5 = 0; r5 < rsBlocks.length; r5++) {
          if (i5 < ecdata[r5].length) {
            data3[index++] = ecdata[r5][i5];
          }
        }
      }
      return data3;
    };
    var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
    var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
    var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
    var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data3) {
      var d4 = data3 << 10;
      while (QRUtil.getBCHDigit(d4) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
        d4 ^= QRUtil.G15 << QRUtil.getBCHDigit(d4) - QRUtil.getBCHDigit(QRUtil.G15);
      }
      return (data3 << 10 | d4) ^ QRUtil.G15_MASK;
    }, getBCHTypeNumber: function(data3) {
      var d4 = data3 << 12;
      while (QRUtil.getBCHDigit(d4) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
        d4 ^= QRUtil.G18 << QRUtil.getBCHDigit(d4) - QRUtil.getBCHDigit(QRUtil.G18);
      }
      return data3 << 12 | d4;
    }, getBCHDigit: function(data3) {
      var digit = 0;
      while (data3 != 0) {
        digit++;
        data3 >>>= 1;
      }
      return digit;
    }, getPatternPosition: function(typeNumber) {
      return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    }, getMask: function(maskPattern, i5, j7) {
      switch (maskPattern) {
        case QRMaskPattern.PATTERN000:
          return (i5 + j7) % 2 == 0;
        case QRMaskPattern.PATTERN001:
          return i5 % 2 == 0;
        case QRMaskPattern.PATTERN010:
          return j7 % 3 == 0;
        case QRMaskPattern.PATTERN011:
          return (i5 + j7) % 3 == 0;
        case QRMaskPattern.PATTERN100:
          return (Math.floor(i5 / 2) + Math.floor(j7 / 3)) % 2 == 0;
        case QRMaskPattern.PATTERN101:
          return i5 * j7 % 2 + i5 * j7 % 3 == 0;
        case QRMaskPattern.PATTERN110:
          return (i5 * j7 % 2 + i5 * j7 % 3) % 2 == 0;
        case QRMaskPattern.PATTERN111:
          return (i5 * j7 % 3 + (i5 + j7) % 2) % 2 == 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }, getErrorCorrectPolynomial: function(errorCorrectLength) {
      var a4 = new QRPolynomial([1], 0);
      for (var i5 = 0; i5 < errorCorrectLength; i5++) {
        a4 = a4.multiply(new QRPolynomial([1, QRMath.gexp(i5)], 0));
      }
      return a4;
    }, getLengthInBits: function(mode, type2) {
      if (1 <= type2 && type2 < 10) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 10;
          case QRMode.MODE_ALPHA_NUM:
            return 9;
          case QRMode.MODE_8BIT_BYTE:
            return 8;
          case QRMode.MODE_KANJI:
            return 8;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type2 < 27) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 12;
          case QRMode.MODE_ALPHA_NUM:
            return 11;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 10;
          default:
            throw new Error("mode:" + mode);
        }
      } else if (type2 < 41) {
        switch (mode) {
          case QRMode.MODE_NUMBER:
            return 14;
          case QRMode.MODE_ALPHA_NUM:
            return 13;
          case QRMode.MODE_8BIT_BYTE:
            return 16;
          case QRMode.MODE_KANJI:
            return 12;
          default:
            throw new Error("mode:" + mode);
        }
      } else {
        throw new Error("type:" + type2);
      }
    }, getLostPoint: function(qrCode) {
      var moduleCount = qrCode.getModuleCount();
      var lostPoint = 0;
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount; col++) {
          var sameCount = 0;
          var dark = qrCode.isDark(row, col);
          for (var r5 = -1; r5 <= 1; r5++) {
            if (row + r5 < 0 || moduleCount <= row + r5) {
              continue;
            }
            for (var c5 = -1; c5 <= 1; c5++) {
              if (col + c5 < 0 || moduleCount <= col + c5) {
                continue;
              }
              if (r5 == 0 && c5 == 0) {
                continue;
              }
              if (dark == qrCode.isDark(row + r5, col + c5)) {
                sameCount++;
              }
            }
          }
          if (sameCount > 5) {
            lostPoint += 3 + sameCount - 5;
          }
        }
      }
      for (var row = 0; row < moduleCount - 1; row++) {
        for (var col = 0; col < moduleCount - 1; col++) {
          var count2 = 0;
          if (qrCode.isDark(row, col))
            count2++;
          if (qrCode.isDark(row + 1, col))
            count2++;
          if (qrCode.isDark(row, col + 1))
            count2++;
          if (qrCode.isDark(row + 1, col + 1))
            count2++;
          if (count2 == 0 || count2 == 4) {
            lostPoint += 3;
          }
        }
      }
      for (var row = 0; row < moduleCount; row++) {
        for (var col = 0; col < moduleCount - 6; col++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
            lostPoint += 40;
          }
        }
      }
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount - 6; row++) {
          if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
            lostPoint += 40;
          }
        }
      }
      var darkCount = 0;
      for (var col = 0; col < moduleCount; col++) {
        for (var row = 0; row < moduleCount; row++) {
          if (qrCode.isDark(row, col)) {
            darkCount++;
          }
        }
      }
      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;
      return lostPoint;
    } };
    var QRMath = { glog: function(n3) {
      if (n3 < 1) {
        throw new Error("glog(" + n3 + ")");
      }
      return QRMath.LOG_TABLE[n3];
    }, gexp: function(n3) {
      while (n3 < 0) {
        n3 += 255;
      }
      while (n3 >= 256) {
        n3 -= 255;
      }
      return QRMath.EXP_TABLE[n3];
    }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
    for (i4 = 0; i4 < 8; i4++) {
      QRMath.EXP_TABLE[i4] = 1 << i4;
    }
    var i4;
    for (i4 = 8; i4 < 256; i4++) {
      QRMath.EXP_TABLE[i4] = QRMath.EXP_TABLE[i4 - 4] ^ QRMath.EXP_TABLE[i4 - 5] ^ QRMath.EXP_TABLE[i4 - 6] ^ QRMath.EXP_TABLE[i4 - 8];
    }
    var i4;
    for (i4 = 0; i4 < 255; i4++) {
      QRMath.LOG_TABLE[QRMath.EXP_TABLE[i4]] = i4;
    }
    var i4;
    function QRPolynomial(num, shift) {
      if (num.length == void 0) {
        throw new Error(num.length + "/" + shift);
      }
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset++;
      }
      this.num = new Array(num.length - offset + shift);
      for (var i5 = 0; i5 < num.length - offset; i5++) {
        this.num[i5] = num[i5 + offset];
      }
    }
    QRPolynomial.prototype = { get: function(index) {
      return this.num[index];
    }, getLength: function() {
      return this.num.length;
    }, multiply: function(e3) {
      var num = new Array(this.getLength() + e3.getLength() - 1);
      for (var i5 = 0; i5 < this.getLength(); i5++) {
        for (var j7 = 0; j7 < e3.getLength(); j7++) {
          num[i5 + j7] ^= QRMath.gexp(QRMath.glog(this.get(i5)) + QRMath.glog(e3.get(j7)));
        }
      }
      return new QRPolynomial(num, 0);
    }, mod: function(e3) {
      if (this.getLength() - e3.getLength() < 0) {
        return this;
      }
      var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e3.get(0));
      var num = new Array(this.getLength());
      for (var i5 = 0; i5 < this.getLength(); i5++) {
        num[i5] = this.get(i5);
      }
      for (var i5 = 0; i5 < e3.getLength(); i5++) {
        num[i5] ^= QRMath.gexp(QRMath.glog(e3.get(i5)) + ratio);
      }
      return new QRPolynomial(num, 0).mod(e3);
    } };
    function QRRSBlock(totalCount, dataCount) {
      this.totalCount = totalCount;
      this.dataCount = dataCount;
    }
    QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
    QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
      var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
      if (rsBlock == void 0) {
        throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
      }
      var length2 = rsBlock.length / 3;
      var list = [];
      for (var i5 = 0; i5 < length2; i5++) {
        var count2 = rsBlock[i5 * 3 + 0];
        var totalCount = rsBlock[i5 * 3 + 1];
        var dataCount = rsBlock[i5 * 3 + 2];
        for (var j7 = 0; j7 < count2; j7++) {
          list.push(new QRRSBlock(totalCount, dataCount));
        }
      }
      return list;
    };
    QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
      switch (errorCorrectLevel) {
        case QRErrorCorrectLevel.L:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
        case QRErrorCorrectLevel.M:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
        case QRErrorCorrectLevel.Q:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
        case QRErrorCorrectLevel.H:
          return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    function QRBitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    QRBitBuffer.prototype = { get: function(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;
    }, put: function(num, length2) {
      for (var i5 = 0; i5 < length2; i5++) {
        this.putBit((num >>> length2 - i5 - 1 & 1) == 1);
      }
    }, getLengthInBits: function() {
      return this.length;
    }, putBit: function(bit) {
      var bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    } };
    var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
    function QRCode(options) {
      var instance2 = this;
      this.options = {
        padding: 4,
        width: 256,
        height: 256,
        typeNumber: 4,
        color: "#000000",
        background: "#ffffff",
        ecl: "M",
        image: {
          svg: "",
          width: 0,
          height: 0
        }
      };
      if (typeof options === "string") {
        options = {
          content: options
        };
      }
      if (options) {
        for (var i5 in options) {
          this.options[i5] = options[i5];
        }
      }
      if (typeof this.options.content !== "string") {
        throw new Error("Expected 'content' as string!");
      }
      if (this.options.content.length === 0) {
        throw new Error("Expected 'content' to be non-empty!");
      }
      if (!(this.options.padding >= 0)) {
        throw new Error("Expected 'padding' value to be non-negative!");
      }
      if (!(this.options.width > 0) || !(this.options.height > 0)) {
        throw new Error("Expected 'width' or 'height' value to be higher than zero!");
      }
      function _getErrorCorrectLevel(ecl2) {
        switch (ecl2) {
          case "L":
            return QRErrorCorrectLevel.L;
          case "M":
            return QRErrorCorrectLevel.M;
          case "Q":
            return QRErrorCorrectLevel.Q;
          case "H":
            return QRErrorCorrectLevel.H;
          default:
            throw new Error("Unknwon error correction level: " + ecl2);
        }
      }
      function _getTypeNumber(content2, ecl2) {
        var length2 = _getUTF8Length(content2);
        var type3 = 1;
        var limit = 0;
        for (var i6 = 0, len = QRCodeLimitLength.length; i6 <= len; i6++) {
          var table = QRCodeLimitLength[i6];
          if (!table) {
            throw new Error("Content too long: expected " + limit + " but got " + length2);
          }
          switch (ecl2) {
            case "L":
              limit = table[0];
              break;
            case "M":
              limit = table[1];
              break;
            case "Q":
              limit = table[2];
              break;
            case "H":
              limit = table[3];
              break;
            default:
              throw new Error("Unknwon error correction level: " + ecl2);
          }
          if (length2 <= limit) {
            break;
          }
          type3++;
        }
        if (type3 > QRCodeLimitLength.length) {
          throw new Error("Content too long");
        }
        return type3;
      }
      function _getUTF8Length(content2) {
        var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
        return result.length + (result.length != content2 ? 3 : 0);
      }
      var content = this.options.content;
      var type2 = _getTypeNumber(content, this.options.ecl);
      var ecl = _getErrorCorrectLevel(this.options.ecl);
      this.qrcode = new QRCodeModel(type2, ecl);
      this.qrcode.addData(content);
      this.qrcode.make();
    }
    QRCode.prototype.svg = function(opt) {
      var options = this.options || {};
      var modules = this.qrcode.modules;
      if (typeof opt == "undefined") {
        opt = { container: options.container || "svg" };
      }
      var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
      var indent = pretty ? "  " : "";
      var EOL = pretty ? "\r\n" : "";
      var width = options.width;
      var height = options.height;
      var length2 = modules.length;
      var xsize = width / (length2 + 2 * options.padding);
      var ysize = height / (length2 + 2 * options.padding);
      var join = typeof options.join != "undefined" ? !!options.join : false;
      var swap = typeof options.swap != "undefined" ? !!options.swap : false;
      var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
      var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
      var defs = predefined ? indent + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
      var bgrect = indent + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
      var modrect = "";
      var pathdata = "";
      for (var y7 = 0; y7 < length2; y7++) {
        for (var x5 = 0; x5 < length2; x5++) {
          var module2 = modules[x5][y7];
          if (module2) {
            var px = x5 * xsize + options.padding * xsize;
            var py = y7 * ysize + options.padding * ysize;
            if (swap) {
              var t3 = px;
              px = py;
              py = t3;
            }
            if (join) {
              var w5 = xsize + px;
              var h6 = ysize + py;
              px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
              py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
              w5 = Number.isInteger(w5) ? Number(w5) : w5.toFixed(2);
              h6 = Number.isInteger(h6) ? Number(h6) : h6.toFixed(2);
              pathdata += "M" + px + "," + py + " V" + h6 + " H" + w5 + " V" + py + " H" + px + " Z ";
            } else if (predefined) {
              modrect += indent + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
            } else {
              modrect += indent + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
            }
          }
        }
      }
      if (join) {
        modrect = indent + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
      }
      let imgSvg = "";
      if (this.options.image !== void 0 && this.options.image.svg) {
        const imgWidth = width * this.options.image.width / 100;
        const imgHeight = height * this.options.image.height / 100;
        const imgX = width / 2 - imgWidth / 2;
        const imgY = height / 2 - imgHeight / 2;
        imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
        imgSvg += this.options.image.svg + EOL;
        imgSvg += "</svg>";
      }
      var svg = "";
      switch (opt.container) {
        case "svg":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "svg-viewbox":
          if (xmlDeclaration) {
            svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
          }
          svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</svg>";
          break;
        case "g":
          svg += '<g width="' + width + '" height="' + height + '">' + EOL;
          svg += defs + bgrect + modrect;
          svg += imgSvg;
          svg += "</g>";
          break;
        default:
          svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
          break;
      }
      return svg;
    };
    module.exports = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js
var require_QRCode = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/QRCode.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QRCode = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var qrcode_svg_1 = __importDefault3(require_qrcode_svg());
    var QRCode = (props) => {
      const [svg, setSvg] = (0, hooks_1.useState)("");
      (0, hooks_1.useEffect)(() => {
        var _a2, _b;
        const qrcode = new qrcode_svg_1.default({
          content: props.content,
          background: props.bgColor || "#ffffff",
          color: props.fgColor || "#000000",
          container: "svg",
          ecl: "M",
          width: (_a2 = props.width) !== null && _a2 !== void 0 ? _a2 : 256,
          height: (_b = props.height) !== null && _b !== void 0 ? _b : 256,
          padding: 0,
          image: props.image
        });
        const base642 = Buffer.from(qrcode.svg(), "utf8").toString("base64");
        setSvg(`data:image/svg+xml;base64,${base642}`);
      });
      return svg ? (0, preact_1.h)("img", { src: svg, alt: "QR Code" }) : null;
    };
    exports.QRCode = QRCode;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner-css.js
var require_Spinner_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner.js
var require_Spinner = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Spinner/Spinner.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Spinner = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var Spinner_css_1 = __importDefault3(require_Spinner_css());
    var Spinner = (props) => {
      var _a2;
      const size2 = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : 64;
      const color = props.color || "#000";
      return (0, preact_1.h)(
        "div",
        { class: "-cbwsdk-spinner" },
        (0, preact_1.h)("style", null, Spinner_css_1.default),
        (0, preact_1.h)(
          "svg",
          { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size2, height: size2 } },
          (0, preact_1.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })
        )
      );
    };
    exports.Spinner = Spinner;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent-css.js
var require_ConnectContent_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-item.light.selected{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark.selected{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item.selected{border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent.js
var require_ConnectContent = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectContent/ConnectContent.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseAppSteps = exports.CoinbaseWalletSteps = exports.ConnectItem = exports.ConnectContent = void 0;
    var clsx_1 = __importDefault3((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var util_1 = require_util2();
    var version_1 = require_version();
    var CloseIcon_1 = require_CloseIcon();
    var coinbase_round_svg_1 = __importDefault3(require_coinbase_round_svg());
    var coinbase_wallet_round_svg_1 = __importDefault3(require_coinbase_wallet_round_svg());
    var QRCodeIcon_1 = require_QRCodeIcon();
    var QRLogoCoinbase_1 = __importDefault3(require_QRLogoCoinbase());
    var QRLogoWallet_1 = __importDefault3(require_QRLogoWallet());
    var StatusDotIcon_1 = require_StatusDotIcon();
    var QRCode_1 = require_QRCode();
    var Spinner_1 = require_Spinner();
    var ConnectContent_css_1 = __importDefault3(require_ConnectContent_css());
    var wallets = {
      "coinbase-wallet-app": {
        title: "Coinbase Wallet app",
        description: "Connect with your self-custody wallet",
        icon: coinbase_wallet_round_svg_1.default,
        steps: CoinbaseWalletSteps
      },
      "coinbase-app": {
        title: "Coinbase app",
        description: "Connect with your Coinbase account",
        icon: coinbase_round_svg_1.default,
        steps: CoinbaseAppSteps
      }
    };
    var makeQrCodeImage = (app) => {
      switch (app) {
        case "coinbase-app":
          return QRLogoCoinbase_1.default;
        case "coinbase-wallet-app":
        default:
          return QRLogoWallet_1.default;
      }
    };
    var makeIconColor = (theme) => {
      return theme === "light" ? "#FFFFFF" : "#0A0B0D";
    };
    function ConnectContent(props) {
      const { theme } = props;
      const [selected, setSelected] = (0, hooks_1.useState)("coinbase-wallet-app");
      const handleSelect = (0, hooks_1.useCallback)((id2) => {
        setSelected(id2);
      }, []);
      const qrUrl = (0, util_1.createQrUrl)(props.sessionId, props.sessionSecret, props.linkAPIUrl, props.isParentConnection, props.version, props.chainId);
      const wallet = wallets[selected];
      if (!selected) {
        return null;
      }
      const WalletSteps = wallet.steps;
      const coinbaseApp = selected === "coinbase-app";
      return (0, preact_1.h)(
        "div",
        { "data-testid": "connect-content", class: (0, clsx_1.default)("-cbwsdk-connect-content", theme) },
        (0, preact_1.h)("style", null, ConnectContent_css_1.default),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-content-header" },
          (0, preact_1.h)("h2", { class: (0, clsx_1.default)("-cbwsdk-connect-content-heading", theme) }, "Scan to connect with one of our mobile apps"),
          props.onCancel && (0, preact_1.h)(
            "button",
            { type: "button", class: "-cbwsdk-cancel-button", onClick: props.onCancel },
            (0, preact_1.h)(CloseIcon_1.CloseIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
          )
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-content-layout" },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-connect-content-column-left" },
            (0, preact_1.h)("div", null, Object.entries(wallets).map(([key2, value]) => {
              return (0, preact_1.h)(ConnectItem, { key: key2, title: value.title, description: value.description, icon: value.icon, selected: selected === key2, onClick: () => handleSelect(key2), theme });
            })),
            coinbaseApp && (0, preact_1.h)(
              "div",
              { class: (0, clsx_1.default)("-cbwsdk-connect-content-update-app", theme) },
              "Don’t see a ",
              (0, preact_1.h)("strong", null, "Scan"),
              " option? Update your Coinbase app to the latest version and try again."
            )
          ),
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-connect-content-column-right" },
            (0, preact_1.h)(
              "div",
              { class: "-cbwsdk-connect-content-qr-wrapper" },
              (0, preact_1.h)(QRCode_1.QRCode, { content: qrUrl, width: 200, height: 200, fgColor: "#000", bgColor: "transparent", image: {
                svg: makeQrCodeImage(selected),
                width: 25,
                height: 25
              } }),
              (0, preact_1.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: version_1.LIB_VERSION }),
              (0, preact_1.h)("input", { type: "hidden", value: qrUrl })
            ),
            (0, preact_1.h)(WalletSteps, { theme }),
            !props.isConnected && (0, preact_1.h)(
              "div",
              { "data-testid": "connecting-spinner", class: (0, clsx_1.default)("-cbwsdk-connect-content-qr-connecting", theme) },
              (0, preact_1.h)(Spinner_1.Spinner, { size: 36, color: theme === "dark" ? "#FFF" : "#000" }),
              (0, preact_1.h)("p", null, "Connecting...")
            )
          )
        )
      );
    }
    exports.ConnectContent = ConnectContent;
    function ConnectItem({ title, description, icon, selected, theme, onClick }) {
      return (0, preact_1.h)(
        "div",
        { onClick, class: (0, clsx_1.default)("-cbwsdk-connect-item", theme, { selected }) },
        (0, preact_1.h)(
          "div",
          null,
          (0, preact_1.h)("img", { src: icon, alt: title })
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-item-copy-wrapper" },
          (0, preact_1.h)("h3", { class: "-cbwsdk-connect-item-title" }, title),
          (0, preact_1.h)("p", { class: "-cbwsdk-connect-item-description" }, description)
        )
      );
    }
    exports.ConnectItem = ConnectItem;
    function CoinbaseWalletSteps({ theme }) {
      return (0, preact_1.h)(
        "ol",
        { class: "-cbwsdk-wallet-steps" },
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
        ),
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-wallet-steps-item-wrapper" },
            (0, preact_1.h)(
              "span",
              null,
              "Tap ",
              (0, preact_1.h)("strong", null, "Scan"),
              " "
            ),
            (0, preact_1.h)(
              "span",
              { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
              (0, preact_1.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) })
            )
          )
        )
      );
    }
    exports.CoinbaseWalletSteps = CoinbaseWalletSteps;
    function CoinbaseAppSteps({ theme }) {
      return (0, preact_1.h)(
        "ol",
        { class: "-cbwsdk-wallet-steps" },
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)("div", { class: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase app")
        ),
        (0, preact_1.h)(
          "li",
          { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-item", theme) },
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-wallet-steps-item-wrapper" },
            (0, preact_1.h)(
              "span",
              null,
              "Tap ",
              (0, preact_1.h)("strong", null, "More")
            ),
            (0, preact_1.h)(
              "span",
              { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
              (0, preact_1.h)(StatusDotIcon_1.StatusDotIcon, { fill: makeIconColor(theme) })
            ),
            (0, preact_1.h)(
              "span",
              { class: "-cbwsdk-wallet-steps-pad-left" },
              "then ",
              (0, preact_1.h)("strong", null, "Scan")
            ),
            (0, preact_1.h)(
              "span",
              { class: (0, clsx_1.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", theme) },
              (0, preact_1.h)(QRCodeIcon_1.QRCodeIcon, { fill: makeIconColor(theme) })
            )
          )
        )
      );
    }
    exports.CoinbaseAppSteps = CoinbaseAppSteps;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/ArrowLeftIcon.js
var require_ArrowLeftIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/ArrowLeftIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrowLeftIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function ArrowLeftIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
      );
    }
    exports.ArrowLeftIcon = ArrowLeftIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/LaptopIcon.js
var require_LaptopIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/LaptopIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LaptopIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function LaptopIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
        (0, preact_1.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
      );
    }
    exports.LaptopIcon = LaptopIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/icons/SafeIcon.js
var require_SafeIcon = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/icons/SafeIcon.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SafeIcon = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    function SafeIcon(props) {
      return (0, preact_1.h)(
        "svg",
        Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, props),
        (0, preact_1.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
      );
    }
    exports.SafeIcon = SafeIcon;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent-css.js
var require_TryExtensionContent_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent.js
var require_TryExtensionContent = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/TryExtensionContent/TryExtensionContent.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TryExtensionContent = void 0;
    var clsx_1 = __importDefault3((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var ArrowLeftIcon_1 = require_ArrowLeftIcon();
    var LaptopIcon_1 = require_LaptopIcon();
    var SafeIcon_1 = require_SafeIcon();
    var TryExtensionContent_css_1 = __importDefault3(require_TryExtensionContent_css());
    function TryExtensionContent({ theme }) {
      const [clicked, setClicked] = (0, hooks_1.useState)(false);
      const handleInstallClick = (0, hooks_1.useCallback)(() => {
        window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
      }, []);
      const handleClick = (0, hooks_1.useCallback)(() => {
        if (clicked) {
          window.location.reload();
        } else {
          handleInstallClick();
          setClicked(true);
        }
      }, [handleInstallClick, clicked]);
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-try-extension", theme) },
        (0, preact_1.h)("style", null, TryExtensionContent_css_1.default),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-try-extension-column-half" },
          (0, preact_1.h)("h3", { class: (0, clsx_1.default)("-cbwsdk-try-extension-heading", theme) }, "Or try the Coinbase Wallet browser extension"),
          (0, preact_1.h)(
            "div",
            { class: "-cbwsdk-try-extension-cta-wrapper" },
            (0, preact_1.h)("button", { class: (0, clsx_1.default)("-cbwsdk-try-extension-cta", theme), onClick: handleClick }, clicked ? "Refresh" : "Install"),
            (0, preact_1.h)("div", null, !clicked && (0, preact_1.h)(ArrowLeftIcon_1.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: theme === "light" ? "#0052FF" : "#588AF5" }))
          )
        ),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-try-extension-column-half" },
          (0, preact_1.h)(
            "ul",
            { class: "-cbwsdk-try-extension-list" },
            (0, preact_1.h)(
              "li",
              { class: "-cbwsdk-try-extension-list-item" },
              (0, preact_1.h)(
                "div",
                { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
                (0, preact_1.h)(
                  "span",
                  { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-icon", theme) },
                  (0, preact_1.h)(LaptopIcon_1.LaptopIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
                )
              ),
              (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-copy", theme) }, "Connect with dapps with just one click on your desktop browser")
            ),
            (0, preact_1.h)(
              "li",
              { class: "-cbwsdk-try-extension-list-item" },
              (0, preact_1.h)(
                "div",
                { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
                (0, preact_1.h)(
                  "span",
                  { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-icon", theme) },
                  (0, preact_1.h)(SafeIcon_1.SafeIcon, { fill: theme === "light" ? "#0A0B0D" : "#FFFFFF" })
                )
              ),
              (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-try-extension-list-item-copy", theme) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
            )
          )
        )
      );
    }
    exports.TryExtensionContent = TryExtensionContent;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog-css.js
var require_ConnectDialog_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog.js
var require_ConnectDialog = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/ConnectDialog/ConnectDialog.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConnectDialog = void 0;
    var clsx_1 = __importDefault3((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var ConnectContent_1 = require_ConnectContent();
    var TryExtensionContent_1 = require_TryExtensionContent();
    var ConnectDialog_css_1 = __importDefault3(require_ConnectDialog_css());
    var ConnectDialog = (props) => {
      const { isOpen, darkMode } = props;
      const [containerHidden, setContainerHidden] = (0, hooks_1.useState)(!isOpen);
      const [dialogHidden, setDialogHidden] = (0, hooks_1.useState)(!isOpen);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setDialogHidden(!isOpen);
          }, 10)
        ];
        if (isOpen) {
          setContainerHidden(false);
        } else {
          timers.push(window.setTimeout(() => {
            setContainerHidden(true);
          }, 360));
        }
        return () => {
          timers.forEach(window.clearTimeout);
        };
      }, [props.isOpen]);
      const theme = darkMode ? "dark" : "light";
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-container", containerHidden && "-cbwsdk-connect-dialog-container-hidden") },
        (0, preact_1.h)("style", null, ConnectDialog_css_1.default),
        (0, preact_1.h)("div", { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-backdrop", theme, dialogHidden && "-cbwsdk-connect-dialog-backdrop-hidden") }),
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-connect-dialog" },
          (0, preact_1.h)(
            "div",
            { class: (0, clsx_1.default)("-cbwsdk-connect-dialog-box", dialogHidden && "-cbwsdk-connect-dialog-box-hidden") },
            !props.connectDisabled ? (0, preact_1.h)(ConnectContent_1.ConnectContent, { theme, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, linkAPIUrl: props.linkAPIUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection, chainId: props.chainId, onCancel: props.onCancel }) : null,
            (0, preact_1.h)(TryExtensionContent_1.TryExtensionContent, { theme })
          )
        )
      );
    };
    exports.ConnectDialog = ConnectDialog;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow/LinkFlow.js
var require_LinkFlow = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/LinkFlow/LinkFlow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkFlow = void 0;
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var ConnectDialog_1 = require_ConnectDialog();
    var LinkFlow = class {
      constructor(options) {
        this.extensionUI$ = new rxjs_1.BehaviorSubject({});
        this.subscriptions = new rxjs_1.Subscription();
        this.isConnected = false;
        this.chainId = 1;
        this.isOpen = false;
        this.onCancel = null;
        this.root = null;
        this.connectDisabled = false;
        this.darkMode = options.darkMode;
        this.version = options.version;
        this.sessionId = options.sessionId;
        this.sessionSecret = options.sessionSecret;
        this.linkAPIUrl = options.linkAPIUrl;
        this.isParentConnection = options.isParentConnection;
        this.connected$ = options.connected$;
        this.chainId$ = options.chainId$;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-link-flow-root";
        el.appendChild(this.root);
        this.render();
        this.subscriptions.add(this.connected$.subscribe((v5) => {
          if (this.isConnected !== v5) {
            this.isConnected = v5;
            this.render();
          }
        }));
        this.subscriptions.add(this.chainId$.subscribe((chainId) => {
          if (this.chainId !== chainId) {
            this.chainId = chainId;
            this.render();
          }
        }));
      }
      detach() {
        var _a2;
        if (!this.root) {
          return;
        }
        this.subscriptions.unsubscribe();
        (0, preact_1.render)(null, this.root);
        (_a2 = this.root.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.root);
      }
      setConnectDisabled(connectDisabled) {
        this.connectDisabled = connectDisabled;
      }
      open(options) {
        this.isOpen = true;
        this.onCancel = options.onCancel;
        this.render();
      }
      close() {
        this.isOpen = false;
        this.onCancel = null;
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        const subscription = this.extensionUI$.subscribe(() => {
          if (!this.root) {
            return;
          }
          (0, preact_1.render)((0, preact_1.h)(ConnectDialog_1.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
        });
        this.subscriptions.add(subscription);
      }
    };
    exports.LinkFlow = LinkFlow;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar-css.js
var require_Snackbar_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `.-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar.js
var require_Snackbar = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/components/Snackbar/Snackbar.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SnackbarInstance = exports.SnackbarContainer = exports.Snackbar = void 0;
    var clsx_1 = __importDefault3((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var preact_1 = (init_preact_module(), __toCommonJS(preact_module_exports));
    var hooks_1 = (init_hooks_module(), __toCommonJS(hooks_module_exports));
    var Snackbar_css_1 = __importDefault3(require_Snackbar_css());
    var gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
    function makeSnackbarIcon(appSrc) {
      switch (appSrc) {
        case "coinbase-app":
          return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE0LjY3NCAxOC44NThjLTIuMDQ1IDAtMy42NDgtMS43MjItMy42NDgtMy44NDVzMS42NTktMy44NDUgMy42NDgtMy44NDVjMS44MjQgMCAzLjMxNyAxLjM3NyAzLjU5MyAzLjIxNGgzLjcwM2MtLjMzMS0zLjk2LTMuNDgyLTcuMDU5LTcuMjk2LTcuMDU5LTQuMDM0IDAtNy4zNSAzLjQ0My03LjM1IDcuNjkgMCA0LjI0NiAzLjI2IDcuNjkgNy4zNSA3LjY5IDMuODcgMCA2Ljk2NS0zLjEgNy4yOTYtNy4wNTloLTMuNzAzYy0uMjc2IDEuODM2LTEuNzY5IDMuMjE0LTMuNTkzIDMuMjE0WiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0wIDEwLjY3OGMwLTMuNzExIDAtNS41OTYuNzQyLTcuMDIzQTYuNTMyIDYuNTMyIDAgMCAxIDMuNjU1Ljc0MkM1LjA4MiAwIDYuOTY3IDAgMTAuNjc4IDBoNy45MzhjMy43MTEgMCA1LjU5NiAwIDcuMDIzLjc0MmE2LjUzMSA2LjUzMSAwIDAgMSAyLjkxMyAyLjkxM2MuNzQyIDEuNDI3Ljc0MiAzLjMxMi43NDIgNy4wMjN2Ny45MzhjMCAzLjcxMSAwIDUuNTk2LS43NDIgNy4wMjNhNi41MzEgNi41MzEgMCAwIDEtMi45MTMgMi45MTNjLTEuNDI3Ljc0Mi0zLjMxMi43NDItNy4wMjMuNzQyaC03LjkzOGMtMy43MTEgMC01LjU5NiAwLTcuMDIzLS43NDJhNi41MzEgNi41MzEgMCAwIDEtMi45MTMtMi45MTNDMCAyNC4yMTIgMCAyMi4zODQgMCAxOC42MTZ2LTcuOTM4WiIgZmlsbD0iIzAwNTJGRiIvPjxwYXRoIGQ9Ik0xNC42ODQgMTkuNzczYy0yLjcyNyAwLTQuODY0LTIuMjk1LTQuODY0LTUuMTI2IDAtMi44MzEgMi4yMS01LjEyNyA0Ljg2NC01LjEyNyAyLjQzMiAwIDQuNDIyIDEuODM3IDQuNzkgNC4yODVoNC45MzhjLS40NDItNS4yOC00LjY0My05LjQxMS05LjcyOC05LjQxMS01LjM4IDAtOS44MDIgNC41OS05LjgwMiAxMC4yNTMgMCA1LjY2MiA0LjM0OCAxMC4yNTMgOS44MDIgMTAuMjUzIDUuMTU5IDAgOS4yODYtNC4xMzIgOS43MjgtOS40MTFoLTQuOTM4Yy0uMzY4IDIuNDQ4LTIuMzU4IDQuMjg0LTQuNzkgNC4yODRaIiBmaWxsPSIjZmZmIi8+PC9zdmc+`;
        case "coinbase-wallet-app":
        default:
          return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
      }
    }
    var Snackbar = class {
      constructor(options) {
        this.items = /* @__PURE__ */ new Map();
        this.nextItemKey = 0;
        this.root = null;
        this.darkMode = options.darkMode;
      }
      attach(el) {
        this.root = document.createElement("div");
        this.root.className = "-cbwsdk-snackbar-root";
        el.appendChild(this.root);
        this.render();
      }
      presentItem(itemProps) {
        const key2 = this.nextItemKey++;
        this.items.set(key2, itemProps);
        this.render();
        return () => {
          this.items.delete(key2);
          this.render();
        };
      }
      clear() {
        this.items.clear();
        this.render();
      }
      render() {
        if (!this.root) {
          return;
        }
        (0, preact_1.render)((0, preact_1.h)(
          "div",
          null,
          (0, preact_1.h)(exports.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key2, itemProps]) => (0, preact_1.h)(exports.SnackbarInstance, Object.assign({}, itemProps, { key: key2 }))))
        ), this.root);
      }
    };
    exports.Snackbar = Snackbar;
    var SnackbarContainer = (props) => (0, preact_1.h)(
      "div",
      { class: (0, clsx_1.default)("-cbwsdk-snackbar-container") },
      (0, preact_1.h)("style", null, Snackbar_css_1.default),
      (0, preact_1.h)("div", { class: "-cbwsdk-snackbar" }, props.children)
    );
    exports.SnackbarContainer = SnackbarContainer;
    var SnackbarInstance = ({ autoExpand, message, menuItems, appSrc }) => {
      const [hidden2, setHidden] = (0, hooks_1.useState)(true);
      const [expanded, setExpanded] = (0, hooks_1.useState)(autoExpand !== null && autoExpand !== void 0 ? autoExpand : false);
      (0, hooks_1.useEffect)(() => {
        const timers = [
          window.setTimeout(() => {
            setHidden(false);
          }, 1),
          window.setTimeout(() => {
            setExpanded(true);
          }, 1e4)
        ];
        return () => {
          timers.forEach(window.clearTimeout);
        };
      });
      const toggleExpanded = () => {
        setExpanded(!expanded);
      };
      return (0, preact_1.h)(
        "div",
        { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance", hidden2 && "-cbwsdk-snackbar-instance-hidden", expanded && "-cbwsdk-snackbar-instance-expanded") },
        (0, preact_1.h)(
          "div",
          { class: "-cbwsdk-snackbar-instance-header", onClick: toggleExpanded },
          (0, preact_1.h)("img", { src: makeSnackbarIcon(appSrc), class: "-cbwsdk-snackbar-instance-header-cblogo" }),
          (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, message),
          (0, preact_1.h)(
            "div",
            { class: "-gear-container" },
            !expanded && (0, preact_1.h)(
              "svg",
              { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
            ),
            (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" })
          )
        ),
        menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, menuItems.map((action, i4) => (0, preact_1.h)(
          "div",
          { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item", action.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i4 },
          (0, preact_1.h)(
            "svg",
            { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })
          ),
          (0, preact_1.h)("span", { class: (0, clsx_1.default)("-cbwsdk-snackbar-instance-menu-item-info", action.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, action.info)
        )))
      );
    };
    exports.SnackbarInstance = SnackbarInstance;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js
var require_cssReset_css = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset-css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = `@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}`;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js
var require_cssReset = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/lib/cssReset.js"(exports) {
    "use strict";
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.injectCssReset = void 0;
    var cssReset_css_1 = __importDefault3(require_cssReset_css());
    function injectCssReset() {
      const styleEl = document.createElement("style");
      styleEl.type = "text/css";
      styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
      document.documentElement.appendChild(styleEl);
    }
    exports.injectCssReset = injectCssReset;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js
var require_WalletSDKUI = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/provider/WalletSDKUI.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKUI = void 0;
    var LinkFlow_1 = require_LinkFlow();
    var Snackbar_1 = require_Snackbar();
    var cssReset_1 = require_cssReset();
    var WalletSDKUI = class {
      constructor(options) {
        this.standalone = null;
        this.attached = false;
        this.appSrc = null;
        this.snackbar = new Snackbar_1.Snackbar({
          darkMode: options.darkMode
        });
        this.linkFlow = new LinkFlow_1.LinkFlow({
          darkMode: options.darkMode,
          version: options.version,
          sessionId: options.session.id,
          sessionSecret: options.session.secret,
          linkAPIUrl: options.linkAPIUrl,
          connected$: options.connected$,
          chainId$: options.chainId$,
          isParentConnection: false
        });
      }
      attach() {
        if (this.attached) {
          throw new Error("Coinbase Wallet SDK UI is already attached");
        }
        const el = document.documentElement;
        const container = document.createElement("div");
        container.className = "-cbwsdk-css-reset";
        el.appendChild(container);
        this.linkFlow.attach(container);
        this.snackbar.attach(container);
        this.attached = true;
        (0, cssReset_1.injectCssReset)();
      }
      setConnectDisabled(connectDisabled) {
        this.linkFlow.setConnectDisabled(connectDisabled);
      }
      /* istanbul ignore next */
      addEthereumChain(_options) {
      }
      /* istanbul ignore next */
      watchAsset(_options) {
      }
      /* istanbul ignore next */
      switchEthereumChain(_options) {
      }
      requestEthereumAccounts(options) {
        this.linkFlow.open({ onCancel: options.onCancel });
      }
      hideRequestEthereumAccounts() {
        this.linkFlow.close();
      }
      /* istanbul ignore next */
      signEthereumMessage(_6) {
      }
      /* istanbul ignore next */
      signEthereumTransaction(_6) {
      }
      /* istanbul ignore next */
      submitEthereumTransaction(_6) {
      }
      /* istanbul ignore next */
      ethereumAddressFromSignedMessage(_6) {
      }
      showConnecting(options) {
        let snackbarProps;
        if (options.isUnlinkedErrorState) {
          snackbarProps = {
            autoExpand: true,
            message: "Connection lost",
            appSrc: this.appSrc,
            menuItems: [
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        } else {
          snackbarProps = {
            message: "Confirm on phone",
            appSrc: this.appSrc,
            menuItems: [
              {
                isRed: true,
                info: "Cancel transaction",
                svgWidth: "11",
                svgHeight: "11",
                path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
                defaultFillRule: "inherit",
                defaultClipRule: "inherit",
                onClick: options.onCancel
              },
              {
                isRed: false,
                info: "Reset connection",
                svgWidth: "10",
                svgHeight: "11",
                path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
                defaultFillRule: "evenodd",
                defaultClipRule: "evenodd",
                onClick: options.onResetConnection
              }
            ]
          };
        }
        return this.snackbar.presentItem(snackbarProps);
      }
      /* istanbul ignore next */
      setAppSrc(appSrc) {
        this.appSrc = appSrc;
      }
      /* istanbul ignore next */
      reloadUI() {
        document.location.reload();
      }
      /* istanbul ignore next */
      inlineAccountsResponse() {
        return false;
      }
      /* istanbul ignore next */
      inlineAddEthereumChain(_chainId) {
        return false;
      }
      /* istanbul ignore next */
      inlineWatchAsset() {
        return false;
      }
      /* istanbul ignore next */
      inlineSwitchEthereumChain() {
        return false;
      }
      /* istanbul ignore next */
      setStandalone(status) {
        this.standalone = status;
      }
      /* istanbul ignore next */
      isStandalone() {
        var _a2;
        return (_a2 = this.standalone) !== null && _a2 !== void 0 ? _a2 : false;
      }
    };
    exports.WalletSDKUI = WalletSDKUI;
  }
});

// node_modules/bind-decorator/index.js
var require_bind_decorator = __commonJS({
  "node_modules/bind-decorator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var constants;
    (function(constants2) {
      constants2.typeOfFunction = "function";
      constants2.boolTrue = true;
    })(constants || (constants = {}));
    function bind(target, propertyKey, descriptor) {
      if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
        throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
      }
      return {
        configurable: constants.boolTrue,
        get: function() {
          var bound = descriptor.value.bind(this);
          Object.defineProperty(this, propertyKey, {
            value: bound,
            configurable: constants.boolTrue,
            writable: constants.boolTrue
          });
          return bound;
        }
      };
    }
    exports.bind = bind;
    exports.default = bind;
  }
});

// node_modules/rxjs/_esm5/internal/operators/audit.js
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator, AuditSubscriber;
var init_audit = __esm({
  "node_modules/rxjs/_esm5/internal/operators/audit.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    AuditOperator = function() {
      function AuditOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      AuditOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
      };
      return AuditOperator2;
    }();
    AuditSubscriber = function(_super) {
      __extends(AuditSubscriber2, _super);
      function AuditSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      AuditSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
          var duration = void 0;
          try {
            var durationSelector = this.durationSelector;
            duration = durationSelector(value);
          } catch (err) {
            return this.destination.error(err);
          }
          var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
          if (!innerSubscription || innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      };
      AuditSubscriber2.prototype.clearThrottle = function() {
        var _a2 = this, value = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
        if (throttled) {
          this.remove(throttled);
          this.throttled = void 0;
          throttled.unsubscribe();
        }
        if (hasValue) {
          this.value = void 0;
          this.hasValue = false;
          this.destination.next(value);
        }
      };
      AuditSubscriber2.prototype.notifyNext = function() {
        this.clearThrottle();
      };
      AuditSubscriber2.prototype.notifyComplete = function() {
        this.clearThrottle();
      };
      return AuditSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/auditTime.js
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer2(duration, scheduler);
  });
}
var init_auditTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/auditTime.js"() {
    init_async();
    init_audit();
    init_timer();
  }
});

// node_modules/rxjs/_esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator, BufferSubscriber;
var init_buffer = __esm({
  "node_modules/rxjs/_esm5/internal/operators/buffer.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    BufferOperator = function() {
      function BufferOperator2(closingNotifier) {
        this.closingNotifier = closingNotifier;
      }
      BufferOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
      };
      return BufferOperator2;
    }();
    BufferSubscriber = function(_super) {
      __extends(BufferSubscriber2, _super);
      function BufferSubscriber2(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
        return _this;
      }
      BufferSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferSubscriber2.prototype.notifyNext = function() {
        var buffer2 = this.buffer;
        this.buffer = [];
        this.destination.next(buffer2);
      };
      return BufferSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferCount.js
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator, BufferCountSubscriber, BufferSkipCountSubscriber;
var init_bufferCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    BufferCountOperator = function() {
      function BufferCountOperator2(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }
      BufferCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
      };
      return BufferCountOperator2;
    }();
    BufferCountSubscriber = function(_super) {
      __extends(BufferCountSubscriber2, _super);
      function BufferCountSubscriber2(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
      }
      BufferCountSubscriber2.prototype._next = function(value) {
        var buffer2 = this.buffer;
        buffer2.push(value);
        if (buffer2.length == this.bufferSize) {
          this.destination.next(buffer2);
          this.buffer = [];
        }
      };
      BufferCountSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2.length > 0) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      return BufferCountSubscriber2;
    }(Subscriber);
    BufferSkipCountSubscriber = function(_super) {
      __extends(BufferSkipCountSubscriber2, _super);
      function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
      }
      BufferSkipCountSubscriber2.prototype._next = function(value) {
        var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
        this.count++;
        if (count2 % startBufferEvery === 0) {
          buffers.push([]);
        }
        for (var i4 = buffers.length; i4--; ) {
          var buffer2 = buffers[i4];
          buffer2.push(value);
          if (buffer2.length === bufferSize) {
            buffers.splice(i4, 1);
            this.destination.next(buffer2);
          }
        }
      };
      BufferSkipCountSubscriber2.prototype._complete = function() {
        var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
        while (buffers.length > 0) {
          var buffer2 = buffers.shift();
          if (buffer2.length > 0) {
            destination.next(buffer2);
          }
        }
        _super.prototype._complete.call(this);
      };
      return BufferSkipCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var length2 = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length2--;
  }
  var bufferCreationInterval = null;
  if (length2 >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length2 >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
function dispatchBufferTimeSpanOnly(state3) {
  var subscriber = state3.subscriber;
  var prevContext = state3.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state3.context = subscriber.openContext();
    state3.context.closeAction = this.schedule(state3, state3.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state3) {
  var bufferCreationInterval = state3.bufferCreationInterval, bufferTimeSpan = state3.bufferTimeSpan, subscriber = state3.subscriber, scheduler = state3.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state3, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
var BufferTimeOperator, Context, BufferTimeSubscriber;
var init_bufferTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferTime.js"() {
    init_tslib_es6();
    init_async();
    init_Subscriber();
    init_isScheduler();
    BufferTimeOperator = function() {
      function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }
      BufferTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
      };
      return BufferTimeOperator2;
    }();
    Context = function() {
      function Context2() {
        this.buffer = [];
      }
      return Context2;
    }();
    BufferTimeSubscriber = function(_super) {
      __extends(BufferTimeSubscriber2, _super);
      function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
          var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          var closeState = { subscriber: _this, context };
          var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
          _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
      }
      BufferTimeSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i4 = 0; i4 < len; i4++) {
          var context_1 = contexts[i4];
          var buffer2 = context_1.buffer;
          buffer2.push(value);
          if (buffer2.length == this.maxBufferSize) {
            filledBufferContext = context_1;
          }
        }
        if (filledBufferContext) {
          this.onBufferFull(filledBufferContext);
        }
      };
      BufferTimeSubscriber2.prototype._error = function(err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
      };
      BufferTimeSubscriber2.prototype._complete = function() {
        var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
      };
      BufferTimeSubscriber2.prototype._unsubscribe = function() {
        this.contexts = null;
      };
      BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
          context = this.openContext();
          var bufferTimeSpan = this.bufferTimeSpan;
          var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
          this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
      };
      BufferTimeSubscriber2.prototype.openContext = function() {
        var context = new Context();
        this.contexts.push(context);
        return context;
      };
      BufferTimeSubscriber2.prototype.closeContext = function(context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
          contexts.splice(contexts.indexOf(context), 1);
        }
      };
      return BufferTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferToggle.js
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator, BufferToggleSubscriber;
var init_bufferToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferToggle.js"() {
    init_tslib_es6();
    init_Subscription();
    init_subscribeToResult();
    init_OuterSubscriber();
    BufferToggleOperator = function() {
      function BufferToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      BufferToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return BufferToggleOperator2;
    }();
    BufferToggleSubscriber = function(_super) {
      __extends(BufferToggleSubscriber2, _super);
      function BufferToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
      }
      BufferToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i4 = 0; i4 < len; i4++) {
          contexts[i4].buffer.push(value);
        }
      };
      BufferToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_1 = contexts.shift();
          context_1.subscription.unsubscribe();
          context_1.buffer = null;
          context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
      };
      BufferToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        while (contexts.length > 0) {
          var context_2 = contexts.shift();
          this.destination.next(context_2.buffer);
          context_2.subscription.unsubscribe();
          context_2.buffer = null;
          context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
      };
      BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
      };
      BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.closeBuffer(innerSub.context);
      };
      BufferToggleSubscriber2.prototype.openBuffer = function(value) {
        try {
          var closingSelector = this.closingSelector;
          var closingNotifier = closingSelector.call(this, value);
          if (closingNotifier) {
            this.trySubscribe(closingNotifier);
          }
        } catch (err) {
          this._error(err);
        }
      };
      BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
        var contexts = this.contexts;
        if (contexts && context) {
          var buffer2 = context.buffer, subscription = context.subscription;
          this.destination.next(buffer2);
          contexts.splice(contexts.indexOf(context), 1);
          this.remove(subscription);
          subscription.unsubscribe();
        }
      };
      BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
        var contexts = this.contexts;
        var buffer2 = [];
        var subscription = new Subscription();
        var context = { buffer: buffer2, subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
          this.closeBuffer(context);
        } else {
          innerSubscription.context = context;
          this.add(innerSubscription);
          subscription.add(innerSubscription);
        }
      };
      return BufferToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/bufferWhen.js
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator, BufferWhenSubscriber;
var init_bufferWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/bufferWhen.js"() {
    init_tslib_es6();
    init_Subscription();
    init_innerSubscribe();
    BufferWhenOperator = function() {
      function BufferWhenOperator2(closingSelector) {
        this.closingSelector = closingSelector;
      }
      BufferWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
      };
      return BufferWhenOperator2;
    }();
    BufferWhenSubscriber = function(_super) {
      __extends(BufferWhenSubscriber2, _super);
      function BufferWhenSubscriber2(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
      }
      BufferWhenSubscriber2.prototype._next = function(value) {
        this.buffer.push(value);
      };
      BufferWhenSubscriber2.prototype._complete = function() {
        var buffer2 = this.buffer;
        if (buffer2) {
          this.destination.next(buffer2);
        }
        _super.prototype._complete.call(this);
      };
      BufferWhenSubscriber2.prototype._unsubscribe = function() {
        this.buffer = void 0;
        this.subscribing = false;
      };
      BufferWhenSubscriber2.prototype.notifyNext = function() {
        this.openBuffer();
      };
      BufferWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.subscribing) {
          this.complete();
        } else {
          this.openBuffer();
        }
      };
      BufferWhenSubscriber2.prototype.openBuffer = function() {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
          this.remove(closingSubscription);
          closingSubscription.unsubscribe();
        }
        var buffer2 = this.buffer;
        if (this.buffer) {
          this.destination.next(buffer2);
        }
        this.buffer = [];
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (err) {
          return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
        this.subscribing = false;
      };
      return BufferWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/catchError.js
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator, CatchSubscriber;
var init_catchError = __esm({
  "node_modules/rxjs/_esm5/internal/operators/catchError.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    CatchOperator = function() {
      function CatchOperator2(selector) {
        this.selector = selector;
      }
      CatchOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator2;
    }();
    CatchSubscriber = function(_super) {
      __extends(CatchSubscriber2, _super);
      function CatchSubscriber2(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
      }
      CatchSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var result = void 0;
          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            _super.prototype.error.call(this, err2);
            return;
          }
          this._unsubscribeAndRecycle();
          var innerSubscriber = new SimpleInnerSubscriber(this);
          this.add(innerSubscriber);
          var innerSubscription = innerSubscribe(result, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            this.add(innerSubscription);
          }
        }
      };
      return CatchSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineAll.js
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
var init_combineAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineAll.js"() {
    init_combineLatest();
  }
});

// node_modules/rxjs/_esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from3([source].concat(observables)), new CombineLatestOperator(project));
  };
}
var init_combineLatest2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/combineLatest.js"() {
    init_isArray();
    init_combineLatest();
    init_from();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concat.js
function concat4() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat3.apply(void 0, [source].concat(observables)));
  };
}
var init_concat2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concat.js"() {
    init_concat();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
var init_concatMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMap.js"() {
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/concatMapTo.js
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
var init_concatMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/concatMapTo.js"() {
    init_concatMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/count.js
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator, CountSubscriber;
var init_count = __esm({
  "node_modules/rxjs/_esm5/internal/operators/count.js"() {
    init_tslib_es6();
    init_Subscriber();
    CountOperator = function() {
      function CountOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      CountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      };
      return CountOperator2;
    }();
    CountSubscriber = function(_super) {
      __extends(CountSubscriber2, _super);
      function CountSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
      }
      CountSubscriber2.prototype._next = function(value) {
        if (this.predicate) {
          this._tryPredicate(value);
        } else {
          this.count++;
        }
      };
      CountSubscriber2.prototype._tryPredicate = function(value) {
        var result;
        try {
          result = this.predicate(value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (result) {
          this.count++;
        }
      };
      CountSubscriber2.prototype._complete = function() {
        this.destination.next(this.count);
        this.destination.complete();
      };
      return CountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounce.js
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator, DebounceSubscriber;
var init_debounce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounce.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DebounceOperator = function() {
      function DebounceOperator2(durationSelector) {
        this.durationSelector = durationSelector;
      }
      DebounceOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
      };
      return DebounceOperator2;
    }();
    DebounceSubscriber = function(_super) {
      __extends(DebounceSubscriber2, _super);
      function DebounceSubscriber2(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
      }
      DebounceSubscriber2.prototype._next = function(value) {
        try {
          var result = this.durationSelector.call(this, value);
          if (result) {
            this._tryNext(value, result);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DebounceSubscriber2.prototype._complete = function() {
        this.emitValue();
        this.destination.complete();
      };
      DebounceSubscriber2.prototype._tryNext = function(value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
          subscription.unsubscribe();
          this.remove(subscription);
        }
        subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
          this.add(this.durationSubscription = subscription);
        }
      };
      DebounceSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      DebounceSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          var value = this.value;
          var subscription = this.durationSubscription;
          if (subscription) {
            this.durationSubscription = void 0;
            subscription.unsubscribe();
            this.remove(subscription);
          }
          this.value = void 0;
          this.hasValue = false;
          _super.prototype._next.call(this, value);
        }
      };
      return DebounceSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
function dispatchNext3(subscriber) {
  subscriber.debouncedNext();
}
var DebounceTimeOperator, DebounceTimeSubscriber;
var init_debounceTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/debounceTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    DebounceTimeOperator = function() {
      function DebounceTimeOperator2(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }
      DebounceTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator2;
    }();
    DebounceTimeSubscriber = function(_super) {
      __extends(DebounceTimeSubscriber2, _super);
      function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
      }
      DebounceTimeSubscriber2.prototype._next = function(value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext3, this.dueTime, this));
      };
      DebounceTimeSubscriber2.prototype._complete = function() {
        this.debouncedNext();
        this.destination.complete();
      };
      DebounceTimeSubscriber2.prototype.debouncedNext = function() {
        this.clearDebounce();
        if (this.hasValue) {
          var lastValue = this.lastValue;
          this.lastValue = null;
          this.hasValue = false;
          this.destination.next(lastValue);
        }
      };
      DebounceTimeSubscriber2.prototype.clearDebounce = function() {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
          this.remove(debouncedSubscription);
          debouncedSubscription.unsubscribe();
          this.debouncedSubscription = null;
        }
      };
      return DebounceTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator, DefaultIfEmptySubscriber;
var init_defaultIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/defaultIfEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    DefaultIfEmptyOperator = function() {
      function DefaultIfEmptyOperator2(defaultValue) {
        this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator2;
    }();
    DefaultIfEmptySubscriber = function(_super) {
      __extends(DefaultIfEmptySubscriber2, _super);
      function DefaultIfEmptySubscriber2(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
      }
      DefaultIfEmptySubscriber2.prototype._next = function(value) {
        this.isEmpty = false;
        this.destination.next(value);
      };
      DefaultIfEmptySubscriber2.prototype._complete = function() {
        if (this.isEmpty) {
          this.destination.next(this.defaultValue);
        }
        this.destination.complete();
      };
      return DefaultIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/util/isDate.js
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
var init_isDate = __esm({
  "node_modules/rxjs/_esm5/internal/util/isDate.js"() {
  }
});

// node_modules/rxjs/_esm5/internal/operators/delay.js
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator, DelaySubscriber, DelayMessage;
var init_delay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delay.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_Subscriber();
    init_Notification();
    DelayOperator = function() {
      function DelayOperator2(delay2, scheduler) {
        this.delay = delay2;
        this.scheduler = scheduler;
      }
      DelayOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator2;
    }();
    DelaySubscriber = function(_super) {
      __extends(DelaySubscriber2, _super);
      function DelaySubscriber2(destination, delay2, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay2;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
      }
      DelaySubscriber2.dispatch = function(state3) {
        var source = state3.source;
        var queue2 = source.queue;
        var scheduler = state3.scheduler;
        var destination = state3.destination;
        while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
          queue2.shift().notification.observe(destination);
        }
        if (queue2.length > 0) {
          var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
          this.schedule(state3, delay_1);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      };
      DelaySubscriber2.prototype._schedule = function(scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler
        }));
      };
      DelaySubscriber2.prototype.scheduleNotification = function(notification) {
        if (this.errored === true) {
          return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
          this._schedule(scheduler);
        }
      };
      DelaySubscriber2.prototype._next = function(value) {
        this.scheduleNotification(Notification.createNext(value));
      };
      DelaySubscriber2.prototype._error = function(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
      };
      DelaySubscriber2.prototype._complete = function() {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
      };
      return DelaySubscriber2;
    }(Subscriber);
    DelayMessage = function() {
      function DelayMessage2(time, notification) {
        this.time = time;
        this.notification = notification;
      }
      return DelayMessage2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator, DelayWhenSubscriber, SubscriptionDelayObservable, SubscriptionDelaySubscriber;
var init_delayWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/delayWhen.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Observable();
    init_OuterSubscriber();
    init_subscribeToResult();
    DelayWhenOperator = function() {
      function DelayWhenOperator2(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
      }
      DelayWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      };
      return DelayWhenOperator2;
    }();
    DelayWhenSubscriber = function(_super) {
      __extends(DelayWhenSubscriber2, _super);
      function DelayWhenSubscriber2(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
      }
      DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype.notifyError = function(error, innerSub) {
        this._error(error);
      };
      DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
          this.destination.next(value);
        }
        this.tryComplete();
      };
      DelayWhenSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        try {
          var delayNotifier = this.delayDurationSelector(value, index);
          if (delayNotifier) {
            this.tryDelay(delayNotifier, value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      DelayWhenSubscriber2.prototype._complete = function() {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
      };
      DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
          this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
      };
      DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
          var destination = this.destination;
          destination.add(notifierSubscription);
          this.delayNotifierSubscriptions.push(notifierSubscription);
        }
      };
      DelayWhenSubscriber2.prototype.tryComplete = function() {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
          this.destination.complete();
        }
      };
      return DelayWhenSubscriber2;
    }(OuterSubscriber);
    SubscriptionDelayObservable = function(_super) {
      __extends(SubscriptionDelayObservable2, _super);
      function SubscriptionDelayObservable2(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
      }
      SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      };
      return SubscriptionDelayObservable2;
    }(Observable);
    SubscriptionDelaySubscriber = function(_super) {
      __extends(SubscriptionDelaySubscriber2, _super);
      function SubscriptionDelaySubscriber2(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
      }
      SubscriptionDelaySubscriber2.prototype._next = function(unused) {
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype._error = function(err) {
        this.unsubscribe();
        this.parent.error(err);
      };
      SubscriptionDelaySubscriber2.prototype._complete = function() {
        this.unsubscribe();
        this.subscribeToSource();
      };
      SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
        if (!this.sourceSubscribed) {
          this.sourceSubscribed = true;
          this.unsubscribe();
          this.source.subscribe(this.parent);
        }
      };
      return SubscriptionDelaySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/dematerialize.js
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator, DeMaterializeSubscriber;
var init_dematerialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/dematerialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    DeMaterializeOperator = function() {
      function DeMaterializeOperator2() {
      }
      DeMaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
      };
      return DeMaterializeOperator2;
    }();
    DeMaterializeSubscriber = function(_super) {
      __extends(DeMaterializeSubscriber2, _super);
      function DeMaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      DeMaterializeSubscriber2.prototype._next = function(value) {
        value.observe(this.destination);
      };
      return DeMaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator, DistinctSubscriber;
var init_distinct = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinct.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    DistinctOperator = function() {
      function DistinctOperator2(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
      }
      DistinctOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
      };
      return DistinctOperator2;
    }();
    DistinctSubscriber = function(_super) {
      __extends(DistinctSubscriber2, _super);
      function DistinctSubscriber2(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = /* @__PURE__ */ new Set();
        if (flushes) {
          _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
        }
        return _this;
      }
      DistinctSubscriber2.prototype.notifyNext = function() {
        this.values.clear();
      };
      DistinctSubscriber2.prototype.notifyError = function(error) {
        this._error(error);
      };
      DistinctSubscriber2.prototype._next = function(value) {
        if (this.keySelector) {
          this._useKeySelector(value);
        } else {
          this._finalizeNext(value, value);
        }
      };
      DistinctSubscriber2.prototype._useKeySelector = function(value) {
        var key2;
        var destination = this.destination;
        try {
          key2 = this.keySelector(value);
        } catch (err) {
          destination.error(err);
          return;
        }
        this._finalizeNext(key2, value);
      };
      DistinctSubscriber2.prototype._finalizeNext = function(key2, value) {
        var values = this.values;
        if (!values.has(key2)) {
          values.add(key2);
          this.destination.next(value);
        }
      };
      return DistinctSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(compare2, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare2, keySelector));
  };
}
var DistinctUntilChangedOperator, DistinctUntilChangedSubscriber;
var init_distinctUntilChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js"() {
    init_tslib_es6();
    init_Subscriber();
    DistinctUntilChangedOperator = function() {
      function DistinctUntilChangedOperator2(compare2, keySelector) {
        this.compare = compare2;
        this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator2;
    }();
    DistinctUntilChangedSubscriber = function(_super) {
      __extends(DistinctUntilChangedSubscriber2, _super);
      function DistinctUntilChangedSubscriber2(destination, compare2, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare2 === "function") {
          _this.compare = compare2;
        }
        return _this;
      }
      DistinctUntilChangedSubscriber2.prototype.compare = function(x5, y7) {
        return x5 === y7;
      };
      DistinctUntilChangedSubscriber2.prototype._next = function(value) {
        var key2;
        try {
          var keySelector = this.keySelector;
          key2 = keySelector ? keySelector(value) : value;
        } catch (err) {
          return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
          try {
            var compare2 = this.compare;
            result = compare2(this.key, key2);
          } catch (err) {
            return this.destination.error(err);
          }
        } else {
          this.hasKey = true;
        }
        if (!result) {
          this.key = key2;
          this.destination.next(value);
        }
      };
      return DistinctUntilChangedSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key2, compare2) {
  return distinctUntilChanged(function(x5, y7) {
    return compare2 ? compare2(x5[key2], y7[key2]) : x5[key2] === y7[key2];
  });
}
var init_distinctUntilKeyChanged = __esm({
  "node_modules/rxjs/_esm5/internal/operators/distinctUntilKeyChanged.js"() {
    init_distinctUntilChanged();
  }
});

// node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
function defaultErrorFactory() {
  return new EmptyError();
}
var ThrowIfEmptyOperator, ThrowIfEmptySubscriber;
var init_throwIfEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throwIfEmpty.js"() {
    init_tslib_es6();
    init_EmptyError();
    init_Subscriber();
    ThrowIfEmptyOperator = function() {
      function ThrowIfEmptyOperator2(errorFactory) {
        this.errorFactory = errorFactory;
      }
      ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
      };
      return ThrowIfEmptyOperator2;
    }();
    ThrowIfEmptySubscriber = function(_super) {
      __extends(ThrowIfEmptySubscriber2, _super);
      function ThrowIfEmptySubscriber2(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
      }
      ThrowIfEmptySubscriber2.prototype._next = function(value) {
        this.hasValue = true;
        this.destination.next(value);
      };
      ThrowIfEmptySubscriber2.prototype._complete = function() {
        if (!this.hasValue) {
          var err = void 0;
          try {
            err = this.errorFactory();
          } catch (e3) {
            err = e3;
          }
          this.destination.error(err);
        } else {
          return this.destination.complete();
        }
      };
      return ThrowIfEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/take.js
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty4();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator, TakeSubscriber;
var init_take = __esm({
  "node_modules/rxjs/_esm5/internal/operators/take.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeOperator = function() {
      function TakeOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator2;
    }();
    TakeSubscriber = function(_super) {
      __extends(TakeSubscriber2, _super);
      function TakeSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      TakeSubscriber2.prototype._next = function(value) {
        var total = this.total;
        var count2 = ++this.count;
        if (count2 <= total) {
          this.destination.next(value);
          if (count2 === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      };
      return TakeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/elementAt.js
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v5, i4) {
      return i4 === index;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
var init_elementAt = __esm({
  "node_modules/rxjs/_esm5/internal/operators/elementAt.js"() {
    init_ArgumentOutOfRangeError();
    init_filter();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_take();
  }
});

// node_modules/rxjs/_esm5/internal/operators/endWith.js
function endWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  return function(source) {
    return concat3(source, of.apply(void 0, array2));
  };
}
var init_endWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/endWith.js"() {
    init_concat();
    init_of();
  }
});

// node_modules/rxjs/_esm5/internal/operators/every.js
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator, EverySubscriber;
var init_every = __esm({
  "node_modules/rxjs/_esm5/internal/operators/every.js"() {
    init_tslib_es6();
    init_Subscriber();
    EveryOperator = function() {
      function EveryOperator2(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }
      EveryOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
      };
      return EveryOperator2;
    }();
    EverySubscriber = function(_super) {
      __extends(EverySubscriber2, _super);
      function EverySubscriber2(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
      };
      EverySubscriber2.prototype._next = function(value) {
        var result = false;
        try {
          result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        if (!result) {
          this.notifyComplete(false);
        }
      };
      EverySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return EverySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaust.js
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator, SwitchFirstSubscriber;
var init_exhaust = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaust.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SwitchFirstOperator = function() {
      function SwitchFirstOperator2() {
      }
      SwitchFirstOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
      };
      return SwitchFirstOperator2;
    }();
    SwitchFirstSubscriber = function(_super) {
      __extends(SwitchFirstSubscriber2, _super);
      function SwitchFirstSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
      }
      SwitchFirstSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.hasSubscription = true;
          this.add(innerSubscribe(value, new SimpleInnerSubscriber(this)));
        }
      };
      SwitchFirstSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
      };
      SwitchFirstSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return SwitchFirstSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a4, i4) {
        return from3(project(a4, i4)).pipe(map2(function(b6, ii) {
          return resultSelector(a4, b6, i4, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator, ExhaustMapSubscriber;
var init_exhaustMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/exhaustMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    ExhaustMapOperator = function() {
      function ExhaustMapOperator2(project) {
        this.project = project;
      }
      ExhaustMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
      };
      return ExhaustMapOperator2;
    }();
    ExhaustMapSubscriber = function(_super) {
      __extends(ExhaustMapSubscriber2, _super);
      function ExhaustMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
      }
      ExhaustMapSubscriber2.prototype._next = function(value) {
        if (!this.hasSubscription) {
          this.tryNext(value);
        }
      };
      ExhaustMapSubscriber2.prototype.tryNext = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
      };
      ExhaustMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      ExhaustMapSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      ExhaustMapSubscriber2.prototype.notifyError = function(err) {
        this.destination.error(err);
      };
      ExhaustMapSubscriber2.prototype.notifyComplete = function() {
        this.hasSubscription = false;
        if (this.hasCompleted) {
          this.destination.complete();
        }
      };
      return ExhaustMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/expand.js
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator, ExpandSubscriber;
var init_expand = __esm({
  "node_modules/rxjs/_esm5/internal/operators/expand.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    ExpandOperator = function() {
      function ExpandOperator2(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }
      ExpandOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
      };
      return ExpandOperator2;
    }();
    ExpandSubscriber = function(_super) {
      __extends(ExpandSubscriber2, _super);
      function ExpandSubscriber2(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
          _this.buffer = [];
        }
        return _this;
      }
      ExpandSubscriber2.dispatch = function(arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
      };
      ExpandSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (destination.closed) {
          this._complete();
          return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
          destination.next(value);
          try {
            var project = this.project;
            var result = project(value, index);
            if (!this.scheduler) {
              this.subscribeToProjection(result, value, index);
            } else {
              var state3 = { subscriber: this, result, value, index };
              var destination_1 = this.destination;
              destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state3));
            }
          } catch (e3) {
            destination.error(e3);
          }
        } else {
          this.buffer.push(value);
        }
      };
      ExpandSubscriber2.prototype.subscribeToProjection = function(result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
      };
      ExpandSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
        this.unsubscribe();
      };
      ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
        this._next(innerValue);
      };
      ExpandSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2 && buffer2.length > 0) {
          this._next(buffer2.shift());
        }
        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
      };
      return ExpandSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/finalize.js
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator, FinallySubscriber;
var init_finalize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/finalize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subscription();
    FinallyOperator = function() {
      function FinallyOperator2(callback) {
        this.callback = callback;
      }
      FinallyOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
      };
      return FinallyOperator2;
    }();
    FinallySubscriber = function(_super) {
      __extends(FinallySubscriber2, _super);
      function FinallySubscriber2(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
      }
      return FinallySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/find.js
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator, FindValueSubscriber;
var init_find = __esm({
  "node_modules/rxjs/_esm5/internal/operators/find.js"() {
    init_tslib_es6();
    init_Subscriber();
    FindValueOperator = function() {
      function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }
      FindValueOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
      };
      return FindValueOperator2;
    }();
    FindValueSubscriber = function(_super) {
      __extends(FindValueSubscriber2, _super);
      function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
      }
      FindValueSubscriber2.prototype.notifyComplete = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
      };
      FindValueSubscriber2.prototype._next = function(value) {
        var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
        var index = this.index++;
        try {
          var result = predicate.call(thisArg || this, value, index, this.source);
          if (result) {
            this.notifyComplete(this.yieldIndex ? index : value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      FindValueSubscriber2.prototype._complete = function() {
        this.notifyComplete(this.yieldIndex ? -1 : void 0);
      };
      return FindValueSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/findIndex.js
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
var init_findIndex = __esm({
  "node_modules/rxjs/_esm5/internal/operators/findIndex.js"() {
    init_find();
  }
});

// node_modules/rxjs/_esm5/internal/operators/first.js
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v5, i4) {
      return predicate(v5, i4, source);
    }) : identity3, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_first = __esm({
  "node_modules/rxjs/_esm5/internal/operators/first.js"() {
    init_EmptyError();
    init_filter();
    init_take();
    init_defaultIfEmpty();
    init_throwIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator, IgnoreElementsSubscriber;
var init_ignoreElements = __esm({
  "node_modules/rxjs/_esm5/internal/operators/ignoreElements.js"() {
    init_tslib_es6();
    init_Subscriber();
    IgnoreElementsOperator = function() {
      function IgnoreElementsOperator2() {
      }
      IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
      };
      return IgnoreElementsOperator2;
    }();
    IgnoreElementsSubscriber = function(_super) {
      __extends(IgnoreElementsSubscriber2, _super);
      function IgnoreElementsSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      IgnoreElementsSubscriber2.prototype._next = function(unused) {
      };
      return IgnoreElementsSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/isEmpty.js
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator, IsEmptySubscriber;
var init_isEmpty = __esm({
  "node_modules/rxjs/_esm5/internal/operators/isEmpty.js"() {
    init_tslib_es6();
    init_Subscriber();
    IsEmptyOperator = function() {
      function IsEmptyOperator2() {
      }
      IsEmptyOperator2.prototype.call = function(observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
      };
      return IsEmptyOperator2;
    }();
    IsEmptySubscriber = function(_super) {
      __extends(IsEmptySubscriber2, _super);
      function IsEmptySubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
        var destination = this.destination;
        destination.next(isEmpty2);
        destination.complete();
      };
      IsEmptySubscriber2.prototype._next = function(value) {
        this.notifyComplete(false);
      };
      IsEmptySubscriber2.prototype._complete = function() {
        this.notifyComplete(true);
      };
      return IsEmptySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeLast.js
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty4();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator, TakeLastSubscriber;
var init_takeLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    init_empty();
    TakeLastOperator = function() {
      function TakeLastOperator2(total) {
        this.total = total;
        if (this.total < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      TakeLastOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
      };
      return TakeLastOperator2;
    }();
    TakeLastSubscriber = function(_super) {
      __extends(TakeLastSubscriber2, _super);
      function TakeLastSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
      }
      TakeLastSubscriber2.prototype._next = function(value) {
        var ring = this.ring;
        var total = this.total;
        var count2 = this.count++;
        if (ring.length < total) {
          ring.push(value);
        } else {
          var index = count2 % total;
          ring[index] = value;
        }
      };
      TakeLastSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        var count2 = this.count;
        if (count2 > 0) {
          var total = this.count >= this.total ? this.total : this.count;
          var ring = this.ring;
          for (var i4 = 0; i4 < total; i4++) {
            var idx = count2++ % total;
            destination.next(ring[idx]);
          }
        }
        destination.complete();
      };
      return TakeLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/last.js
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v5, i4) {
      return predicate(v5, i4, source);
    }) : identity3, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var init_last = __esm({
  "node_modules/rxjs/_esm5/internal/operators/last.js"() {
    init_EmptyError();
    init_filter();
    init_takeLast();
    init_throwIfEmpty();
    init_defaultIfEmpty();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mapTo.js
function mapTo(value) {
  return function(source) {
    return source.lift(new MapToOperator(value));
  };
}
var MapToOperator, MapToSubscriber;
var init_mapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mapTo.js"() {
    init_tslib_es6();
    init_Subscriber();
    MapToOperator = function() {
      function MapToOperator2(value) {
        this.value = value;
      }
      MapToOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
      };
      return MapToOperator2;
    }();
    MapToSubscriber = function(_super) {
      __extends(MapToSubscriber2, _super);
      function MapToSubscriber2(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
      }
      MapToSubscriber2.prototype._next = function(x5) {
        this.destination.next(this.value);
      };
      return MapToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/materialize.js
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator, MaterializeSubscriber;
var init_materialize = __esm({
  "node_modules/rxjs/_esm5/internal/operators/materialize.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Notification();
    MaterializeOperator = function() {
      function MaterializeOperator2() {
      }
      MaterializeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
      };
      return MaterializeOperator2;
    }();
    MaterializeSubscriber = function(_super) {
      __extends(MaterializeSubscriber2, _super);
      function MaterializeSubscriber2(destination) {
        return _super.call(this, destination) || this;
      }
      MaterializeSubscriber2.prototype._next = function(value) {
        this.destination.next(Notification.createNext(value));
      };
      MaterializeSubscriber2.prototype._error = function(err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
      };
      MaterializeSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
      };
      return MaterializeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator, ScanSubscriber;
var init_scan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/scan.js"() {
    init_tslib_es6();
    init_Subscriber();
    ScanOperator = function() {
      function ScanOperator2(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
          hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }
      ScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
      };
      return ScanOperator2;
    }();
    ScanSubscriber = function(_super) {
      __extends(ScanSubscriber2, _super);
      function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
      }
      Object.defineProperty(ScanSubscriber2.prototype, "seed", {
        get: function() {
          return this._seed;
        },
        set: function(value) {
          this.hasSeed = true;
          this._seed = value;
        },
        enumerable: true,
        configurable: true
      });
      ScanSubscriber2.prototype._next = function(value) {
        if (!this.hasSeed) {
          this.seed = value;
          this.destination.next(value);
        } else {
          return this._tryNext(value);
        }
      };
      ScanSubscriber2.prototype._tryNext = function(value) {
        var index = this.index++;
        var result;
        try {
          result = this.accumulator(this.seed, value, index);
        } catch (err) {
          this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
      };
      return ScanSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/reduce.js
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value, index) {
      return accumulator(acc, value, index + 1);
    }), takeLast(1))(source);
  };
}
var init_reduce = __esm({
  "node_modules/rxjs/_esm5/internal/operators/reduce.js"() {
    init_scan();
    init_takeLast();
    init_defaultIfEmpty();
    init_pipe();
  }
});

// node_modules/rxjs/_esm5/internal/operators/max.js
function max2(comparer) {
  var max3 = typeof comparer === "function" ? function(x5, y7) {
    return comparer(x5, y7) > 0 ? x5 : y7;
  } : function(x5, y7) {
    return x5 > y7 ? x5 : y7;
  };
  return reduce(max3);
}
var init_max = __esm({
  "node_modules/rxjs/_esm5/internal/operators/max.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/merge.js
function merge2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge.apply(void 0, [source].concat(observables)));
  };
}
var init_merge2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/merge.js"() {
    init_merge();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
var init_mergeMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js"() {
    init_mergeMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/mergeScan.js
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator, MergeScanSubscriber;
var init_mergeScan = __esm({
  "node_modules/rxjs/_esm5/internal/operators/mergeScan.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    MergeScanOperator = function() {
      function MergeScanOperator2(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }
      MergeScanOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
      };
      return MergeScanOperator2;
    }();
    MergeScanSubscriber = function(_super) {
      __extends(MergeScanSubscriber2, _super);
      function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
      }
      MergeScanSubscriber2.prototype._next = function(value) {
        if (this.active < this.concurrent) {
          var index = this.index++;
          var destination = this.destination;
          var ish = void 0;
          try {
            var accumulator = this.accumulator;
            ish = accumulator(this.acc, value, index);
          } catch (e3) {
            return destination.error(e3);
          }
          this.active++;
          this._innerSub(ish);
        } else {
          this.buffer.push(value);
        }
      };
      MergeScanSubscriber2.prototype._innerSub = function(ish) {
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = innerSubscribe(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          destination.add(innerSubscription);
        }
      };
      MergeScanSubscriber2.prototype._complete = function() {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
        this.unsubscribe();
      };
      MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
      };
      MergeScanSubscriber2.prototype.notifyComplete = function() {
        var buffer2 = this.buffer;
        this.active--;
        if (buffer2.length > 0) {
          this._next(buffer2.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }
          this.destination.complete();
        }
      };
      return MergeScanSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/min.js
function min2(comparer) {
  var min3 = typeof comparer === "function" ? function(x5, y7) {
    return comparer(x5, y7) < 0 ? x5 : y7;
  } : function(x5, y7) {
    return x5 < y7 ? x5 : y7;
  };
  return reduce(min3);
}
var init_min = __esm({
  "node_modules/rxjs/_esm5/internal/operators/min.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/multicast.js
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator;
var init_multicast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/multicast.js"() {
    init_ConnectableObservable();
    MulticastOperator = function() {
      function MulticastOperator2(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }
      MulticastOperator2.prototype.call = function(subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      };
      return MulticastOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js
function onErrorResumeNext2() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator, OnErrorResumeNextSubscriber;
var init_onErrorResumeNext2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/onErrorResumeNext.js"() {
    init_tslib_es6();
    init_from();
    init_isArray();
    init_innerSubscribe();
    OnErrorResumeNextOperator = function() {
      function OnErrorResumeNextOperator2(nextSources) {
        this.nextSources = nextSources;
      }
      OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
      };
      return OnErrorResumeNextOperator2;
    }();
    OnErrorResumeNextSubscriber = function(_super) {
      __extends(OnErrorResumeNextSubscriber2, _super);
      function OnErrorResumeNextSubscriber2(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
      }
      OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
        this.subscribeToNextSource();
      };
      OnErrorResumeNextSubscriber2.prototype._error = function(err) {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype._complete = function() {
        this.subscribeToNextSource();
        this.unsubscribe();
      };
      OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
        var next = this.nextSources.shift();
        if (!!next) {
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = innerSubscribe(next, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
          }
        } else {
          this.destination.complete();
        }
      };
      return OnErrorResumeNextSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/pairwise.js
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator, PairwiseSubscriber;
var init_pairwise = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pairwise.js"() {
    init_tslib_es6();
    init_Subscriber();
    PairwiseOperator = function() {
      function PairwiseOperator2() {
      }
      PairwiseOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
      };
      return PairwiseOperator2;
    }();
    PairwiseSubscriber = function(_super) {
      __extends(PairwiseSubscriber2, _super);
      function PairwiseSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
      }
      PairwiseSubscriber2.prototype._next = function(value) {
        var pair;
        if (this.hasPrev) {
          pair = [this.prev, value];
        } else {
          this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
          this.destination.next(pair);
        }
      };
      return PairwiseSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/partition.js
function partition2(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not(predicate, thisArg))(source)
    ];
  };
}
var init_partition2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/partition.js"() {
    init_not();
    init_filter();
  }
});

// node_modules/rxjs/_esm5/internal/operators/pluck.js
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length2 = properties.length;
  if (length2 === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map2(plucker(properties, length2))(source);
  };
}
function plucker(props, length2) {
  var mapper = function(x5) {
    var currentProp = x5;
    for (var i4 = 0; i4 < length2; i4++) {
      var p6 = currentProp != null ? currentProp[props[i4]] : void 0;
      if (p6 !== void 0) {
        currentProp = p6;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
var init_pluck = __esm({
  "node_modules/rxjs/_esm5/internal/operators/pluck.js"() {
    init_map();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publish.js
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
var init_publish = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publish.js"() {
    init_Subject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishBehavior.js
function publishBehavior(value) {
  return function(source) {
    return multicast(new BehaviorSubject(value))(source);
  };
}
var init_publishBehavior = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishBehavior.js"() {
    init_BehaviorSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishLast.js
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
var init_publishLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishLast.js"() {
    init_AsyncSubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/publishReplay.js
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
var init_publishReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/publishReplay.js"() {
    init_ReplaySubject();
    init_multicast();
  }
});

// node_modules/rxjs/_esm5/internal/operators/race.js
function race2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race.apply(void 0, [source].concat(observables)));
  };
}
var init_race2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/race.js"() {
    init_isArray();
    init_race();
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeat.js
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty4();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator, RepeatSubscriber;
var init_repeat = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeat.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_empty();
    RepeatOperator = function() {
      function RepeatOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RepeatOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
      };
      return RepeatOperator2;
    }();
    RepeatSubscriber = function(_super) {
      __extends(RepeatSubscriber2, _super);
      function RepeatSubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RepeatSubscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          var _a2 = this, source = _a2.source, count2 = _a2.count;
          if (count2 === 0) {
            return _super.prototype.complete.call(this);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RepeatSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/repeatWhen.js
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator, RepeatWhenSubscriber;
var init_repeatWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/repeatWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RepeatWhenOperator = function() {
      function RepeatWhenOperator2(notifier) {
        this.notifier = notifier;
      }
      RepeatWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
      };
      return RepeatWhenOperator2;
    }();
    RepeatWhenSubscriber = function(_super) {
      __extends(RepeatWhenSubscriber2, _super);
      function RepeatWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
      }
      RepeatWhenSubscriber2.prototype.notifyNext = function() {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
      };
      RepeatWhenSubscriber2.prototype.notifyComplete = function() {
        if (this.sourceIsBeingSubscribedTo === false) {
          return _super.prototype.complete.call(this);
        }
      };
      RepeatWhenSubscriber2.prototype.complete = function() {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
          if (!this.retries) {
            this.subscribeToRetries();
          }
          if (!this.retriesSubscription || this.retriesSubscription.closed) {
            return _super.prototype.complete.call(this);
          }
          this._unsubscribeAndRecycle();
          this.notifications.next(void 0);
        }
      };
      RepeatWhenSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
        if (notifications) {
          notifications.unsubscribe();
          this.notifications = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
      };
      RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
        this.notifications = new Subject();
        var retries;
        try {
          var notifier = this.notifier;
          retries = notifier(this.notifications);
        } catch (e3) {
          return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      };
      return RepeatWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retry.js
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator, RetrySubscriber;
var init_retry = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retry.js"() {
    init_tslib_es6();
    init_Subscriber();
    RetryOperator = function() {
      function RetryOperator2(count2, source) {
        this.count = count2;
        this.source = source;
      }
      RetryOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      };
      return RetryOperator2;
    }();
    RetrySubscriber = function(_super) {
      __extends(RetrySubscriber2, _super);
      function RetrySubscriber2(destination, count2, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count2;
        _this.source = source;
        return _this;
      }
      RetrySubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _a2 = this, source = _a2.source, count2 = _a2.count;
          if (count2 === 0) {
            return _super.prototype.error.call(this, err);
          } else if (count2 > -1) {
            this.count = count2 - 1;
          }
          source.subscribe(this._unsubscribeAndRecycle());
        }
      };
      return RetrySubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/retryWhen.js
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator, RetryWhenSubscriber;
var init_retryWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/retryWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    RetryWhenOperator = function() {
      function RetryWhenOperator2(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }
      RetryWhenOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      };
      return RetryWhenOperator2;
    }();
    RetryWhenSubscriber = function(_super) {
      __extends(RetryWhenSubscriber2, _super);
      function RetryWhenSubscriber2(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
      }
      RetryWhenSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var errors = this.errors;
          var retries = this.retries;
          var retriesSubscription = this.retriesSubscription;
          if (!retries) {
            errors = new Subject();
            try {
              var notifier = this.notifier;
              retries = notifier(errors);
            } catch (e3) {
              return _super.prototype.error.call(this, e3);
            }
            retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
          } else {
            this.errors = void 0;
            this.retriesSubscription = void 0;
          }
          this._unsubscribeAndRecycle();
          this.errors = errors;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors.next(err);
        }
      };
      RetryWhenSubscriber2.prototype._unsubscribe = function() {
        var _a2 = this, errors = _a2.errors, retriesSubscription = _a2.retriesSubscription;
        if (errors) {
          errors.unsubscribe();
          this.errors = void 0;
        }
        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = void 0;
        }
        this.retries = void 0;
      };
      RetryWhenSubscriber2.prototype.notifyNext = function() {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
      };
      return RetryWhenSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sample.js
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator, SampleSubscriber;
var init_sample = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sample.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SampleOperator = function() {
      function SampleOperator2(notifier) {
        this.notifier = notifier;
      }
      SampleOperator2.prototype.call = function(subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
      };
      return SampleOperator2;
    }();
    SampleSubscriber = function(_super) {
      __extends(SampleSubscriber2, _super);
      function SampleSubscriber2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
      }
      SampleSubscriber2.prototype._next = function(value) {
        this.value = value;
        this.hasValue = true;
      };
      SampleSubscriber2.prototype.notifyNext = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.notifyComplete = function() {
        this.emitValue();
      };
      SampleSubscriber2.prototype.emitValue = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.value);
        }
      };
      return SampleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sampleTime.js
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
function dispatchNotification(state3) {
  var subscriber = state3.subscriber, period = state3.period;
  subscriber.notifyNext();
  this.schedule(state3, period);
}
var SampleTimeOperator, SampleTimeSubscriber;
var init_sampleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sampleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    SampleTimeOperator = function() {
      function SampleTimeOperator2(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
      }
      SampleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
      };
      return SampleTimeOperator2;
    }();
    SampleTimeSubscriber = function(_super) {
      __extends(SampleTimeSubscriber2, _super);
      function SampleTimeSubscriber2(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
        return _this;
      }
      SampleTimeSubscriber2.prototype._next = function(value) {
        this.lastValue = value;
        this.hasValue = true;
      };
      SampleTimeSubscriber2.prototype.notifyNext = function() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.lastValue);
        }
      };
      return SampleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator, SequenceEqualSubscriber, SequenceEqualCompareToSubscriber;
var init_sequenceEqual = __esm({
  "node_modules/rxjs/_esm5/internal/operators/sequenceEqual.js"() {
    init_tslib_es6();
    init_Subscriber();
    SequenceEqualOperator = function() {
      function SequenceEqualOperator2(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
      }
      SequenceEqualOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
      };
      return SequenceEqualOperator2;
    }();
    SequenceEqualSubscriber = function(_super) {
      __extends(SequenceEqualSubscriber2, _super);
      function SequenceEqualSubscriber2(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
      }
      SequenceEqualSubscriber2.prototype._next = function(value) {
        if (this._oneComplete && this._b.length === 0) {
          this.emit(false);
        } else {
          this._a.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype._complete = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
        this.unsubscribe();
      };
      SequenceEqualSubscriber2.prototype.checkValues = function() {
        var _c = this, _a2 = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a2.length > 0 && _b.length > 0) {
          var a4 = _a2.shift();
          var b6 = _b.shift();
          var areEqual = false;
          try {
            areEqual = comparator ? comparator(a4, b6) : a4 === b6;
          } catch (e3) {
            this.destination.error(e3);
          }
          if (!areEqual) {
            this.emit(false);
          }
        }
      };
      SequenceEqualSubscriber2.prototype.emit = function(value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
      };
      SequenceEqualSubscriber2.prototype.nextB = function(value) {
        if (this._oneComplete && this._a.length === 0) {
          this.emit(false);
        } else {
          this._b.push(value);
          this.checkValues();
        }
      };
      SequenceEqualSubscriber2.prototype.completeB = function() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
      };
      return SequenceEqualSubscriber2;
    }(Subscriber);
    SequenceEqualCompareToSubscriber = function(_super) {
      __extends(SequenceEqualCompareToSubscriber2, _super);
      function SequenceEqualCompareToSubscriber2(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
      }
      SequenceEqualCompareToSubscriber2.prototype._next = function(value) {
        this.parent.nextB(value);
      };
      SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
        this.parent.error(err);
        this.unsubscribe();
      };
      SequenceEqualCompareToSubscriber2.prototype._complete = function() {
        this.parent.completeB();
        this.unsubscribe();
      };
      return SequenceEqualCompareToSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/share.js
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
var init_share = __esm({
  "node_modules/rxjs/_esm5/internal/operators/share.js"() {
    init_multicast();
    init_refCount();
    init_Subject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b = _a2.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value) {
          subject.next(value);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
var init_shareReplay = __esm({
  "node_modules/rxjs/_esm5/internal/operators/shareReplay.js"() {
    init_ReplaySubject();
  }
});

// node_modules/rxjs/_esm5/internal/operators/single.js
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator, SingleSubscriber;
var init_single = __esm({
  "node_modules/rxjs/_esm5/internal/operators/single.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_EmptyError();
    SingleOperator = function() {
      function SingleOperator2(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }
      SingleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
      };
      return SingleOperator2;
    }();
    SingleSubscriber = function(_super) {
      __extends(SingleSubscriber2, _super);
      function SingleSubscriber2(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
      }
      SingleSubscriber2.prototype.applySingleValue = function(value) {
        if (this.seenValue) {
          this.destination.error("Sequence contains more than one element");
        } else {
          this.seenValue = true;
          this.singleValue = value;
        }
      };
      SingleSubscriber2.prototype._next = function(value) {
        var index = this.index++;
        if (this.predicate) {
          this.tryNext(value, index);
        } else {
          this.applySingleValue(value);
        }
      };
      SingleSubscriber2.prototype.tryNext = function(value, index) {
        try {
          if (this.predicate(value, index, this.source)) {
            this.applySingleValue(value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      };
      SingleSubscriber2.prototype._complete = function() {
        var destination = this.destination;
        if (this.index > 0) {
          destination.next(this.seenValue ? this.singleValue : void 0);
          destination.complete();
        } else {
          destination.error(new EmptyError());
        }
      };
      return SingleSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skip.js
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator, SkipSubscriber;
var init_skip = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skip.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipOperator = function() {
      function SkipOperator2(total) {
        this.total = total;
      }
      SkipOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
      };
      return SkipOperator2;
    }();
    SkipSubscriber = function(_super) {
      __extends(SkipSubscriber2, _super);
      function SkipSubscriber2(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
      }
      SkipSubscriber2.prototype._next = function(x5) {
        if (++this.count > this.total) {
          this.destination.next(x5);
        }
      };
      return SkipSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipLast.js
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator, SkipLastSubscriber;
var init_skipLast = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipLast.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_ArgumentOutOfRangeError();
    SkipLastOperator = function() {
      function SkipLastOperator2(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
          throw new ArgumentOutOfRangeError();
        }
      }
      SkipLastOperator2.prototype.call = function(subscriber, source) {
        if (this._skipCount === 0) {
          return source.subscribe(new Subscriber(subscriber));
        } else {
          return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
      };
      return SkipLastOperator2;
    }();
    SkipLastSubscriber = function(_super) {
      __extends(SkipLastSubscriber2, _super);
      function SkipLastSubscriber2(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
      }
      SkipLastSubscriber2.prototype._next = function(value) {
        var skipCount = this._skipCount;
        var count2 = this._count++;
        if (count2 < skipCount) {
          this._ring[count2] = value;
        } else {
          var currentIndex = count2 % skipCount;
          var ring = this._ring;
          var oldValue = ring[currentIndex];
          ring[currentIndex] = value;
          this.destination.next(oldValue);
        }
      };
      return SkipLastSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipUntil.js
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator, SkipUntilSubscriber;
var init_skipUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    SkipUntilOperator = function() {
      function SkipUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      SkipUntilOperator2.prototype.call = function(destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      };
      return SkipUntilOperator2;
    }();
    SkipUntilSubscriber = function(_super) {
      __extends(SkipUntilSubscriber2, _super);
      function SkipUntilSubscriber2(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = innerSubscribe(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
          _this.add(innerSubscription);
          _this.innerSubscription = innerSubscription;
        }
        return _this;
      }
      SkipUntilSubscriber2.prototype._next = function(value) {
        if (this.hasValue) {
          _super.prototype._next.call(this, value);
        }
      };
      SkipUntilSubscriber2.prototype.notifyNext = function() {
        this.hasValue = true;
        if (this.innerSubscription) {
          this.innerSubscription.unsubscribe();
        }
      };
      SkipUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return SkipUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/skipWhile.js
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator, SkipWhileSubscriber;
var init_skipWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/skipWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    SkipWhileOperator = function() {
      function SkipWhileOperator2(predicate) {
        this.predicate = predicate;
      }
      SkipWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator2;
    }();
    SkipWhileSubscriber = function(_super) {
      __extends(SkipWhileSubscriber2, _super);
      function SkipWhileSubscriber2(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
      }
      SkipWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        if (this.skipping) {
          this.tryCallPredicate(value);
        }
        if (!this.skipping) {
          destination.next(value);
        }
      };
      SkipWhileSubscriber2.prototype.tryCallPredicate = function(value) {
        try {
          var result = this.predicate(value, this.index++);
          this.skipping = Boolean(result);
        } catch (err) {
          this.destination.error(err);
        }
      };
      return SkipWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/startWith.js
function startWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  var scheduler = array2[array2.length - 1];
  if (isScheduler(scheduler)) {
    array2.pop();
    return function(source) {
      return concat3(array2, source, scheduler);
    };
  } else {
    return function(source) {
      return concat3(array2, source);
    };
  }
}
var init_startWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/startWith.js"() {
    init_concat();
    init_isScheduler();
  }
});

// node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
var SubscribeOnObservable;
var init_SubscribeOnObservable = __esm({
  "node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js"() {
    init_tslib_es6();
    init_Observable();
    init_asap();
    init_isNumeric();
    SubscribeOnObservable = function(_super) {
      __extends(SubscribeOnObservable2, _super);
      function SubscribeOnObservable2(source, delayTime, scheduler) {
        if (delayTime === void 0) {
          delayTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
          _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== "function") {
          _this.scheduler = asap;
        }
        return _this;
      }
      SubscribeOnObservable2.create = function(source, delay2, scheduler) {
        if (delay2 === void 0) {
          delay2 = 0;
        }
        if (scheduler === void 0) {
          scheduler = asap;
        }
        return new SubscribeOnObservable2(source, delay2, scheduler);
      };
      SubscribeOnObservable2.dispatch = function(arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
      };
      SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
        var delay2 = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
          source,
          subscriber
        });
      };
      return SubscribeOnObservable2;
    }(Observable);
  }
});

// node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator;
var init_subscribeOn = __esm({
  "node_modules/rxjs/_esm5/internal/operators/subscribeOn.js"() {
    init_SubscribeOnObservable();
    SubscribeOnOperator = function() {
      function SubscribeOnOperator2(scheduler, delay2) {
        this.scheduler = scheduler;
        this.delay = delay2;
      }
      SubscribeOnOperator2.prototype.call = function(subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
      };
      return SubscribeOnOperator2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a4, i4) {
        return from3(project(a4, i4)).pipe(map2(function(b6, ii) {
          return resultSelector(a4, b6, i4, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator, SwitchMapSubscriber;
var init_switchMap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMap.js"() {
    init_tslib_es6();
    init_map();
    init_from();
    init_innerSubscribe();
    SwitchMapOperator = function() {
      function SwitchMapOperator2(project) {
        this.project = project;
      }
      SwitchMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator2;
    }();
    SwitchMapSubscriber = function(_super) {
      __extends(SwitchMapSubscriber2, _super);
      function SwitchMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
      }
      SwitchMapSubscriber2.prototype._next = function(value) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value, index);
        } catch (error) {
          this.destination.error(error);
          return;
        }
        this._innerSub(result);
      };
      SwitchMapSubscriber2.prototype._innerSub = function(result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }
        var innerSubscriber = new SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = innerSubscribe(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
          destination.add(this.innerSubscription);
        }
      };
      SwitchMapSubscriber2.prototype._complete = function() {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
          _super.prototype._complete.call(this);
        }
        this.unsubscribe();
      };
      SwitchMapSubscriber2.prototype._unsubscribe = function() {
        this.innerSubscription = void 0;
      };
      SwitchMapSubscriber2.prototype.notifyComplete = function() {
        this.innerSubscription = void 0;
        if (this.isStopped) {
          _super.prototype._complete.call(this);
        }
      };
      SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
        this.destination.next(innerValue);
      };
      return SwitchMapSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchAll.js
function switchAll() {
  return switchMap(identity3);
}
var init_switchAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchAll.js"() {
    init_switchMap();
    init_identity();
  }
});

// node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
var init_switchMapTo = __esm({
  "node_modules/rxjs/_esm5/internal/operators/switchMapTo.js"() {
    init_switchMap();
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator, TakeUntilSubscriber;
var init_takeUntil = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeUntil.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    TakeUntilOperator = function() {
      function TakeUntilOperator2(notifier) {
        this.notifier = notifier;
      }
      TakeUntilOperator2.prototype.call = function(subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
          takeUntilSubscriber.add(notifierSubscription);
          return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
      };
      return TakeUntilOperator2;
    }();
    TakeUntilSubscriber = function(_super) {
      __extends(TakeUntilSubscriber2, _super);
      function TakeUntilSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
      }
      TakeUntilSubscriber2.prototype.notifyNext = function() {
        this.seenValue = true;
        this.complete();
      };
      TakeUntilSubscriber2.prototype.notifyComplete = function() {
      };
      return TakeUntilSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator, TakeWhileSubscriber;
var init_takeWhile = __esm({
  "node_modules/rxjs/_esm5/internal/operators/takeWhile.js"() {
    init_tslib_es6();
    init_Subscriber();
    TakeWhileOperator = function() {
      function TakeWhileOperator2(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
      }
      TakeWhileOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
      };
      return TakeWhileOperator2;
    }();
    TakeWhileSubscriber = function(_super) {
      __extends(TakeWhileSubscriber2, _super);
      function TakeWhileSubscriber2(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
      }
      TakeWhileSubscriber2.prototype._next = function(value) {
        var destination = this.destination;
        var result;
        try {
          result = this.predicate(value, this.index++);
        } catch (err) {
          destination.error(err);
          return;
        }
        this.nextOrComplete(value, result);
      };
      TakeWhileSubscriber2.prototype.nextOrComplete = function(value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
          destination.next(value);
        } else {
          if (this.inclusive) {
            destination.next(value);
          }
          destination.complete();
        }
      };
      return TakeWhileSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/tap.js
function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}
var DoOperator, TapSubscriber;
var init_tap = __esm({
  "node_modules/rxjs/_esm5/internal/operators/tap.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_noop();
    init_isFunction();
    DoOperator = function() {
      function DoOperator2(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }
      DoOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator2;
    }();
    TapSubscriber = function(_super) {
      __extends(TapSubscriber2, _super);
      function TapSubscriber2(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
          _this._context = _this;
          _this._tapNext = observerOrNext;
        } else if (observerOrNext) {
          _this._context = observerOrNext;
          _this._tapNext = observerOrNext.next || noop;
          _this._tapError = observerOrNext.error || noop;
          _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
      }
      TapSubscriber2.prototype._next = function(value) {
        try {
          this._tapNext.call(this._context, value);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(value);
      };
      TapSubscriber2.prototype._error = function(err) {
        try {
          this._tapError.call(this._context, err);
        } catch (err2) {
          this.destination.error(err2);
          return;
        }
        this.destination.error(err);
      };
      TapSubscriber2.prototype._complete = function() {
        try {
          this._tapComplete.call(this._context);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        return this.destination.complete();
      };
      return TapSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var defaultThrottleConfig, ThrottleOperator, ThrottleSubscriber;
var init_throttle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttle.js"() {
    init_tslib_es6();
    init_innerSubscribe();
    defaultThrottleConfig = {
      leading: true,
      trailing: false
    };
    ThrottleOperator = function() {
      function ThrottleOperator2(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
      };
      return ThrottleOperator2;
    }();
    ThrottleSubscriber = function(_super) {
      __extends(ThrottleSubscriber2, _super);
      function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
      }
      ThrottleSubscriber2.prototype._next = function(value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
          if (this._leading) {
            this.send();
          } else {
            this.throttle(value);
          }
        }
      };
      ThrottleSubscriber2.prototype.send = function() {
        var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
        if (_hasValue) {
          this.destination.next(_sendValue);
          this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = void 0;
      };
      ThrottleSubscriber2.prototype.throttle = function(value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
          this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
        }
      };
      ThrottleSubscriber2.prototype.tryDurationSelector = function(value) {
        try {
          return this.durationSelector(value);
        } catch (err) {
          this.destination.error(err);
          return null;
        }
      };
      ThrottleSubscriber2.prototype.throttlingDone = function() {
        var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
        if (_throttled) {
          _throttled.unsubscribe();
        }
        this._throttled = void 0;
        if (_trailing) {
          this.send();
        }
      };
      ThrottleSubscriber2.prototype.notifyNext = function() {
        this.throttlingDone();
      };
      ThrottleSubscriber2.prototype.notifyComplete = function() {
        this.throttlingDone();
      };
      return ThrottleSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
function dispatchNext4(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
var ThrottleTimeOperator, ThrottleTimeSubscriber;
var init_throttleTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/throttleTime.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_async();
    init_throttle();
    ThrottleTimeOperator = function() {
      function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }
      ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      };
      return ThrottleTimeOperator2;
    }();
    ThrottleTimeSubscriber = function(_super) {
      __extends(ThrottleTimeSubscriber2, _super);
      function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
      }
      ThrottleTimeSubscriber2.prototype._next = function(value) {
        if (this.throttled) {
          if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        } else {
          this.add(this.throttled = this.scheduler.schedule(dispatchNext4, this.duration, { subscriber: this }));
          if (this.leading) {
            this.destination.next(value);
          } else if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        }
      };
      ThrottleTimeSubscriber2.prototype._complete = function() {
        if (this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this.destination.complete();
        } else {
          this.destination.complete();
        }
      };
      ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
        var throttled = this.throttled;
        if (throttled) {
          if (this.trailing && this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
          }
          throttled.unsubscribe();
          this.remove(throttled);
          this.throttled = null;
        }
      };
      return ThrottleTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeInterval.js
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a2, value) {
        var current = _a2.current;
        return { value, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map2(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value = _a2.value;
        return new TimeInterval(value, current - last2);
      }));
    });
  };
}
var TimeInterval;
var init_timeInterval = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeInterval.js"() {
    init_async();
    init_scan();
    init_defer();
    init_map();
    TimeInterval = function() {
      function TimeInterval2(value, interval2) {
        this.value = value;
        this.interval = interval2;
      }
      return TimeInterval2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator, TimeoutWithSubscriber;
var init_timeoutWith = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeoutWith.js"() {
    init_tslib_es6();
    init_async();
    init_isDate();
    init_innerSubscribe();
    TimeoutWithOperator = function() {
      function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }
      TimeoutWithOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      };
      return TimeoutWithOperator2;
    }();
    TimeoutWithSubscriber = function(_super) {
      __extends(TimeoutWithSubscriber2, _super);
      function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
      }
      TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
      };
      TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
        var action = this.action;
        if (action) {
          this.action = action.schedule(this, this.waitFor);
        } else {
          this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
        }
      };
      TimeoutWithSubscriber2.prototype._next = function(value) {
        if (!this.absoluteTimeout) {
          this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
      };
      TimeoutWithSubscriber2.prototype._unsubscribe = function() {
        this.action = void 0;
        this.scheduler = null;
        this.withObservable = null;
      };
      return TimeoutWithSubscriber2;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/timeout.js
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
var init_timeout = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timeout.js"() {
    init_async();
    init_TimeoutError();
    init_timeoutWith();
    init_throwError();
  }
});

// node_modules/rxjs/_esm5/internal/operators/timestamp.js
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map2(function(value) {
    return new Timestamp(value, scheduler.now());
  });
}
var Timestamp;
var init_timestamp = __esm({
  "node_modules/rxjs/_esm5/internal/operators/timestamp.js"() {
    init_async();
    init_map();
    Timestamp = function() {
      function Timestamp2(value, timestamp2) {
        this.value = value;
        this.timestamp = timestamp2;
      }
      return Timestamp2;
    }();
  }
});

// node_modules/rxjs/_esm5/internal/operators/toArray.js
function toArrayReducer(arr, item, index) {
  if (index === 0) {
    return [item];
  }
  arr.push(item);
  return arr;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
var init_toArray = __esm({
  "node_modules/rxjs/_esm5/internal/operators/toArray.js"() {
    init_reduce();
  }
});

// node_modules/rxjs/_esm5/internal/operators/window.js
function window2(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator(windowBoundaries));
  };
}
var WindowOperator, WindowSubscriber;
var init_window = __esm({
  "node_modules/rxjs/_esm5/internal/operators/window.js"() {
    init_tslib_es6();
    init_Subject();
    init_innerSubscribe();
    WindowOperator = function() {
      function WindowOperator3(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
          windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
      };
      return WindowOperator3;
    }();
    WindowSubscriber = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function() {
        this.openWindow();
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function() {
        this._complete();
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
      };
      WindowSubscriber3.prototype._unsubscribe = function() {
        this.window = null;
      };
      WindowSubscriber3.prototype.openWindow = function() {
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
      };
      return WindowSubscriber3;
    }(SimpleOuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowCount.js
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator, WindowCountSubscriber;
var init_windowCount = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowCount.js"() {
    init_tslib_es6();
    init_Subscriber();
    init_Subject();
    WindowCountOperator = function() {
      function WindowCountOperator2(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }
      WindowCountOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
      };
      return WindowCountOperator2;
    }();
    WindowCountSubscriber = function(_super) {
      __extends(WindowCountSubscriber2, _super);
      function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
      }
      WindowCountSubscriber2.prototype._next = function(value) {
        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i4 = 0; i4 < len && !this.closed; i4++) {
          windows[i4].next(value);
        }
        var c5 = this.count - windowSize + 1;
        if (c5 >= 0 && c5 % startWindowEvery === 0 && !this.closed) {
          windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
          var window_1 = new Subject();
          windows.push(window_1);
          destination.next(window_1);
        }
      };
      WindowCountSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().error(err);
          }
        }
        this.destination.error(err);
      };
      WindowCountSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().complete();
          }
        }
        this.destination.complete();
      };
      WindowCountSubscriber2.prototype._unsubscribe = function() {
        this.count = 0;
        this.windows = null;
      };
      return WindowCountSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowTime.js
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
function dispatchWindowTimeSpanOnly(state3) {
  var subscriber = state3.subscriber, windowTimeSpan = state3.windowTimeSpan, window3 = state3.window;
  if (window3) {
    subscriber.closeWindow(window3);
  }
  state3.window = subscriber.openWindow();
  this.schedule(state3, windowTimeSpan);
}
function dispatchWindowCreation(state3) {
  var windowTimeSpan = state3.windowTimeSpan, subscriber = state3.subscriber, scheduler = state3.scheduler, windowCreationInterval = state3.windowCreationInterval;
  var window3 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window3, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state3, windowCreationInterval);
}
function dispatchWindowClose(state3) {
  var subscriber = state3.subscriber, window3 = state3.window, context = state3.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window3);
}
var WindowTimeOperator, CountedSubject, WindowTimeSubscriber;
var init_windowTime = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowTime.js"() {
    init_tslib_es6();
    init_Subject();
    init_async();
    init_Subscriber();
    init_isNumeric();
    init_isScheduler();
    WindowTimeOperator = function() {
      function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }
      WindowTimeOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
      };
      return WindowTimeOperator2;
    }();
    CountedSubject = function(_super) {
      __extends(CountedSubject2, _super);
      function CountedSubject2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
      }
      CountedSubject2.prototype.next = function(value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
      };
      Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
        get: function() {
          return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
      });
      return CountedSubject2;
    }(Subject);
    WindowTimeSubscriber = function(_super) {
      __extends(WindowTimeSubscriber2, _super);
      function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window3 = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          var closeState = { subscriber: _this, window: window3, context: null };
          var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
          _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
          _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          var timeSpanOnlyState = { subscriber: _this, window: window3, windowTimeSpan };
          _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
      }
      WindowTimeSubscriber2.prototype._next = function(value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i4 = 0; i4 < len; i4++) {
          var window_1 = windows[i4];
          if (!window_1.closed) {
            window_1.next(value);
            if (window_1.numberOfNextedValues >= this.maxWindowSize) {
              this.closeWindow(window_1);
            }
          }
        }
      };
      WindowTimeSubscriber2.prototype._error = function(err) {
        var windows = this.windows;
        while (windows.length > 0) {
          windows.shift().error(err);
        }
        this.destination.error(err);
      };
      WindowTimeSubscriber2.prototype._complete = function() {
        var windows = this.windows;
        while (windows.length > 0) {
          var window_2 = windows.shift();
          if (!window_2.closed) {
            window_2.complete();
          }
        }
        this.destination.complete();
      };
      WindowTimeSubscriber2.prototype.openWindow = function() {
        var window3 = new CountedSubject();
        this.windows.push(window3);
        var destination = this.destination;
        destination.next(window3);
        return window3;
      };
      WindowTimeSubscriber2.prototype.closeWindow = function(window3) {
        window3.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window3), 1);
      };
      return WindowTimeSubscriber2;
    }(Subscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowToggle.js
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator, WindowToggleSubscriber;
var init_windowToggle = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowToggle.js"() {
    init_tslib_es6();
    init_Subject();
    init_Subscription();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowToggleOperator = function() {
      function WindowToggleOperator2(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }
      WindowToggleOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
      };
      return WindowToggleOperator2;
    }();
    WindowToggleSubscriber = function(_super) {
      __extends(WindowToggleSubscriber2, _super);
      function WindowToggleSubscriber2(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
      }
      WindowToggleSubscriber2.prototype._next = function(value) {
        var contexts = this.contexts;
        if (contexts) {
          var len = contexts.length;
          for (var i4 = 0; i4 < len; i4++) {
            contexts[i4].window.next(value);
          }
        }
      };
      WindowToggleSubscriber2.prototype._error = function(err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_1 = contexts[index];
            context_1.window.error(err);
            context_1.subscription.unsubscribe();
          }
        }
        _super.prototype._error.call(this, err);
      };
      WindowToggleSubscriber2.prototype._complete = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_2 = contexts[index];
            context_2.window.complete();
            context_2.subscription.unsubscribe();
          }
        }
        _super.prototype._complete.call(this);
      };
      WindowToggleSubscriber2.prototype._unsubscribe = function() {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
          var len = contexts.length;
          var index = -1;
          while (++index < len) {
            var context_3 = contexts[index];
            context_3.window.unsubscribe();
            context_3.subscription.unsubscribe();
          }
        }
      };
      WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
          var closingNotifier = void 0;
          try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector(innerValue);
          } catch (e3) {
            return this.error(e3);
          }
          var window_1 = new Subject();
          var subscription = new Subscription();
          var context_4 = { window: window_1, subscription };
          this.contexts.push(context_4);
          var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context_4;
            subscription.add(innerSubscription);
          }
          this.destination.next(window_1);
        } else {
          this.closeWindow(this.contexts.indexOf(outerValue));
        }
      };
      WindowToggleSubscriber2.prototype.notifyError = function(err) {
        this.error(err);
      };
      WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
        if (inner !== this.openSubscription) {
          this.closeWindow(this.contexts.indexOf(inner.context));
        }
      };
      WindowToggleSubscriber2.prototype.closeWindow = function(index) {
        if (index === -1) {
          return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window3 = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window3.complete();
        subscription.unsubscribe();
      };
      return WindowToggleSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/windowWhen.js
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator2(closingSelector));
  };
}
var WindowOperator2, WindowSubscriber2;
var init_windowWhen = __esm({
  "node_modules/rxjs/_esm5/internal/operators/windowWhen.js"() {
    init_tslib_es6();
    init_Subject();
    init_OuterSubscriber();
    init_subscribeToResult();
    WindowOperator2 = function() {
      function WindowOperator3(closingSelector) {
        this.closingSelector = closingSelector;
      }
      WindowOperator3.prototype.call = function(subscriber, source) {
        return source.subscribe(new WindowSubscriber2(subscriber, this.closingSelector));
      };
      return WindowOperator3;
    }();
    WindowSubscriber2 = function(_super) {
      __extends(WindowSubscriber3, _super);
      function WindowSubscriber3(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
      }
      WindowSubscriber3.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype.notifyError = function(error) {
        this._error(error);
      };
      WindowSubscriber3.prototype.notifyComplete = function(innerSub) {
        this.openWindow(innerSub);
      };
      WindowSubscriber3.prototype._next = function(value) {
        this.window.next(value);
      };
      WindowSubscriber3.prototype._error = function(err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype._complete = function() {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
      };
      WindowSubscriber3.prototype.unsubscribeClosingNotification = function() {
        if (this.closingNotification) {
          this.closingNotification.unsubscribe();
        }
      };
      WindowSubscriber3.prototype.openWindow = function(innerSub) {
        if (innerSub === void 0) {
          innerSub = null;
        }
        if (innerSub) {
          this.remove(innerSub);
          innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
          prevWindow.complete();
        }
        var window3 = this.window = new Subject();
        this.destination.next(window3);
        var closingNotifier;
        try {
          var closingSelector = this.closingSelector;
          closingNotifier = closingSelector();
        } catch (e3) {
          this.destination.error(e3);
          this.window.error(e3);
          return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
      };
      return WindowSubscriber3;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator, WithLatestFromSubscriber;
var init_withLatestFrom = __esm({
  "node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js"() {
    init_tslib_es6();
    init_OuterSubscriber();
    init_subscribeToResult();
    WithLatestFromOperator = function() {
      function WithLatestFromOperator2(observables, project) {
        this.observables = observables;
        this.project = project;
      }
      WithLatestFromOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
      };
      return WithLatestFromOperator2;
    }();
    WithLatestFromSubscriber = function(_super) {
      __extends(WithLatestFromSubscriber2, _super);
      function WithLatestFromSubscriber2(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i4 = 0; i4 < len; i4++) {
          _this.toRespond.push(i4);
        }
        for (var i4 = 0; i4 < len; i4++) {
          var observable2 = observables[i4];
          _this.add(subscribeToResult(_this, observable2, void 0, i4));
        }
        return _this;
      }
      WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
          var found = toRespond.indexOf(outerIndex);
          if (found !== -1) {
            toRespond.splice(found, 1);
          }
        }
      };
      WithLatestFromSubscriber2.prototype.notifyComplete = function() {
      };
      WithLatestFromSubscriber2.prototype._next = function(value) {
        if (this.toRespond.length === 0) {
          var args = [value].concat(this.values);
          if (this.project) {
            this._tryProject(args);
          } else {
            this.destination.next(args);
          }
        }
      };
      WithLatestFromSubscriber2.prototype._tryProject = function(args) {
        var result;
        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return WithLatestFromSubscriber2;
    }(OuterSubscriber);
  }
});

// node_modules/rxjs/_esm5/internal/operators/zip.js
function zip2() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip.apply(void 0, [source].concat(observables)));
  };
}
var init_zip2 = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zip.js"() {
    init_zip();
  }
});

// node_modules/rxjs/_esm5/internal/operators/zipAll.js
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var init_zipAll = __esm({
  "node_modules/rxjs/_esm5/internal/operators/zipAll.js"() {
    init_zip();
  }
});

// node_modules/rxjs/_esm5/operators/index.js
var operators_exports = {};
__export(operators_exports, {
  audit: () => audit,
  auditTime: () => auditTime,
  buffer: () => buffer,
  bufferCount: () => bufferCount,
  bufferTime: () => bufferTime,
  bufferToggle: () => bufferToggle,
  bufferWhen: () => bufferWhen,
  catchError: () => catchError,
  combineAll: () => combineAll,
  combineLatest: () => combineLatest2,
  concat: () => concat4,
  concatAll: () => concatAll,
  concatMap: () => concatMap,
  concatMapTo: () => concatMapTo,
  count: () => count,
  debounce: () => debounce,
  debounceTime: () => debounceTime,
  defaultIfEmpty: () => defaultIfEmpty,
  delay: () => delay,
  delayWhen: () => delayWhen,
  dematerialize: () => dematerialize,
  distinct: () => distinct,
  distinctUntilChanged: () => distinctUntilChanged,
  distinctUntilKeyChanged: () => distinctUntilKeyChanged,
  elementAt: () => elementAt,
  endWith: () => endWith,
  every: () => every,
  exhaust: () => exhaust,
  exhaustMap: () => exhaustMap,
  expand: () => expand,
  filter: () => filter,
  finalize: () => finalize,
  find: () => find,
  findIndex: () => findIndex,
  first: () => first,
  flatMap: () => flatMap,
  groupBy: () => groupBy,
  ignoreElements: () => ignoreElements,
  isEmpty: () => isEmpty,
  last: () => last,
  map: () => map2,
  mapTo: () => mapTo,
  materialize: () => materialize,
  max: () => max2,
  merge: () => merge2,
  mergeAll: () => mergeAll,
  mergeMap: () => mergeMap,
  mergeMapTo: () => mergeMapTo,
  mergeScan: () => mergeScan,
  min: () => min2,
  multicast: () => multicast,
  observeOn: () => observeOn,
  onErrorResumeNext: () => onErrorResumeNext2,
  pairwise: () => pairwise,
  partition: () => partition2,
  pluck: () => pluck,
  publish: () => publish,
  publishBehavior: () => publishBehavior,
  publishLast: () => publishLast,
  publishReplay: () => publishReplay,
  race: () => race2,
  reduce: () => reduce,
  refCount: () => refCount,
  repeat: () => repeat,
  repeatWhen: () => repeatWhen,
  retry: () => retry,
  retryWhen: () => retryWhen,
  sample: () => sample,
  sampleTime: () => sampleTime,
  scan: () => scan,
  sequenceEqual: () => sequenceEqual,
  share: () => share,
  shareReplay: () => shareReplay,
  single: () => single,
  skip: () => skip,
  skipLast: () => skipLast,
  skipUntil: () => skipUntil,
  skipWhile: () => skipWhile,
  startWith: () => startWith,
  subscribeOn: () => subscribeOn,
  switchAll: () => switchAll,
  switchMap: () => switchMap,
  switchMapTo: () => switchMapTo,
  take: () => take,
  takeLast: () => takeLast,
  takeUntil: () => takeUntil,
  takeWhile: () => takeWhile,
  tap: () => tap,
  throttle: () => throttle,
  throttleTime: () => throttleTime,
  throwIfEmpty: () => throwIfEmpty,
  timeInterval: () => timeInterval,
  timeout: () => timeout,
  timeoutWith: () => timeoutWith,
  timestamp: () => timestamp,
  toArray: () => toArray,
  window: () => window2,
  windowCount: () => windowCount,
  windowTime: () => windowTime,
  windowToggle: () => windowToggle,
  windowWhen: () => windowWhen,
  withLatestFrom: () => withLatestFrom,
  zip: () => zip2,
  zipAll: () => zipAll
});
var init_operators = __esm({
  "node_modules/rxjs/_esm5/operators/index.js"() {
    init_audit();
    init_auditTime();
    init_buffer();
    init_bufferCount();
    init_bufferTime();
    init_bufferToggle();
    init_bufferWhen();
    init_catchError();
    init_combineAll();
    init_combineLatest2();
    init_concat2();
    init_concatAll();
    init_concatMap();
    init_concatMapTo();
    init_count();
    init_debounce();
    init_debounceTime();
    init_defaultIfEmpty();
    init_delay();
    init_delayWhen();
    init_dematerialize();
    init_distinct();
    init_distinctUntilChanged();
    init_distinctUntilKeyChanged();
    init_elementAt();
    init_endWith();
    init_every();
    init_exhaust();
    init_exhaustMap();
    init_expand();
    init_filter();
    init_finalize();
    init_find();
    init_findIndex();
    init_first();
    init_groupBy();
    init_ignoreElements();
    init_isEmpty();
    init_last();
    init_map();
    init_mapTo();
    init_materialize();
    init_max();
    init_merge2();
    init_mergeAll();
    init_mergeMap();
    init_mergeMapTo();
    init_mergeScan();
    init_min();
    init_multicast();
    init_observeOn();
    init_onErrorResumeNext2();
    init_pairwise();
    init_partition2();
    init_pluck();
    init_publish();
    init_publishBehavior();
    init_publishLast();
    init_publishReplay();
    init_race2();
    init_reduce();
    init_repeat();
    init_repeatWhen();
    init_retry();
    init_retryWhen();
    init_refCount();
    init_sample();
    init_sampleTime();
    init_scan();
    init_sequenceEqual();
    init_share();
    init_shareReplay();
    init_single();
    init_skip();
    init_skipLast();
    init_skipUntil();
    init_skipWhile();
    init_startWith();
    init_subscribeOn();
    init_switchAll();
    init_switchMap();
    init_switchMapTo();
    init_take();
    init_takeLast();
    init_takeUntil();
    init_takeWhile();
    init_tap();
    init_throttle();
    init_throttleTime();
    init_throwIfEmpty();
    init_timeInterval();
    init_timeout();
    init_timeoutWith();
    init_timestamp();
    init_toArray();
    init_window();
    init_windowCount();
    init_windowTime();
    init_windowToggle();
    init_windowWhen();
    init_withLatestFrom();
    init_zip2();
    init_zipAll();
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js
var require_ClientMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ClientMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientMessagePublishEvent = exports.ClientMessageSetSessionConfig = exports.ClientMessageGetSessionConfig = exports.ClientMessageIsLinked = exports.ClientMessageHostSession = void 0;
    function ClientMessageHostSession(params) {
      return Object.assign({ type: "HostSession" }, params);
    }
    exports.ClientMessageHostSession = ClientMessageHostSession;
    function ClientMessageIsLinked(params) {
      return Object.assign({ type: "IsLinked" }, params);
    }
    exports.ClientMessageIsLinked = ClientMessageIsLinked;
    function ClientMessageGetSessionConfig(params) {
      return Object.assign({ type: "GetSessionConfig" }, params);
    }
    exports.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
    function ClientMessageSetSessionConfig(params) {
      return Object.assign({ type: "SetSessionConfig" }, params);
    }
    exports.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
    function ClientMessagePublishEvent(params) {
      return Object.assign({ type: "PublishEvent" }, params);
    }
    exports.ClientMessagePublishEvent = ClientMessagePublishEvent;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js
var require_RxWebSocket = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/RxWebSocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RxWebSocket = exports.ConnectionState = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
      ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
    })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
    var RxWebSocket = class {
      /**
       * Constructor
       * @param url WebSocket server URL
       * @param [WebSocketClass] Custom WebSocket implementation
       */
      constructor(url, WebSocketClass = WebSocket) {
        this.WebSocketClass = WebSocketClass;
        this.webSocket = null;
        this.connectionStateSubject = new rxjs_1.BehaviorSubject(ConnectionState.DISCONNECTED);
        this.incomingDataSubject = new rxjs_1.Subject();
        this.url = url.replace(/^http/, "ws");
      }
      /**
       * Make a websocket connection
       * @returns an Observable that completes when connected
       */
      connect() {
        if (this.webSocket) {
          return (0, rxjs_1.throwError)(new Error("webSocket object is not null"));
        }
        return new rxjs_1.Observable((obs) => {
          let webSocket;
          try {
            this.webSocket = webSocket = new this.WebSocketClass(this.url);
          } catch (err) {
            obs.error(err);
            return;
          }
          this.connectionStateSubject.next(ConnectionState.CONNECTING);
          webSocket.onclose = (evt) => {
            this.clearWebSocket();
            obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
            this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
          };
          webSocket.onopen = (_6) => {
            obs.next();
            obs.complete();
            this.connectionStateSubject.next(ConnectionState.CONNECTED);
          };
          webSocket.onmessage = (evt) => {
            this.incomingDataSubject.next(evt.data);
          };
        }).pipe((0, operators_1.take)(1));
      }
      /**
       * Disconnect from server
       */
      disconnect() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.clearWebSocket();
        this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        try {
          webSocket.close();
        } catch (_a2) {
        }
      }
      /**
       * Emit current connection state and subsequent changes
       * @returns an Observable for the connection state
       */
      get connectionState$() {
        return this.connectionStateSubject.asObservable();
      }
      /**
       * Emit incoming data from server
       * @returns an Observable for the data received
       */
      get incomingData$() {
        return this.incomingDataSubject.asObservable();
      }
      /**
       * Emit incoming JSON data from server. non-JSON data are ignored
       * @returns an Observable for parsed JSON data
       */
      get incomingJSONData$() {
        return this.incomingData$.pipe((0, operators_1.flatMap)((m5) => {
          let j7;
          try {
            j7 = JSON.parse(m5);
          } catch (err) {
            return (0, rxjs_1.empty)();
          }
          return (0, rxjs_1.of)(j7);
        }));
      }
      /**
       * Send data to server
       * @param data text to send
       */
      sendData(data3) {
        const { webSocket } = this;
        if (!webSocket) {
          throw new Error("websocket is not connected");
        }
        webSocket.send(data3);
      }
      clearWebSocket() {
        const { webSocket } = this;
        if (!webSocket) {
          return;
        }
        this.webSocket = null;
        webSocket.onclose = null;
        webSocket.onerror = null;
        webSocket.onmessage = null;
        webSocket.onopen = null;
      }
    };
    exports.RxWebSocket = RxWebSocket;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js
var require_ServerMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/ServerMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isServerMessageFail = void 0;
    function isServerMessageFail(msg) {
      return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
    }
    exports.isServerMessageFail = isServerMessageFail;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js
var require_WalletSDKConnection = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKConnection = void 0;
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var Session_1 = require_Session();
    var types_1 = require_types3();
    var ClientMessage_1 = require_ClientMessage();
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var RxWebSocket_1 = require_RxWebSocket();
    var ServerMessage_1 = require_ServerMessage();
    var HEARTBEAT_INTERVAL = 1e4;
    var REQUEST_TIMEOUT = 6e4;
    var WalletSDKConnection = class {
      /**
       * Constructor
       * @param sessionId Session ID
       * @param sessionKey Session Key
       * @param linkAPIUrl Coinbase Wallet link server URL
       * @param [WebSocketClass] Custom WebSocket implementation
       */
      constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {
        this.sessionId = sessionId;
        this.sessionKey = sessionKey;
        this.diagnostic = diagnostic;
        this.subscriptions = new rxjs_1.Subscription();
        this.destroyed = false;
        this.lastHeartbeatResponse = 0;
        this.nextReqId = (0, types_1.IntNumber)(1);
        this.connectedSubject = new rxjs_1.BehaviorSubject(false);
        this.linkedSubject = new rxjs_1.BehaviorSubject(false);
        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);
        const ws2 = new RxWebSocket_1.RxWebSocket(linkAPIUrl + "/rpc", WebSocketClass);
        this.ws = ws2;
        this.subscriptions.add(ws2.connectionState$.pipe(
          (0, operators_1.tap)((state3) => {
            var _a2;
            return (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {
              state: state3,
              sessionIdHash: Session_1.Session.hash(sessionId)
            });
          }),
          // ignore initial DISCONNECTED state
          (0, operators_1.skip)(1),
          // if DISCONNECTED and not destroyed
          (0, operators_1.filter)((cs3) => cs3 === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),
          // wait 5 seconds
          (0, operators_1.delay)(5e3),
          // check whether it's destroyed again
          (0, operators_1.filter)((_6) => !this.destroyed),
          // reconnect
          (0, operators_1.flatMap)((_6) => ws2.connect()),
          (0, operators_1.retry)()
        ).subscribe());
        this.subscriptions.add(ws2.connectionState$.pipe(
          // ignore initial DISCONNECTED and CONNECTING states
          (0, operators_1.skip)(2),
          (0, operators_1.switchMap)((cs3) => (0, rxjs_1.iif)(
            () => cs3 === RxWebSocket_1.ConnectionState.CONNECTED,
            // if CONNECTED, authenticate, and then check link status
            this.authenticate().pipe((0, operators_1.tap)((_6) => this.sendIsLinked()), (0, operators_1.tap)((_6) => this.sendGetSessionConfig()), (0, operators_1.map)((_6) => true)),
            // if not CONNECTED, emit false immediately
            (0, rxjs_1.of)(false)
          )),
          (0, operators_1.distinctUntilChanged)(),
          (0, operators_1.catchError)((_6) => (0, rxjs_1.of)(false))
        ).subscribe((connected) => this.connectedSubject.next(connected)));
        this.subscriptions.add(ws2.connectionState$.pipe(
          // ignore initial DISCONNECTED state
          (0, operators_1.skip)(1),
          (0, operators_1.switchMap)((cs3) => (0, rxjs_1.iif)(
            () => cs3 === RxWebSocket_1.ConnectionState.CONNECTED,
            // if CONNECTED, start the heartbeat timer
            (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)
          ))
        ).subscribe((i4) => (
          // first timer event updates lastHeartbeat timestamp
          // subsequent calls send heartbeat message
          i4 === 0 ? this.updateLastHeartbeat() : this.heartbeat()
        )));
        this.subscriptions.add(ws2.incomingData$.pipe((0, operators_1.filter)((m5) => m5 === "h")).subscribe((_6) => this.updateLastHeartbeat()));
        this.subscriptions.add(ws2.incomingJSONData$.pipe((0, operators_1.filter)((m5) => ["IsLinkedOK", "Linked"].includes(m5.type))).subscribe((m5) => {
          var _a2;
          const msg = m5;
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.LINKED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            linked: msg.linked,
            type: m5.type,
            onlineGuests: msg.onlineGuests
          });
          this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
        }));
        this.subscriptions.add(ws2.incomingJSONData$.pipe((0, operators_1.filter)((m5) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m5.type))).subscribe((m5) => {
          var _a2;
          const msg = m5;
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {
            sessionIdHash: Session_1.Session.hash(sessionId),
            metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
          });
          this.sessionConfigSubject.next({
            webhookId: msg.webhookId,
            webhookUrl: msg.webhookUrl,
            metadata: msg.metadata
          });
        }));
      }
      /**
       * Make a connection to the server
       */
      connect() {
        var _a2;
        if (this.destroyed) {
          throw new Error("instance is destroyed");
        }
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.ws.connect().subscribe();
      }
      /**
       * Terminate connection, and mark as destroyed. To reconnect, create a new
       * instance of WalletSDKConnection
       */
      destroy() {
        var _a2;
        this.subscriptions.unsubscribe();
        this.ws.disconnect();
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {
          sessionIdHash: Session_1.Session.hash(this.sessionId)
        });
        this.destroyed = true;
      }
      get isDestroyed() {
        return this.destroyed;
      }
      /**
       * Emit true if connected and authenticated, else false
       * @returns an Observable
       */
      get connected$() {
        return this.connectedSubject.asObservable();
      }
      /**
       * Emit once connected
       * @returns an Observable
       */
      get onceConnected$() {
        return this.connected$.pipe((0, operators_1.filter)((v5) => v5), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      /**
       * Emit true if linked (a guest has joined before)
       * @returns an Observable
       */
      get linked$() {
        return this.linkedSubject.asObservable();
      }
      /**
       * Emit once when linked
       * @returns an Observable
       */
      get onceLinked$() {
        return this.linked$.pipe((0, operators_1.filter)((v5) => v5), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));
      }
      /**
       * Emit current session config if available, and subsequent updates
       * @returns an Observable for the session config
       */
      get sessionConfig$() {
        return this.sessionConfigSubject.asObservable();
      }
      /**
       * Emit incoming Event messages
       * @returns an Observable for the messages
       */
      get incomingEvent$() {
        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)((m5) => {
          if (m5.type !== "Event") {
            return false;
          }
          const sme = m5;
          return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
        }), (0, operators_1.map)((m5) => m5));
      }
      /**
       * Set session metadata in SessionConfig object
       * @param key
       * @param value
       * @returns an Observable that completes when successful
       */
      setSessionMetadata(key2, value) {
        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          metadata: { [key2]: value }
        });
        return this.onceConnected$.pipe((0, operators_1.flatMap)((_6) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to set session metadata");
          }
        }));
      }
      /**
       * Publish an event and emit event ID when successful
       * @param event event name
       * @param data event data
       * @param callWebhook whether the webhook should be invoked
       * @returns an Observable that emits event ID when successful
       */
      publishEvent(event, data3, callWebhook = false) {
        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          event,
          data: data3,
          callWebhook
        });
        return this.onceLinked$.pipe((0, operators_1.flatMap)((_6) => this.makeRequest(message)), (0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to publish event");
          }
          return res.eventId;
        }));
      }
      sendData(message) {
        this.ws.sendData(JSON.stringify(message));
      }
      updateLastHeartbeat() {
        this.lastHeartbeatResponse = Date.now();
      }
      heartbeat() {
        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
          this.ws.disconnect();
          return;
        }
        try {
          this.ws.sendData("h");
        } catch (_a2) {
        }
      }
      makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
        const reqId = message.id;
        try {
          this.sendData(message);
        } catch (err) {
          return (0, rxjs_1.throwError)(err);
        }
        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout2, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)((m5) => m5.id === reqId), (0, operators_1.take)(1));
      }
      authenticate() {
        const msg = (0, ClientMessage_1.ClientMessageHostSession)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId,
          sessionKey: this.sessionKey
        });
        return this.makeRequest(msg).pipe((0, operators_1.map)((res) => {
          if ((0, ServerMessage_1.isServerMessageFail)(res)) {
            throw new Error(res.error || "failed to authentcate");
          }
        }));
      }
      sendIsLinked() {
        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
      sendGetSessionConfig() {
        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
          id: (0, types_1.IntNumber)(this.nextReqId++),
          sessionId: this.sessionId
        });
        this.sendData(msg);
      }
    };
    exports.WalletSDKConnection = WalletSDKConnection;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js
var require_aes256gcm = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/aes256gcm.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = void 0;
    var util_1 = require_util2();
    async function encrypt2(plainText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      const ivBytes = crypto.getRandomValues(new Uint8Array(12));
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const enc = new TextEncoder();
      const encryptedResult = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBytes
      }, secretKey, enc.encode(plainText));
      const tagLength = 16;
      const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
      const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
      const authTagBytes = new Uint8Array(authTag);
      const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
      const concatted = new Uint8Array([
        ...ivBytes,
        ...authTagBytes,
        ...encryptedPlaintextBytes
      ]);
      return (0, util_1.uint8ArrayToHex)(concatted);
    }
    exports.encrypt = encrypt2;
    function decrypt3(cipherText, secret) {
      if (secret.length !== 64)
        throw Error(`secret must be 256 bits`);
      return new Promise((resolve, reject) => {
        void async function() {
          const secretKey = await crypto.subtle.importKey("raw", (0, util_1.hexStringToUint8Array)(secret), { name: "aes-gcm" }, false, ["encrypt", "decrypt"]);
          const encrypted = (0, util_1.hexStringToUint8Array)(cipherText);
          const ivBytes = encrypted.slice(0, 12);
          const authTagBytes = encrypted.slice(12, 28);
          const encryptedPlaintextBytes = encrypted.slice(28);
          const concattedBytes = new Uint8Array([
            ...encryptedPlaintextBytes,
            ...authTagBytes
          ]);
          const algo = {
            name: "AES-GCM",
            iv: new Uint8Array(ivBytes)
          };
          try {
            const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
            const decoder = new TextDecoder();
            resolve(decoder.decode(decrypted));
          } catch (err) {
            reject(err);
          }
        }();
      });
    }
    exports.decrypt = decrypt3;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js
var require_RelayMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/RelayMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelayMessageType = void 0;
    var RelayMessageType;
    (function(RelayMessageType2) {
      RelayMessageType2["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
      RelayMessageType2["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
      RelayMessageType2["LINKED"] = "LINKED";
      RelayMessageType2["UNLINKED"] = "UNLINKED";
      RelayMessageType2["WEB3_REQUEST"] = "WEB3_REQUEST";
      RelayMessageType2["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
      RelayMessageType2["WEB3_RESPONSE"] = "WEB3_RESPONSE";
    })(RelayMessageType = exports.RelayMessageType || (exports.RelayMessageType = {}));
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js
var require_Web3RequestCanceledMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestCanceledMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestCanceledMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestCanceledMessage(id2) {
      return { type: RelayMessage_1.RelayMessageType.WEB3_REQUEST_CANCELED, id: id2 };
    }
    exports.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js
var require_Web3RequestMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3RequestMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Web3RequestMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3RequestMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_REQUEST }, params);
    }
    exports.Web3RequestMessage = Web3RequestMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js
var require_Web3ResponseMessage = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/Web3ResponseMessage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isWeb3ResponseMessage = exports.Web3ResponseMessage = void 0;
    var RelayMessage_1 = require_RelayMessage();
    function Web3ResponseMessage(params) {
      return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
    }
    exports.Web3ResponseMessage = Web3ResponseMessage;
    function isWeb3ResponseMessage(msg) {
      return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
    }
    exports.isWeb3ResponseMessage = isWeb3ResponseMessage;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js
var require_WalletSDKRelay = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelay.js"(exports) {
    "use strict";
    var __createBinding3 = exports && exports.__createBinding || (Object.create ? function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      Object.defineProperty(o3, k22, { enumerable: true, get: function() {
        return m5[k5];
      } });
    } : function(o3, m5, k5, k22) {
      if (k22 === void 0)
        k22 = k5;
      o3[k22] = m5[k5];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o3, v5) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v5 });
    } : function(o3, v5) {
      o3["default"] = v5;
    });
    var __decorate37 = exports && exports.__decorate || function(decorators, target, key2, desc) {
      var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r5 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i4 = decorators.length - 1; i4 >= 0; i4--)
          if (d4 = decorators[i4])
            r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
      return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
    };
    var __importStar3 = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k5 in mod)
          if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
            __createBinding3(result, mod, k5);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    var __importDefault3 = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelay = void 0;
    var bind_decorator_1 = __importDefault3(require_bind_decorator());
    var rxjs_1 = (init_esm5(), __toCommonJS(esm5_exports));
    var operators_1 = (init_operators(), __toCommonJS(operators_exports));
    var DiagnosticLogger_1 = require_DiagnosticLogger();
    var WalletSDKConnection_1 = require_WalletSDKConnection();
    var errors_1 = require_errors2();
    var types_1 = require_types3();
    var util_1 = require_util2();
    var aes256gcm = __importStar3(require_aes256gcm());
    var Session_1 = require_Session();
    var WalletSDKRelayAbstract_1 = require_WalletSDKRelayAbstract();
    var Web3Method_1 = require_Web3Method();
    var Web3RequestCanceledMessage_1 = require_Web3RequestCanceledMessage();
    var Web3RequestMessage_1 = require_Web3RequestMessage();
    var Web3Response_1 = require_Web3Response();
    var Web3ResponseMessage_1 = require_Web3ResponseMessage();
    var WalletSDKRelay = class _WalletSDKRelay extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {
      constructor(options) {
        var _a2;
        super();
        this.accountsCallback = null;
        this.chainCallback = null;
        this.dappDefaultChainSubject = new rxjs_1.BehaviorSubject(1);
        this.dappDefaultChain = 1;
        this.appName = "";
        this.appLogoUrl = null;
        this.subscriptions = new rxjs_1.Subscription();
        this.linkAPIUrl = options.linkAPIUrl;
        this.storage = options.storage;
        this.options = options;
        const { session, ui, connection } = this.subscribe();
        this._session = session;
        this.connection = connection;
        this.relayEventManager = options.relayEventManager;
        if (options.diagnosticLogger && options.eventListener) {
          throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        }
        if (options.eventListener) {
          this.diagnostic = {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            log: options.eventListener.onEvent
          };
        } else {
          this.diagnostic = options.diagnosticLogger;
        }
        this._reloadOnDisconnect = (_a2 = options.reloadOnDisconnect) !== null && _a2 !== void 0 ? _a2 : true;
        this.ui = ui;
      }
      subscribe() {
        this.subscriptions.add(this.dappDefaultChainSubject.subscribe((chainId) => {
          if (this.dappDefaultChain !== chainId) {
            this.dappDefaultChain = chainId;
          }
        }));
        const session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();
        const connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);
        this.subscriptions.add(connection.sessionConfig$.subscribe({
          next: (sessionConfig) => {
            this.onSessionConfigChanged(sessionConfig);
          },
          error: () => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "error while invoking session config callback"
            });
          }
        }));
        this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)((m5) => m5.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
        this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
          var _a2;
          this.isLinked = linked;
          const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
          if (linked) {
            this.session.linked = linked;
          }
          this.isUnlinkedErrorState = false;
          if (cachedAddresses) {
            const addresses = cachedAddresses.split(" ");
            const wasConnectedViaStandalone = this.storage.getItem("IsStandaloneSigning") === "true";
            if (addresses[0] !== "" && !linked && this.session.linked && !wasConnectedViaStandalone) {
              this.isUnlinkedErrorState = true;
              const sessionIdHash = this.getSessionIdHash();
              (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {
                sessionIdHash
              });
            }
          }
        })).subscribe());
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => !!c5.metadata && c5.metadata.__destroyed === "1")).subscribe(() => {
          var _a2;
          const alreadyDestroyed = connection.isDestroyed;
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {
            alreadyDestroyed,
            sessionIdHash: this.getSessionIdHash()
          });
          return this.resetAndReload();
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.WalletUsername, session.secret))).subscribe({
          next: (walletUsername) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
          },
          error: () => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "username"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.AppVersion, session.secret))).subscribe({
          next: (appVersion) => {
            this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);
          },
          error: () => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appversion"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.ChainId !== void 0 && c5.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c5) => (0, rxjs_1.zip)(aes256gcm.decrypt(c5.metadata.ChainId, session.secret), aes256gcm.decrypt(c5.metadata.JsonRpcUrl, session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
          next: ([chainId, jsonRpcUrl]) => {
            if (this.chainCallback) {
              this.chainCallback(chainId, jsonRpcUrl);
            }
          },
          error: () => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "chainId|jsonRpcUrl"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.EthereumAddress, session.secret))).subscribe({
          next: (selectedAddress) => {
            if (this.accountsCallback) {
              this.accountsCallback([selectedAddress]);
            }
            if (_WalletSDKRelay.accountRequestCallbackIds.size > 0) {
              Array.from(_WalletSDKRelay.accountRequestCallbackIds.values()).forEach((id2) => {
                const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
                  id: id2,
                  response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                    selectedAddress
                  ])
                });
                this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 }));
              });
              _WalletSDKRelay.accountRequestCallbackIds.clear();
            }
          },
          error: () => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "selectedAddress"
            });
          }
        }));
        this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)((c5) => c5.metadata && c5.metadata.AppSrc !== void 0)).pipe((0, operators_1.mergeMap)((c5) => aes256gcm.decrypt(c5.metadata.AppSrc, session.secret))).subscribe({
          next: (appSrc) => {
            this.ui.setAppSrc(appSrc);
          },
          error: () => {
            var _a2;
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error decrypting",
              value: "appSrc"
            });
          }
        }));
        const ui = this.options.uiConstructor({
          linkAPIUrl: this.options.linkAPIUrl,
          version: this.options.version,
          darkMode: this.options.darkMode,
          session,
          connected$: connection.connected$,
          chainId$: this.dappDefaultChainSubject
        });
        connection.connect();
        return { session, ui, connection };
      }
      attachUI() {
        this.ui.attach();
      }
      resetAndReload() {
        this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_6) => (0, rxjs_1.of)(null))).subscribe((_6) => {
          var _a2, _b, _c;
          const isStandalone = this.ui.isStandalone();
          try {
            this.subscriptions.unsubscribe();
          } catch (err) {
            (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
              message: "Had error unsubscribing"
            });
          }
          (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {
            method: "relay::resetAndReload",
            sessionMetadataChange: "__destroyed, 1",
            sessionIdHash: this.getSessionIdHash()
          });
          this.connection.destroy();
          const storedSession = Session_1.Session.load(this.storage);
          if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {
            this.storage.clear();
          } else if (storedSession) {
            (_c = this.diagnostic) === null || _c === void 0 ? void 0 : _c.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: Session_1.Session.hash(storedSession.id)
            });
          }
          if (this._reloadOnDisconnect) {
            this.ui.reloadUI();
            return;
          }
          if (this.accountsCallback) {
            this.accountsCallback([], true);
          }
          this.subscriptions = new rxjs_1.Subscription();
          const { session, ui, connection } = this.subscribe();
          this._session = session;
          this.connection = connection;
          this.ui = ui;
          if (isStandalone && this.ui.setStandalone)
            this.ui.setStandalone(true);
          this.attachUI();
        }, (err) => {
          var _a2;
          (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.FAILURE, {
            method: "relay::resetAndReload",
            message: `failed to reset and reload with ${err}`,
            sessionIdHash: this.getSessionIdHash()
          });
        });
      }
      setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
      }
      getStorageItem(key2) {
        return this.storage.getItem(key2);
      }
      get session() {
        return this._session;
      }
      setStorageItem(key2, value) {
        this.storage.setItem(key2, value);
      }
      signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            address,
            addPrefix,
            typedDataJson: typedDataJson || null
          }
        });
      }
      ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
          params: {
            message: (0, util_1.hexStringFromBuffer)(message, true),
            signature: (0, util_1.hexStringFromBuffer)(signature2, true),
            addPrefix
          }
        });
      }
      signEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: false
          }
        });
      }
      signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.signEthereumTransaction,
          params: {
            fromAddress: params.fromAddress,
            toAddress: params.toAddress,
            weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),
            data: (0, util_1.hexStringFromBuffer)(params.data, true),
            nonce: params.nonce,
            gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,
            maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,
            maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
            gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,
            chainId: params.chainId,
            shouldSubmit: true
          }
        });
      }
      submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.submitEthereumTransaction,
          params: {
            signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),
            chainId
          }
        });
      }
      scanQRCode(regExp) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.scanQRCode,
          params: { regExp }
        });
      }
      getQRCodeUrl() {
        return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);
      }
      genericRequest(data3, action) {
        return this.sendRequest({
          method: Web3Method_1.Web3Method.generic,
          params: {
            action,
            data: data3
          }
        });
      }
      sendGenericMessage(request) {
        return this.sendRequest(request);
      }
      sendRequest(request) {
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          if (!this.ui.isStandalone()) {
            hideSnackbarItem = this.ui.showConnecting({
              isUnlinkedErrorState: this.isUnlinkedErrorState,
              onCancel: cancel,
              onResetConnection: this.resetAndReload
              // eslint-disable-line @typescript-eslint/unbound-method
            });
          }
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          if (this.ui.isStandalone()) {
            this.sendRequestStandalone(id2, request);
          } else {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
      }
      setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
      }
      setChainCallback(chainCallback) {
        this.chainCallback = chainCallback;
      }
      setDappDefaultChainCallback(chainId) {
        this.dappDefaultChainSubject.next(chainId);
      }
      publishWeb3RequestEvent(id2, request) {
        var _a2;
        const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id: id2, request });
        const storedSession = Session_1.Session.load(this.storage);
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {
          eventId: message.id,
          method: `relay::${message.request.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
        });
        this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
          next: (_6) => {
            var _a3;
            (_a3 = this.diagnostic) === null || _a3 === void 0 ? void 0 : _a3.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {
              eventId: message.id,
              method: `relay::${message.request.method}`,
              sessionIdHash: this.getSessionIdHash(),
              storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : "",
              isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()
            });
          },
          error: (err) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: message.id,
              response: {
                method: message.request.method,
                errorMessage: err.message
              }
            }));
          }
        }));
      }
      publishWeb3RequestCanceledEvent(id2) {
        const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id2);
        this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
      }
      publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
          void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
            subscriber.next(encrypted);
            subscriber.complete();
          });
        }).pipe((0, operators_1.mergeMap)((encrypted) => {
          return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
      }
      handleIncomingEvent(event) {
        try {
          this.subscriptions.add((0, rxjs_1.from)(aes256gcm.decrypt(event.data, this.session.secret)).pipe((0, operators_1.map)((c5) => JSON.parse(c5))).subscribe({
            next: (json) => {
              const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;
              if (!message) {
                return;
              }
              this.handleWeb3ResponseMessage(message);
            },
            error: () => {
              var _a2;
              (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {
                message: "Had error decrypting",
                value: "incomingEvent"
              });
            }
          }));
        } catch (_a2) {
          return;
        }
      }
      handleWeb3ResponseMessage(message) {
        var _a2;
        const { response } = message;
        (_a2 = this.diagnostic) === null || _a2 === void 0 ? void 0 : _a2.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {
          eventId: message.id,
          method: `relay::${response.method}`,
          sessionIdHash: this.getSessionIdHash()
        });
        if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
          _WalletSDKRelay.accountRequestCallbackIds.forEach((id2) => this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 })));
          _WalletSDKRelay.accountRequestCallbackIds.clear();
          return;
        }
        this.invokeCallback(message);
      }
      handleErrorResponse(id2, method, error, errorCode) {
        var _a2;
        const errorMessage = (_a2 = error === null || error === void 0 ? void 0 : error.message) !== null && _a2 !== void 0 ? _a2 : (0, errors_1.standardErrorMessage)(errorCode);
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: {
            method,
            errorMessage,
            errorCode
          }
        }));
      }
      invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
          callback(message.response);
          this.relayEventManager.callbacks.delete(message.id);
        }
      }
      requestEthereumAccounts() {
        const request = {
          method: Web3Method_1.Web3Method.requestEthereumAccounts,
          params: {
            appName: this.appName,
            appLogoUrl: this.appLogoUrl || null
          }
        };
        const hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        const promise = new Promise((resolve, reject) => {
          var _a2;
          this.relayEventManager.callbacks.set(id2, (response) => {
            this.ui.hideRequestEthereumAccounts();
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const userAgent = ((_a2 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) || null;
          if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
            let location2;
            try {
              if ((0, util_1.isInIFrame)() && window.top) {
                location2 = window.top.location;
              } else {
                location2 = window.location;
              }
            } catch (e3) {
              location2 = window.location;
            }
            location2.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(location2.href)}`;
            return;
          }
          if (this.ui.inlineAccountsResponse()) {
            const onAccounts = (accounts) => {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
              }));
            };
            this.ui.requestEthereumAccounts({
              onCancel: cancel,
              onAccounts
            });
          } else {
            const err = errors_1.standardErrors.provider.userRejectedRequest("User denied account authorization");
            this.ui.requestEthereumAccounts({
              onCancel: () => cancel(err)
            });
          }
          _WalletSDKRelay.accountRequestCallbackIds.add(id2);
          if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      selectProvider(providerOptions) {
        const request = {
          method: Web3Method_1.Web3Method.selectProvider,
          params: {
            providerOptions
          }
        };
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
        };
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)
            }));
          };
          const approve = (selectedProviderKey) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)
            }));
          };
          if (this.ui.selectProvider)
            this.ui.selectProvider({
              onApprove: approve,
              onCancel: _cancel,
              providerOptions
            });
        });
        return { cancel, promise };
      }
      watchAsset(type2, address, symbol, decimals, image, chainId) {
        const request = {
          method: Web3Method_1.Web3Method.watchAsset,
          params: {
            type: type2,
            options: {
              address,
              symbol,
              decimals,
              image
            },
            chainId
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineWatchAsset()) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
            // eslint-disable-line @typescript-eslint/unbound-method
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.WatchAssetReponse)(false)
            }));
          };
          const approve = () => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.WatchAssetReponse)(true)
            }));
          };
          if (this.ui.inlineWatchAsset()) {
            this.ui.watchAsset({
              onApprove: approve,
              onCancel: _cancel,
              type: type2,
              address,
              symbol,
              decimals,
              image,
              chainId
            });
          }
          if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { cancel, promise };
      }
      addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
        const request = {
          method: Web3Method_1.Web3Method.addEthereumChain,
          params: {
            chainId,
            rpcUrls,
            blockExplorerUrls,
            chainName,
            iconUrls,
            nativeCurrency
          }
        };
        let hideSnackbarItem = null;
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
          hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        };
        if (!this.ui.inlineAddEthereumChain(chainId)) {
          hideSnackbarItem = this.ui.showConnecting({
            isUnlinkedErrorState: this.isUnlinkedErrorState,
            onCancel: cancel,
            onResetConnection: this.resetAndReload
            // eslint-disable-line @typescript-eslint/unbound-method
          });
        }
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (_error) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.AddEthereumChainResponse)({
                isApproved: false,
                rpcUrl: ""
              })
            }));
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
            }));
          };
          if (this.ui.inlineAddEthereumChain(chainId)) {
            this.ui.addEthereumChain({
              onCancel: _cancel,
              onApprove: approve,
              chainId: request.params.chainId,
              rpcUrls: request.params.rpcUrls,
              blockExplorerUrls: request.params.blockExplorerUrls,
              chainName: request.params.chainName,
              iconUrls: request.params.iconUrls,
              nativeCurrency: request.params.nativeCurrency
            });
          }
          if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      switchEthereumChain(chainId, address) {
        const request = {
          method: Web3Method_1.Web3Method.switchEthereumChain,
          params: Object.assign({ chainId }, { address })
        };
        const id2 = (0, util_1.randomBytesHex)(8);
        const cancel = (error) => {
          this.publishWeb3RequestCanceledEvent(id2);
          this.handleErrorResponse(id2, request.method, error);
        };
        const promise = new Promise((resolve, reject) => {
          this.relayEventManager.callbacks.set(id2, (response) => {
            if ((0, Web3Response_1.isErrorResponse)(response) && response.errorCode) {
              return reject(errors_1.standardErrors.provider.custom({
                code: response.errorCode,
                message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
              }));
            } else if (response.errorMessage) {
              return reject(new Error(response.errorMessage));
            }
            resolve(response);
          });
          const _cancel = (error) => {
            var _a2;
            if (error) {
              const errorCode = (_a2 = (0, errors_1.getErrorCode)(error)) !== null && _a2 !== void 0 ? _a2 : errors_1.standardErrorCodes.provider.unsupportedChain;
              this.handleErrorResponse(id2, Web3Method_1.Web3Method.switchEthereumChain, error instanceof Error ? error : errors_1.standardErrors.provider.unsupportedChain(chainId), errorCode);
            } else {
              this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
                id: id2,
                response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                  isApproved: false,
                  rpcUrl: ""
                })
              }));
            }
          };
          const approve = (rpcUrl) => {
            this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.SwitchEthereumChainResponse)({
                isApproved: true,
                rpcUrl
              })
            }));
          };
          this.ui.switchEthereumChain({
            onCancel: _cancel,
            onApprove: approve,
            chainId: request.params.chainId,
            address: request.params.address
          });
          if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
            this.publishWeb3RequestEvent(id2, request);
          }
        });
        return { promise, cancel };
      }
      inlineAddEthereumChain(chainId) {
        return this.ui.inlineAddEthereumChain(chainId);
      }
      getSessionIdHash() {
        return Session_1.Session.hash(this._session.id);
      }
      sendRequestStandalone(id2, request) {
        const _cancel = (error) => {
          this.handleErrorResponse(id2, request.method, error);
        };
        const onSuccess = (response) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response
          }));
        };
        switch (request.method) {
          case Web3Method_1.Web3Method.signEthereumMessage:
            this.ui.signEthereumMessage({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.signEthereumTransaction:
            this.ui.signEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.submitEthereumTransaction:
            this.ui.submitEthereumTransaction({
              request,
              onSuccess,
              onCancel: _cancel
            });
            break;
          case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
            this.ui.ethereumAddressFromSignedMessage({
              request,
              onSuccess
            });
            break;
          default:
            _cancel();
            break;
        }
      }
      onSessionConfigChanged(_nextSessionConfig) {
      }
    };
    WalletSDKRelay.accountRequestCallbackIds = /* @__PURE__ */ new Set();
    __decorate37([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "resetAndReload", null);
    __decorate37([
      bind_decorator_1.default
    ], WalletSDKRelay.prototype, "handleIncomingEvent", null);
    exports.WalletSDKRelay = WalletSDKRelay;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js
var require_WalletSDKRelayEventManager = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/relay/WalletSDKRelayEventManager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletSDKRelayEventManager = void 0;
    var util_1 = require_util2();
    var WalletSDKRelayEventManager = class {
      constructor() {
        this._nextRequestId = 0;
        this.callbacks = /* @__PURE__ */ new Map();
      }
      makeRequestId() {
        this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
        const id2 = this._nextRequestId;
        const idStr = (0, util_1.prepend0x)(id2.toString(16));
        const callback = this.callbacks.get(idStr);
        if (callback) {
          this.callbacks.delete(idStr);
        }
        return id2;
      }
    };
    exports.WalletSDKRelayEventManager = WalletSDKRelayEventManager;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js
var require_CoinbaseWalletSDK = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/CoinbaseWalletSDK.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletSDK = void 0;
    var wallet_logo_1 = require_wallet_logo();
    var constants_1 = require_constants4();
    var ScopedLocalStorage_1 = require_ScopedLocalStorage();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var WalletSDKUI_1 = require_WalletSDKUI();
    var WalletSDKRelay_1 = require_WalletSDKRelay();
    var WalletSDKRelayEventManager_1 = require_WalletSDKRelayEventManager();
    var util_1 = require_util2();
    var version_1 = require_version();
    var CoinbaseWalletSDK2 = class _CoinbaseWalletSDK {
      /**
       * Constructor
       * @param options Coinbase Wallet SDK constructor options
       */
      constructor(options) {
        var _a2, _b, _c;
        this._appName = "";
        this._appLogoUrl = null;
        this._relay = null;
        this._relayEventManager = null;
        const linkAPIUrl = options.linkAPIUrl || constants_1.LINK_API_URL;
        let uiConstructor;
        if (!options.uiConstructor) {
          uiConstructor = (opts) => new WalletSDKUI_1.WalletSDKUI(opts);
        } else {
          uiConstructor = options.uiConstructor;
        }
        if (typeof options.overrideIsMetaMask === "undefined") {
          this._overrideIsMetaMask = false;
        } else {
          this._overrideIsMetaMask = options.overrideIsMetaMask;
        }
        this._overrideIsCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
        this._overrideIsCoinbaseBrowser = (_b = options.overrideIsCoinbaseBrowser) !== null && _b !== void 0 ? _b : false;
        if (options.diagnosticLogger && options.eventListener) {
          throw new Error("Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger");
        }
        if (options.eventListener) {
          this._diagnosticLogger = {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            log: options.eventListener.onEvent
          };
        } else {
          this._diagnosticLogger = options.diagnosticLogger;
        }
        this._reloadOnDisconnect = (_c = options.reloadOnDisconnect) !== null && _c !== void 0 ? _c : true;
        const url = new URL(linkAPIUrl);
        const origin = `${url.protocol}//${url.host}`;
        this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${origin}`);
        this._storage.setItem("version", _CoinbaseWalletSDK.VERSION);
        if (this.walletExtension || this.coinbaseBrowser) {
          return;
        }
        this._relayEventManager = new WalletSDKRelayEventManager_1.WalletSDKRelayEventManager();
        this._relay = new WalletSDKRelay_1.WalletSDKRelay({
          linkAPIUrl,
          version: version_1.LIB_VERSION,
          darkMode: !!options.darkMode,
          uiConstructor,
          storage: this._storage,
          relayEventManager: this._relayEventManager,
          diagnosticLogger: this._diagnosticLogger,
          reloadOnDisconnect: this._reloadOnDisconnect
        });
        this.setAppInfo(options.appName, options.appLogoUrl);
        if (!!options.headlessMode)
          return;
        this._relay.attachUI();
      }
      /**
       * Create a Web3 Provider object
       * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
       * @param chainId Ethereum Chain ID (Default: 1)
       * @returns A Web3 Provider
       */
      makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setProviderInfo(jsonRpcUrl, chainId);
          }
          if (this._reloadOnDisconnect === false && typeof extension.disableReloadOnDisconnect === "function")
            extension.disableReloadOnDisconnect();
          return extension;
        }
        const dappBrowser = this.coinbaseBrowser;
        if (dappBrowser) {
          return dappBrowser;
        }
        const relay = this._relay;
        if (!relay || !this._relayEventManager || !this._storage) {
          throw new Error("Relay not initialized, should never happen");
        }
        if (!jsonRpcUrl)
          relay.setConnectDisabled(true);
        return new CoinbaseWalletProvider_1.CoinbaseWalletProvider({
          relayProvider: () => Promise.resolve(relay),
          relayEventManager: this._relayEventManager,
          storage: this._storage,
          jsonRpcUrl,
          chainId,
          qrUrl: this.getQrUrl(),
          diagnosticLogger: this._diagnosticLogger,
          overrideIsMetaMask: this._overrideIsMetaMask,
          overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
          overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
        });
      }
      /**
       * Set application information
       * @param appName Application name
       * @param appLogoUrl Application logo image URL
       */
      setAppInfo(appName, appLogoUrl) {
        var _a2;
        this._appName = appName || "DApp";
        this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
        const extension = this.walletExtension;
        if (extension) {
          if (!this.isCipherProvider(extension)) {
            extension.setAppInfo(this._appName, this._appLogoUrl);
          }
        } else {
          (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.setAppInfo(this._appName, this._appLogoUrl);
        }
      }
      /**
       * Disconnect. After disconnecting, this will reload the web page to ensure
       * all potential stale state is cleared.
       */
      disconnect() {
        var _a2;
        const extension = this.walletExtension;
        if (extension) {
          void extension.close();
        } else {
          (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.resetAndReload();
        }
      }
      /**
       * Return QR URL for mobile wallet connection, will return null if extension is installed
       */
      getQrUrl() {
        var _a2, _b;
        return (_b = (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.getQRCodeUrl()) !== null && _b !== void 0 ? _b : null;
      }
      /**
       * Official Coinbase Wallet logo for developers to use on their frontend
       * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
       * @param width Width of the logo (Optional)
       * @returns SVG Data URI
       */
      getCoinbaseWalletLogo(type2, width = 240) {
        return (0, wallet_logo_1.walletLogo)(type2, width);
      }
      get walletExtension() {
        var _a2;
        return (_a2 = window.coinbaseWalletExtension) !== null && _a2 !== void 0 ? _a2 : window.walletLinkExtension;
      }
      get coinbaseBrowser() {
        var _a2, _b;
        try {
          const ethereum = (_a2 = window.ethereum) !== null && _a2 !== void 0 ? _a2 : (_b = window.top) === null || _b === void 0 ? void 0 : _b.ethereum;
          if (!ethereum) {
            return void 0;
          }
          if ("isCoinbaseBrowser" in ethereum && ethereum.isCoinbaseBrowser) {
            return ethereum;
          } else {
            return void 0;
          }
        } catch (e3) {
          return void 0;
        }
      }
      isCipherProvider(provider) {
        return typeof provider.isCipher === "boolean" && provider.isCipher;
      }
    };
    exports.CoinbaseWalletSDK = CoinbaseWalletSDK2;
    CoinbaseWalletSDK2.VERSION = version_1.LIB_VERSION;
  }
});

// node_modules/@coinbase/wallet-sdk/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@coinbase/wallet-sdk/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CoinbaseWalletProvider = exports.CoinbaseWalletSDK = void 0;
    var CoinbaseWalletSDK_1 = require_CoinbaseWalletSDK();
    var CoinbaseWalletProvider_1 = require_CoinbaseWalletProvider();
    var CoinbaseWalletSDK_2 = require_CoinbaseWalletSDK();
    Object.defineProperty(exports, "CoinbaseWalletSDK", { enumerable: true, get: function() {
      return CoinbaseWalletSDK_2.CoinbaseWalletSDK;
    } });
    var CoinbaseWalletProvider_2 = require_CoinbaseWalletProvider();
    Object.defineProperty(exports, "CoinbaseWalletProvider", { enumerable: true, get: function() {
      return CoinbaseWalletProvider_2.CoinbaseWalletProvider;
    } });
    exports.default = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
    if (typeof window !== "undefined") {
      window.CoinbaseWalletSDK = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.CoinbaseWalletProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
      window.WalletLink = CoinbaseWalletSDK_1.CoinbaseWalletSDK;
      window.WalletLinkProvider = CoinbaseWalletProvider_1.CoinbaseWalletProvider;
    }
  }
});

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-account-button/index.js
var __decorate = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mAccountButton = class W3mAccountButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.disabled = false;
    this.balance = "show";
    this.address = AccountController.state.address;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = NetworkController.state.caipNetwork;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          this.address = val.address;
          this.balanceVal = val.balance;
          this.profileName = val.profileName;
          this.profileImage = val.profileImage;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          this.address = "";
          this.balanceVal = "";
          this.profileName = "";
          this.profileImage = "";
          this.balanceSymbol = "";
        }
      }),
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    const networkImage = this.networkImages[((_a2 = this.network) == null ? void 0 : _a2.imageId) ?? ""];
    const showBalance = this.balance === "show";
    return html`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        address=${ifDefined(this.profileName ?? this.address)}
        ?isProfileName=${Boolean(this.profileName)}
        networkSrc=${ifDefined(networkImage)}
        avatarSrc=${ifDefined(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    ModalController.open();
  }
};
__decorate([
  property({ type: Boolean })
], W3mAccountButton.prototype, "disabled", void 0);
__decorate([
  property()
], W3mAccountButton.prototype, "balance", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "address", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "profileName", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "profileImage", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "network", void 0);
W3mAccountButton = __decorate([
  customElement("w3m-account-button")
], W3mAccountButton);

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-button/index.js
var __decorate2 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mButton = class W3mButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.isAccount = AccountController.state.isConnected;
    this.unsubscribe.push(AccountController.subscribeKey("isConnected", (val) => {
      this.isAccount = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.isAccount ? html`
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${ifDefined(this.balance)}
          >
          </w3m-account-button>
        ` : html`
          <w3m-connect-button
            size=${ifDefined(this.size)}
            label=${ifDefined(this.label)}
            loadingLabel=${ifDefined(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
__decorate2([
  property({ type: Boolean })
], W3mButton.prototype, "disabled", void 0);
__decorate2([
  property()
], W3mButton.prototype, "balance", void 0);
__decorate2([
  property()
], W3mButton.prototype, "size", void 0);
__decorate2([
  property()
], W3mButton.prototype, "label", void 0);
__decorate2([
  property()
], W3mButton.prototype, "loadingLabel", void 0);
__decorate2([
  state()
], W3mButton.prototype, "isAccount", void 0);
W3mButton = __decorate2([
  customElement("w3m-button")
], W3mButton);

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-connect-button/index.js
var __decorate3 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectButton = class W3mConnectButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.unsubscribe.push(ModalController.subscribeKey("open", (val) => this.open = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-connect-button
        size=${ifDefined(this.size)}
        .loading=${this.open}
        @click=${this.onClick.bind(this)}
      >
        ${this.open ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else {
      ModalController.open();
    }
  }
};
__decorate3([
  property()
], W3mConnectButton.prototype, "size", void 0);
__decorate3([
  property()
], W3mConnectButton.prototype, "label", void 0);
__decorate3([
  property()
], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate3([
  state()
], W3mConnectButton.prototype, "open", void 0);
W3mConnectButton = __decorate3([
  customElement("w3m-connect-button")
], W3mConnectButton);

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-network-button/index.js
var __decorate4 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mNetworkButton = class W3mNetworkButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = NetworkController.state.caipNetwork;
    this.connected = AccountController.state.isConnected;
    this.unsubscribe.push(...[
      NetworkController.subscribeKey("caipNetwork", (val) => this.network = val),
      AccountController.subscribeKey("isConnected", (val) => this.connected = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2;
    return html`
      <wui-network-button
        .disabled=${Boolean(this.disabled)}
        imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.network))}
        @click=${this.onClick.bind(this)}
      >
        ${((_a2 = this.network) == null ? void 0 : _a2.name) ?? (this.connected ? "Unknown Network" : "Select Network")}
      </wui-network-button>
    `;
  }
  onClick() {
    ModalController.open({ view: "Networks" });
  }
};
__decorate4([
  property({ type: Boolean })
], W3mNetworkButton.prototype, "disabled", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "network", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "connected", void 0);
W3mNetworkButton = __decorate4([
  customElement("w3m-network-button")
], W3mNetworkButton);

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-router/styles.js
var styles_default = css`
  :host {
    display: block;
    will-change: transform, opacity;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/modal/w3m-router/index.js
var __decorate5 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mRouter = class W3mRouter2 extends LitElement {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(async ([content]) => {
      const height = `${content == null ? void 0 : content.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        await this.animate([{ height: this.prevHeight }, { height }], {
          duration: 150,
          easing: "ease",
          fill: "forwards"
        }).finished;
        this.style.height = "auto";
      }
      this.prevHeight = height;
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    var _a2;
    (_a2 = this.resizeObserver) == null ? void 0 : _a2.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`<div>${this.viewTemplate()}</div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "Connect":
        return html`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return html`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return html`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return html`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "AllWallets":
        return html`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "Networks":
        return html`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return html`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Account":
        return html`<w3m-account-view></w3m-account-view>`;
      case "WhatIsAWallet":
        return html`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "WhatIsANetwork":
        return html`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "GetWallet":
        return html`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Downloads":
        return html`<w3m-downloads-view></w3m-downloads-view>`;
      case "Transactions":
        return html`<w3m-transactions-view></w3m-transactions-view>`;
      default:
        return html`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  async onViewChange(newView) {
    const { history } = RouterController.state;
    let xOut = -10;
    let xIn = 10;
    if (history.length < this.prevHistoryLength) {
      xOut = 10;
      xIn = -10;
    }
    this.prevHistoryLength = history.length;
    await this.animate([
      { opacity: 1, transform: "translateX(0px)" },
      { opacity: 0, transform: `translateX(${xOut}px)` }
    ], { duration: 150, easing: "ease", fill: "forwards" }).finished;
    this.view = newView;
    await this.animate([
      { opacity: 0, transform: `translateX(${xIn}px)` },
      { opacity: 1, transform: "translateX(0px)" }
    ], { duration: 150, easing: "ease", fill: "forwards", delay: 50 }).finished;
  }
  getWrapper() {
    var _a2;
    return (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("div");
  }
};
W3mRouter.styles = styles_default;
__decorate5([
  state()
], W3mRouter.prototype, "view", void 0);
W3mRouter = __decorate5([
  customElement("w3m-router")
], W3mRouter);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-account-view/styles.js
var styles_default2 = css`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-account-view/index.js
var __decorate6 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mAccountView = class W3mAccountView2 extends LitElement {
  constructor() {
    super();
    this.usubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.network = NetworkController.state.caipNetwork;
    this.disconecting = false;
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.balance = val.balance;
          this.balanceSymbol = val.balanceSymbol;
        } else {
          ModalController.close();
        }
      })
    ], NetworkController.subscribeKey("caipNetwork", (val) => {
      if (val == null ? void 0 : val.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a2, _b;
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = this.networkImages[((_a2 = this.network) == null ? void 0 : _a2.imageId) ?? ""];
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["0", "s", "m", "s"]}
        alignItems="center"
        gap="l"
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${ifDefined(this.profileImage)}
        ></wui-avatar>

        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="large-600" color="fg-100">
              ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
          <wui-flex gap="s" flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-200">
              ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
            </wui-text>

            ${this.explorerBtnTemplate()}
          </wui-flex>
        </wui-flex>
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        <wui-list-item
          .variant=${networkImage ? "image" : "icon"}
          iconVariant="overlay"
          icon="networkPlaceholder"
          imageSrc=${ifDefined(networkImage)}
          ?chevron=${this.isAllowedNetworkSwitch()}
          @click=${this.onNetworks.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">
            ${((_b = this.network) == null ? void 0 : _b.name) ?? "Unknown"}
          </wui-text>
        </wui-list-item>
        <wui-list-item
          iconVariant="blue"
          icon="swapHorizontalBold"
          iconSize="sm"
          ?chevron=${true}
          @click=${this.onTransactions.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-100">Activity</wui-text>
        </wui-list-item>
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconecting}
          @click=${this.onDisconnect.bind(this)}
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>
    `;
  }
  explorerBtnTemplate() {
    const { addressExplorerUrl } = AccountController.state;
    if (!addressExplorerUrl) {
      return null;
    }
    return html`
      <wui-button size="sm" variant="shade" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  isAllowedNetworkSwitch() {
    const { requestedCaipNetworks } = NetworkController.state;
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id: id2 }) => {
      var _a2;
      return id2 === ((_a2 = this.network) == null ? void 0 : _a2.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  onTransactions() {
    EventsController.sendEvent({ type: "track", event: "CLICK_TRANSACTIONS" });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  onExplorer() {
    const { addressExplorerUrl } = AccountController.state;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
};
W3mAccountView.styles = styles_default2;
__decorate6([
  state()
], W3mAccountView.prototype, "address", void 0);
__decorate6([
  state()
], W3mAccountView.prototype, "profileImage", void 0);
__decorate6([
  state()
], W3mAccountView.prototype, "profileName", void 0);
__decorate6([
  state()
], W3mAccountView.prototype, "balance", void 0);
__decorate6([
  state()
], W3mAccountView.prototype, "balanceSymbol", void 0);
__decorate6([
  state()
], W3mAccountView.prototype, "network", void 0);
__decorate6([
  state()
], W3mAccountView.prototype, "disconecting", void 0);
W3mAccountView = __decorate6([
  customElement("w3m-account-view")
], W3mAccountView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-all-wallets-view/index.js
var __decorate7 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mAllWalletsView = class W3mAllWalletsView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return html`
      <wui-flex padding="s" gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch ? html`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : html`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return html`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate7([
  state()
], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate7([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-connect-view/styles.js
var styles_default3 = css`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-connect-view/index.js
var __decorate8 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectView = class W3mConnectView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.walletConnectConnectorTemplate()} ${this.recentTemplate()}
        ${this.announcedTemplate()} ${this.injectedTemplate()} ${this.featuredTemplate()}
        ${this.customTemplate()} ${this.recommendedTemplate()} ${this.connectorsTemplate()}
        ${this.allWalletsTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletConnectConnectorTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return null;
    }
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    return html`
      <wui-list-wallet
        imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
      >
      </wui-list-wallet>
    `;
  }
  customTemplate() {
    const { customWallets } = OptionsController.state;
    if (!(customWallets == null ? void 0 : customWallets.length)) {
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    return wallets.map((wallet) => html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  featuredTemplate() {
    const { featured } = ApiController.state;
    if (!featured.length) {
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(featured);
    return wallets.map((wallet) => html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  recentTemplate() {
    const recent = StorageUtil.getRecentWallets();
    return recent.map((wallet) => html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          name=${wallet.name ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
          tagLabel="recent"
          tagVariant="shade"
        >
        </wui-list-wallet>
      `);
  }
  announcedTemplate() {
    return this.connectors.map((connector) => {
      if (connector.type !== "ANNOUNCED") {
        return null;
      }
      return html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
          tagLabel="installed"
          tagVariant="success"
        >
        </wui-list-wallet>
      `;
    });
  }
  injectedTemplate() {
    const announced = this.connectors.find((c5) => c5.type === "ANNOUNCED");
    return this.connectors.map((connector) => {
      if (connector.type !== "INJECTED") {
        return null;
      }
      if (!ConnectionController.checkInstalled()) {
        return null;
      }
      return html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
          tagLabel=${ifDefined(announced ? void 0 : "installed")}
          tagVariant=${ifDefined(announced ? void 0 : "success")}
        >
        </wui-list-wallet>
      `;
    });
  }
  connectorsTemplate() {
    return this.connectors.map((connector) => {
      if (["WALLET_CONNECT", "INJECTED", "ANNOUNCED"].includes(connector.type)) {
        return null;
      }
      return html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
          name=${connector.name ?? "Unknown"}
          @click=${() => this.onConnector(connector)}
        >
        </wui-list-wallet>
      `;
    });
  }
  allWalletsTemplate() {
    const roundedCount = Math.floor(ApiController.state.count / 10) * 10;
    return html`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${`${roundedCount}+`}
        tagVariant="shade"
      ></wui-list-wallet>
    `;
  }
  recommendedTemplate() {
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const eip6963 = connectors.filter((c5) => c5.type === "ANNOUNCED");
    if (featuredWalletIds || customWallets || !recommended.length) {
      return null;
    }
    const overrideLength = eip6963.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = this.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    return wallets.map((wallet) => html`
        <wui-list-wallet
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          name=${(wallet == null ? void 0 : wallet.name) ?? "Unknown"}
          @click=${() => this.onConnectWallet(wallet)}
        >
        </wui-list-wallet>
      `);
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
  filterOutDuplicateWallets(wallets) {
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const recentIds = recent.map((wallet) => wallet.id);
    const rdnsIds = connectors.map((c5) => {
      var _a2;
      return (_a2 = c5.info) == null ? void 0 : _a2.rdns;
    }).filter(Boolean);
    const filtered = wallets.filter((wallet) => !recentIds.includes(wallet.id) && !rdnsIds.includes(wallet.rdns ?? void 0));
    return filtered;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
W3mConnectView.styles = styles_default3;
__decorate8([
  state()
], W3mConnectView.prototype, "connectors", void 0);
W3mConnectView = __decorate8([
  customElement("w3m-connect-view")
], W3mConnectView);

// node_modules/@web3modal/scaffold/dist/esm/src/utils/w3m-connecting-widget/styles.js
var styles_default4 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/utils/w3m-connecting-widget/index.js
var __decorate9 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWidget = class extends LitElement {
  constructor() {
    var _a2, _b, _c, _d;
    super();
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
    this.connector = (_b = RouterController.state.data) == null ? void 0 : _b.connector;
    this.timeout = void 0;
    this.secondaryBtnLabel = "Try again";
    this.secondaryBtnIcon = "refresh";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = ((_c = this.wallet) == null ? void 0 : _c.name) ?? ((_d = this.connector) == null ? void 0 : _d.name) ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        var _a3;
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          (_a3 = this.onConnect) == null ? void 0 : _a3.call(this);
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
  }
  firstUpdated() {
    var _a2;
    (_a2 = this.onAutoConnect) == null ? void 0 : _a2.call(this);
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    var _a2;
    (_a2 = this.onRender) == null ? void 0 : _a2.call(this);
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${ifDefined(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? html`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="sm" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy Link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    var _a2;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-button");
      retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    var _a2, _b;
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        (_a2 = this.onRetry) == null ? void 0 : _a2.call(this);
      } else {
        (_b = this.onConnect) == null ? void 0 : _b.call(this);
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingWidget.styles = styles_default4;
__decorate9([
  state()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate9([
  state()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate9([
  state()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate9([
  state()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate9([
  state()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate9([
  property({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate9([
  property()
], W3mConnectingWidget.prototype, "onRetry", void 0);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-connecting-external-view/index.js
var __decorate10 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var platformMap = {
  INJECTED: "browser",
  ANNOUNCED: "browser"
};
var W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: platformMap[this.connector.type] ?? "external"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.imageUrl) {
          StorageUtil.setConnectedWalletImageUrl(this.connector.imageUrl);
        }
        await ConnectionController.connectExternal(this.connector);
        ModalController.close();
        EventsController.sendEvent({
          type: "track",
          event: "CONNECT_SUCCESS",
          properties: { method: "external" }
        });
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate10([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-connecting-siwe-view/index.js
var __decorate11 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingSiweView = class W3mConnectingSiweView2 extends LitElement {
  constructor() {
    var _a2, _b;
    super(...arguments);
    this.dappUrl = (_a2 = OptionsController.state.metadata) == null ? void 0 : _a2.url;
    this.dappName = (_b = OptionsController.state.metadata) == null ? void 0 : _b.name;
  }
  render() {
    return html`
      <wui-flex justifyContent="center" .padding=${["2xl", "0", "xxl", "0"]}>
        <w3m-connecting-siwe></w3m-connecting-siwe>
      </wui-flex>
      <wui-flex
        .padding=${["0", "4xl", "l", "4xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100"
          >${this.dappName ?? "Dapp"} wants to connect to your wallet</wui-text
        >
      </wui-flex>
      ${this.urlTemplate()}
      <wui-flex
        .padding=${["0", "3xl", "l", "3xl"]}
        gap="s"
        justifyContent="space-between"
      >
        <wui-text variant="small-400" align="center" color="fg-200"
          >Sign this message to prove you own this wallet and to continue</wui-text
        >
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button size="md" ?fullwidth=${true} variant="shade" @click=${this.onCancel.bind(this)}>
          Cancel
        </wui-button>
        <wui-button size="md" ?fullwidth=${true} variant="fill" @click=${this.onSign.bind(this)}>
          Sign
        </wui-button>
      </wui-flex>
    `;
  }
  urlTemplate() {
    if (this.dappUrl) {
      return html`<wui-flex .padding=${["0", "0", "l", "0"]} justifyContent="center">
        <wui-button size="sm" variant="accentBg" @click=${this.onDappLink.bind(this)}>
          ${this.dappUrl}
          <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>`;
    }
    return null;
  }
  onDappLink() {
    if (this.dappUrl) {
      CoreHelperUtil.openHref(this.dappUrl, "_blank");
    }
  }
  onSign() {
  }
  onCancel() {
    RouterController.goBack();
  }
};
W3mConnectingSiweView = __decorate11([
  customElement("w3m-connecting-siwe-view")
], W3mConnectingSiweView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-connecting-wc-view/index.js
var __decorate12 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcView = class W3mConnectingWcView2 extends LitElement {
  constructor() {
    var _a2;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return html`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    this.determinePlatforms();
    return html`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry2 = false) {
    try {
      const { wcPairingExpiry } = ConnectionController.state;
      if (retry2 || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
        ConnectionController.connectWalletConnect();
        if (this.wallet) {
          const url = AssetUtil.getWalletImage(this.wallet);
          if (url) {
            StorageUtil.setConnectedWalletImageUrl(url);
          }
        } else {
          const connectors = ConnectorController.state.connectors;
          const connector = connectors.find((c5) => c5.type === "WALLET_CONNECT");
          const url = AssetUtil.getConnectorImage(connector);
          if (url) {
            StorageUtil.setConnectedWalletImageUrl(url);
          }
        }
        await ConnectionController.state.wcPromise;
        this.finalizeConnection();
        ModalController.close();
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError("Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      }
    }
  }
  finalizeConnection() {
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setWeb3ModalRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
    const injectedIds = injected == null ? void 0 : injected.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = rdns ? [rdns] : injectedIds ?? [];
    const isBrowser = browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return html`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return html`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return html`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return html`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return html`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return html`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return html`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    var _a2;
    const container = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate12([
  state()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate12([
  state()
], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate12([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-downloads-view/index.js
var __decorate13 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mDownloadsView = class W3mDownloadsView2 extends LitElement {
  constructor() {
    var _a2;
    super(...arguments);
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return html`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.chrome_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.app_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.play_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    var _a2;
    if (!((_a2 = this.wallet) == null ? void 0 : _a2.homepage)) {
      return null;
    }
    return html`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate13([
  customElement("w3m-downloads-view")
], W3mDownloadsView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-get-wallet-view/index.js
var __decorate14 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var EXPLORER = "https://walletconnect.com/explorer";
var W3mGetWalletView = class W3mGetWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => html`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate14([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-network-switch-view/styles.js
var styles_default5 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-network-switch-view/index.js
var __decorate15 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends LitElement {
  constructor() {
    var _a2;
    super();
    this.network = (_a2 = RouterController.state.data) == null ? void 0 : _a2.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
    this.currentNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", (val) => {
      var _a3;
      if ((val == null ? void 0 : val.id) !== ((_a3 = this.currentNetwork) == null ? void 0 : _a3.id)) {
        RouterController.goBack();
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.error ? "Switch declined" : "Approve in wallet";
    const subLabel = this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
    return html`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : html`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="fill"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  onShowRetry() {
    var _a2;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-button");
      retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await NetworkController.switchActiveNetwork(this.network);
        RouterController.goBack();
      }
    } catch {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles_default5;
__decorate15([
  state()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate15([
  state()
], W3mNetworkSwitchView.prototype, "error", void 0);
__decorate15([
  state()
], W3mNetworkSwitchView.prototype, "currentNetwork", void 0);
W3mNetworkSwitchView = __decorate15([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-networks-view/index.js
var __decorate16 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mNetworksView = class W3mNetworksView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.caipNetwork = NetworkController.state.caipNetwork;
    this.unsubscribe.push(NetworkController.subscribeKey("caipNetwork", (val) => this.caipNetwork = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-grid padding="s" gridTemplateColumns="repeat(4, 1fr)" rowGap="l" columnGap="xs">
        ${this.networksTemplate()}
      </wui-grid>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-500" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    const { approvedCaipNetworkIds, requestedCaipNetworks, supportsAllNetworks } = NetworkController.state;
    const approvedIds = approvedCaipNetworkIds;
    const requested = requestedCaipNetworks;
    if (approvedIds == null ? void 0 : approvedIds.length) {
      requested == null ? void 0 : requested.sort((a4, b6) => approvedIds.indexOf(b6.id) - approvedIds.indexOf(a4.id));
    }
    return requested == null ? void 0 : requested.map((network) => {
      var _a2;
      return html`
        <wui-card-select
          .selected=${((_a2 = this.caipNetwork) == null ? void 0 : _a2.id) === network.id}
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${!supportsAllNetworks && !(approvedIds == null ? void 0 : approvedIds.includes(network.id))}
        ></wui-card-select>
      `;
    });
  }
  async onSwitchNetwork(network) {
    const { isConnected } = AccountController.state;
    const { approvedCaipNetworkIds, supportsAllNetworks, caipNetwork } = NetworkController.state;
    if (isConnected && (caipNetwork == null ? void 0 : caipNetwork.id) !== network.id) {
      if (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { network });
      }
    } else if (!isConnected) {
      NetworkController.setCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
__decorate16([
  state()
], W3mNetworksView.prototype, "caipNetwork", void 0);
W3mNetworksView = __decorate16([
  customElement("w3m-networks-view")
], W3mNetworksView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-transactions-view/styles.js
var styles_default6 = css`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-transactions-view/index.js
var __decorate17 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var PAGINATOR_ID = "last-transaction";
var LOADING_ITEM_COUNT = 7;
var W3mTransactionsView = class W3mTransactionsView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.address = AccountController.state.address;
    this.transactions = TransactionsController.state.transactions;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.isConnected) {
          if (this.address !== val.address) {
            this.address = val.address;
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val.address);
          }
        }
      }),
      TransactionsController.subscribe((val) => {
        this.transactions = val.transactions;
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    if (this.transactions.length === 0) {
      TransactionsController.fetchTransactions(this.address);
    }
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" padding="s" gap="s">
        ${this.empty ? null : this.templateTransactionsByYear()}
        ${this.loading ? this.templateLoading() : null}
        ${!this.loading && this.empty ? this.templateEmpty() : null}
      </wui-flex>
    `;
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year, index) => {
      const isLastGroup = index === sortedYearKeys.length - 1;
      const yearInt = parseInt(year, 10);
      const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt);
      const transactions = this.transactionsByYear[yearInt];
      if (!transactions) {
        return null;
      }
      return html`
        <wui-flex flexDirection="column" gap="sm">
          <wui-flex
            alignItems="center"
            flexDirection="row"
            .padding=${["xs", "s", "s", "s"]}
          >
            <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
          </wui-flex>
          <wui-flex flexDirection="column" gap="xs">
            ${this.templateTransactions(transactions, isLastGroup)}
          </wui-flex>
        </wui-flex>
      `;
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date: date2, descriptions, direction, isAllNFT, images, status, transfers, type: type2 } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return html`
        <wui-transaction-list-item
          date=${date2}
          direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type2}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index === transfers.length - 1;
        return html` <wui-transaction-list-item
          date=${date2}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID : ""}
          status=${status}
          type=${type2}
          onlyDirectionIcon=${true}
          .images=${[images == null ? void 0 : images[index]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
      });
    }
    return html`
      <wui-transaction-list-item
        date=${date2}
        direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID : ""}
        status=${status}
        type=${type2}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index) => {
      const isLastTransaction = isLastGroup && index === transactions.length - 1;
      return html`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  templateEmpty() {
    return html`
      <wui-flex
        flexGrow="1"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-icon-box
          backgroundColor="glass-005"
          background="gray"
          iconColor="fg-200"
          icon="wallet"
          size="lg"
          ?border=${true}
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >No Transactions yet</wui-text
          >
          <wui-text align="center" variant="small-500" color="fg-200"
            >Start trading on dApps <br />
            to grow your wallet!</wui-text
          >
        </wui-flex>
      </wui-flex>
    `;
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT).fill(html` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
  createPaginationObserver() {
    const { projectId } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if ((element == null ? void 0 : element.isIntersecting) && !this.loading) {
        TransactionsController.fetchTransactions(this.address);
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: this.address,
            projectId,
            cursor: this.next
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    var _a2, _b, _c;
    (_a2 = this.paginationObserver) == null ? void 0 : _a2.disconnect();
    const lastItem = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector(`#${PAGINATOR_ID}`);
    if (lastItem) {
      (_c = this.paginationObserver) == null ? void 0 : _c.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    var _a2, _b, _c, _d, _e4;
    const date2 = DateUtil.getRelativeDateFromNow((_a2 = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a2.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const transfer = (_b = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b[0];
    const isAllNFT = Boolean(transfer) && ((_c = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c.every((item) => Boolean(item.nft_info)));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date: date2,
      direction: transfer == null ? void 0 : transfer.direction,
      descriptions,
      isAllNFT,
      images,
      status: (_d = transaction.metadata) == null ? void 0 : _d.status,
      transfers,
      type: (_e4 = transaction.metadata) == null ? void 0 : _e4.operationType
    };
  }
};
W3mTransactionsView.styles = styles_default6;
__decorate17([
  state()
], W3mTransactionsView.prototype, "address", void 0);
__decorate17([
  state()
], W3mTransactionsView.prototype, "transactions", void 0);
__decorate17([
  state()
], W3mTransactionsView.prototype, "transactionsByYear", void 0);
__decorate17([
  state()
], W3mTransactionsView.prototype, "loading", void 0);
__decorate17([
  state()
], W3mTransactionsView.prototype, "empty", void 0);
__decorate17([
  state()
], W3mTransactionsView.prototype, "next", void 0);
W3mTransactionsView = __decorate17([
  customElement("w3m-transactions-view")
], W3mTransactionsView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-what-is-a-network-view/index.js
var __decorate18 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var data = [
  {
    images: ["network", "layers", "system"],
    title: "The system’s nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
var W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button
          variant="fill"
          size="sm"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate18([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);

// node_modules/@web3modal/scaffold/dist/esm/src/views/w3m-what-is-a-wallet-view/index.js
var __decorate19 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var data2 = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
var W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data2}></w3m-help-widget>
        <wui-button variant="fill" size="sm" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a Wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate19([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-all-wallets-list/styles.js
var styles_default7 = css`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-all-wallets-list/index.js
var __decorate20 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var PAGINATOR_ID2 = "local-paginator";
var W3mAllWalletsList = class W3mAllWalletsList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    var _a2;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a2 = this.paginationObserver) == null ? void 0 : _a2.disconnect();
  }
  render() {
    return html`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    var _a2;
    const gridEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id2) {
    return [...Array(items)].map(() => html`
        <wui-card-select-loader type="wallet" id=${ifDefined(id2)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    return wallets.map((wallet) => html`
        <wui-card-select
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          type="wallet"
          name=${wallet.name}
          @click=${() => this.onConnectWallet(wallet)}
        ></wui-card-select>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count: count2 } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count2 === 0 || [...featured, ...wallets, ...recommended].length < count2) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID2);
    }
    return null;
  }
  createPaginationObserver() {
    var _a2;
    const loaderEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector(`#${PAGINATOR_ID2}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if ((element == null ? void 0 : element.isIntersecting) && !this.initial) {
          const { page, count: count2, wallets } = ApiController.state;
          if (wallets.length < count2) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const { connectors } = ConnectorController.state;
    const connector = connectors.find(({ explorerId }) => explorerId === wallet.id);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles_default7;
__decorate20([
  state()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate20([
  state()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate20([
  state()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate20([
  state()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate20([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-all-wallets-search/styles.js
var styles_default8 = css`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-all-wallets-search/index.js
var __decorate21 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends LitElement {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? html`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query !== this.prevQuery) {
      this.prevQuery = this.query;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    if (!search.length) {
      return html`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return html`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${search.map((wallet) => html`
            <wui-card-select
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              type="wallet"
              name=${wallet.name}
              @click=${() => this.onConnectWallet(wallet)}
            ></wui-card-select>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const { connectors } = ConnectorController.state;
    const connector = connectors.find(({ explorerId }) => explorerId === wallet.id);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles_default8;
__decorate21([
  state()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate21([
  property()
], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate21([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-header/index.js
var __decorate22 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingHeader = class W3mConnectingHeader2 extends LitElement {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return html`
      <wui-flex justifyContent="center" .padding=${["l", "0", "0", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index) {
    var _a2;
    const tab = this.platformTabs[index];
    if (tab) {
      (_a2 = this.onSelectPlatfrom) == null ? void 0 : _a2.call(this, tab);
    }
  }
};
__decorate22([
  property({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate22([
  property()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate22([
  state()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate22([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-browser/index.js
var __decorate23 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const announcedConnector = connectors.find((c5) => {
        var _a2, _b;
        return c5.type === "ANNOUNCED" && ((_a2 = c5.info) == null ? void 0 : _a2.rdns) === ((_b = this.wallet) == null ? void 0 : _b.rdns);
      });
      const injectedConnector = connectors.find((c5) => c5.type === "INJECTED");
      if (announcedConnector) {
        await ConnectionController.connectExternal(announcedConnector);
      } else if (injectedConnector) {
        await ConnectionController.connectExternal(injectedConnector);
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate23([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-desktop/index.js
var __decorate24 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.ready = true;
      this.timeout = setTimeout(() => {
        var _a2;
        (_a2 = this.onConnect) == null ? void 0 : _a2.call(this);
      }, 200);
    }
  }
  onConnectProxy() {
    var _a2;
    if (((_a2 = this.wallet) == null ? void 0 : _a2.desktop_link) && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate24([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-mobile/index.js
var __decorate25 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    var _a2;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a2 = this.onConnect) == null ? void 0 : _a2.call(this);
    }
  }
  onConnectProxy() {
    var _a2;
    if (((_a2 = this.wallet) == null ? void 0 : _a2.mobile_link) && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if ((document == null ? void 0 : document.visibilityState) === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate25([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-qrcode/styles.js
var styles_default9 = css`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-qrcode/index.js
var __decorate26 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    var _a2;
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((_a2 = this.wallet) == null ? void 0 : _a2.name) ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return html`
      <wui-flex padding="xl" flexDirection="column" gap="xl" alignItems="center">
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>

        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="sm" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy Link
        </wui-link>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size2 = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return html`<wui-qr-code
      size=${size2}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${ifDefined(AssetUtil.getWalletImage(this.wallet))}
      alt=${ifDefined(alt)}
    ></wui-qr-code>`;
  }
};
W3mConnectingWcQrcode.styles = styles_default9;
W3mConnectingWcQrcode = __decorate26([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-siwe/styles.js
var styles_default10 = css`
  :host {
    display: flex;
    justify-content: center;
    gap: var(--wui-spacing-2xl);
  }

  wui-visual-thumbnail:nth-child(1) {
    z-index: 1;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-siwe/index.js
var __decorate27 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingSiwe = class W3mConnectingSiwe2 extends LitElement {
  constructor() {
    var _a2;
    super(...arguments);
    this.dappImageUrl = (_a2 = OptionsController.state.metadata) == null ? void 0 : _a2.icons;
    this.walletImageUrl = StorageUtil.getConnectedWalletImageUrl();
  }
  firstUpdated() {
    var _a2;
    const visuals = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelectorAll("wui-visual-thumbnail");
    if (visuals == null ? void 0 : visuals[0]) {
      this.createAnimation(visuals[0], "translate(18px)");
    }
    if (visuals == null ? void 0 : visuals[1]) {
      this.createAnimation(visuals[1], "translate(-18px)");
    }
  }
  render() {
    var _a2;
    return html`
      <wui-visual-thumbnail
        ?borderRadiusFull=${true}
        .imageSrc=${(_a2 = this.dappImageUrl) == null ? void 0 : _a2[0]}
      ></wui-visual-thumbnail>
      <wui-visual-thumbnail .imageSrc=${this.walletImageUrl}></wui-visual-thumbnail>
    `;
  }
  createAnimation(element, translation) {
    element.animate([{ transform: "translateX(0px)" }, { transform: translation }], {
      duration: 1600,
      easing: "cubic-bezier(0.56, 0, 0.48, 1)",
      direction: "alternate",
      iterations: Infinity
    });
  }
};
W3mConnectingSiwe.styles = styles_default10;
W3mConnectingSiwe = __decorate27([
  customElement("w3m-connecting-siwe")
], W3mConnectingSiwe);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-unsupported/index.js
var __decorate28 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends LitElement {
  constructor() {
    var _a2;
    super();
    this.wallet = (_a2 = RouterController.state.data) == null ? void 0 : _a2.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${ifDefined(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate28([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-connecting-wc-web/index.js
var __decorate29 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    var _a2;
    if (((_a2 = this.wallet) == null ? void 0 : _a2.webapp_link) && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name: name2 } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name: name2, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate29([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-header/styles.js
var styles_default11 = css`
  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-header/index.js
var __decorate30 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
function headings() {
  var _a2, _b, _c, _d, _e4, _f;
  const connectorName = (_b = (_a2 = RouterController.state.data) == null ? void 0 : _a2.connector) == null ? void 0 : _b.name;
  const walletName = (_d = (_c = RouterController.state.data) == null ? void 0 : _c.wallet) == null ? void 0 : _d.name;
  const networkName = (_f = (_e4 = RouterController.state.data) == null ? void 0 : _e4.network) == null ? void 0 : _f.name;
  const name2 = walletName ?? connectorName;
  return {
    Connect: "Connect Wallet",
    Account: void 0,
    ConnectingExternal: name2 ?? "Connect Wallet",
    ConnectingWalletConnect: name2 ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Networks: "Choose Network",
    SwitchNetwork: networkName ?? "Switch Network",
    AllWallets: "All Wallets",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    GetWallet: "Get a Wallet",
    Downloads: name2 ? `Get ${name2}` : "Downloads",
    Transactions: "Activity"
  };
}
var W3mHeader = class W3mHeader2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.buffering = false;
    this.showBack = false;
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      this.onViewChange(val);
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()}
        <wui-icon-link
          ?disabled=${this.buffering}
          icon="close"
          @click=${ModalController.close}
        ></wui-icon-link>
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  titleTemplate() {
    return html`<wui-text variant="paragraph-700" color="fg-100">${this.heading}</wui-text>`;
  }
  dynamicButtonTemplate() {
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    if (this.showBack) {
      return html`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${RouterController.goBack}
      ></wui-icon-link>`;
    }
    return html`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  separatorTemplate() {
    if (!this.heading) {
      return null;
    }
    return html`<wui-separator></wui-separator>`;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["l", "2l", "0", "2l"];
  }
  async onViewChange(view) {
    var _a2;
    const headingEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("wui-text");
    if (headingEl) {
      const preset = headings()[view];
      await headingEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.heading = preset;
      headingEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onHistoryChange() {
    var _a2;
    const { history } = RouterController.state;
    const buttonEl = (_a2 = this.shadowRoot) == null ? void 0 : _a2.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mHeader.styles = [styles_default11];
__decorate30([
  state()
], W3mHeader.prototype, "heading", void 0);
__decorate30([
  state()
], W3mHeader.prototype, "buffering", void 0);
__decorate30([
  state()
], W3mHeader.prototype, "showBack", void 0);
W3mHeader = __decorate30([
  customElement("w3m-header")
], W3mHeader);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-help-widget/index.js
var __decorate31 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mHelpWidget = class W3mHelpWidget2 extends LitElement {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => html`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => html`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate31([
  property({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate31([
  customElement("w3m-help-widget")
], W3mHelpWidget);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-legal-footer/styles.js
var styles_default12 = css`
  wui-flex {
    background-color: var(--wui-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 600;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-legal-footer/index.js
var __decorate32 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mLegalFooter = class W3mLegalFooter2 extends LitElement {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return html`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-500" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return html`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return html`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles_default12];
W3mLegalFooter = __decorate32([
  customElement("w3m-legal-footer")
], W3mLegalFooter);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-mobile-download-links/styles.js
var styles_default13 = css`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-mobile-download-links/index.js
var __decorate33 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends LitElement {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name: name2, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name2,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a2;
    if ((_a2 = this.wallet) == null ? void 0 : _a2.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles_default13];
__decorate33([
  property({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate33([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-snackbar/styles.js
var styles_default14 = css`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
  }
`;

// node_modules/@web3modal/scaffold/dist/esm/src/partials/w3m-snackbar/index.js
var __decorate34 = function(decorators, target, key2, desc) {
  var c5 = arguments.length, r5 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r5 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i4 = decorators.length - 1; i4 >= 0; i4--)
      if (d4 = decorators[i4])
        r5 = (c5 < 3 ? d4(r5) : c5 > 3 ? d4(target, key2, r5) : d4(target, key2)) || r5;
  return c5 > 3 && r5 && Object.defineProperty(target, key2, r5), r5;
};
var presets = {
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
var W3mSnackBar = class W3mSnackBar2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = SnackController.state;
    const preset = presets[variant];
    return html`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset.backgroundColor}
        iconColor=${preset.iconColor}
        icon=${preset.icon}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles_default14;
__decorate34([
  state()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate34([
  customElement("w3m-snackbar")
], W3mSnackBar);

// node_modules/@web3modal/scaffold/dist/esm/src/client.js
var isInitialized = false;
var Web3ModalScaffold = class {
  constructor(options) {
    this.initPromise = void 0;
    this.setIsConnected = (isConnected) => {
      AccountController.setIsConnected(isConnected);
    };
    this.setCaipAddress = (caipAddress) => {
      AccountController.setCaipAddress(caipAddress);
    };
    this.setBalance = (balance, balanceSymbol) => {
      AccountController.setBalance(balance, balanceSymbol);
    };
    this.setProfileName = (profileName) => {
      AccountController.setProfileName(profileName);
    };
    this.setProfileImage = (profileImage) => {
      AccountController.setProfileImage(profileImage);
    };
    this.resetAccount = () => {
      AccountController.resetAccount();
    };
    this.setCaipNetwork = (caipNetwork) => {
      NetworkController.setCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = () => NetworkController.state.caipNetwork;
    this.setRequestedCaipNetworks = (requestedCaipNetworks) => {
      NetworkController.setRequestedCaipNetworks(requestedCaipNetworks);
    };
    this.getApprovedCaipNetworksData = () => NetworkController.getApprovedCaipNetworksData();
    this.resetNetwork = () => {
      NetworkController.resetNetwork();
    };
    this.setConnectors = (connectors) => {
      ConnectorController.setConnectors(connectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.setAddressExplorerUrl = (addressExplorerUrl) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl);
    };
    this.setSIWENonce = (nonce) => {
      SIWEController.setNonce(nonce);
    };
    this.setSIWESession = (session) => {
      SIWEController.setSession(session);
    };
    this.setSIWEStatus = (status) => {
      SIWEController.setStatus(status);
    };
    this.setSIWEMessage = (message) => {
      SIWEController.setMessage(message);
    };
    this.getSIWENonce = () => SIWEController.state.nonce;
    this.getSIWESession = () => SIWEController.state.session;
    this.getSIWEStatus = () => SIWEController.state.status;
    this.getSIWEMessage = () => SIWEController.state.message;
    this.initControllers(options);
    this.initOrContinue();
  }
  async open(options) {
    await this.initOrContinue();
    ModalController.open(options);
  }
  async close() {
    await this.initOrContinue();
    ModalController.close();
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getState() {
    return { ...PublicStateController.state };
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  subscribeSIWEState(callback) {
    return SIWEController.subscribe(callback);
  }
  initControllers(options) {
    NetworkController.setClient(options.networkControllerClient);
    NetworkController.setDefaultCaipNetwork(options.defaultChain);
    OptionsController.setProjectId(options.projectId);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setEnableAnalytics(options.enableAnalytics);
    OptionsController.setSdkVersion(options._sdkVersion);
    ConnectionController.setClient(options.connectionControllerClient);
    if (options.siweControllerClient) {
      SIWEController.setSIWEClient(options.siweControllerClient);
    }
    if (options.metadata) {
      OptionsController.setMetadata(options.metadata);
    }
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
  }
  async initOrContinue() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([import("./esm-26P7EGZK.js"), import("./w3m-modal-Q2B2KCOD.js")]);
        const modal = document.createElement("w3m-modal");
        document.body.insertAdjacentElement("beforeend", modal);
        resolve();
      });
    }
    return this.initPromise;
  }
};

// node_modules/@web3modal/utils/dist/esm/src/ConstantsUtil.js
var ConstantsUtil2 = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  VERSION: "3.3.1"
};

// node_modules/@web3modal/utils/dist/esm/src/PresetsUtil.js
var PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil2.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil2.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil2.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  EIP155NetworkImageIds: {
    1: "692ed6ba-e569-459a-556a-776476829e00",
    42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100"
  },
  ConnectorImageIds: {
    [ConstantsUtil2.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil2.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil2.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil2.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil2.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [ConstantsUtil2.COINBASE_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil2.LEDGER_CONNECTOR_ID]: "Ledger",
    [ConstantsUtil2.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil2.INJECTED_CONNECTOR_ID]: "INJECTED",
    [ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [ConstantsUtil2.EIP6963_CONNECTOR_ID]: "ANNOUNCED"
  }
};

// node_modules/@web3modal/utils/dist/esm/src/HelpersUtil.js
var HelpersUtil = {
  caipNetworkIdToNumber(caipnetworkId) {
    return caipnetworkId ? Number(caipnetworkId.split(":")[1]) : void 0;
  },
  getCaipTokens(tokens) {
    if (!tokens) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens).forEach(([id2, token]) => {
      caipTokens[`${ConstantsUtil2.EIP155}:${id2}`] = token;
    });
    return caipTokens;
  }
};

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_events9 = __toESM(require_events());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
var import_hkdf = __toESM(require_hkdf());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var fe = __toESM(require_x25519());

// node_modules/uint8arrays/esm/src/util/as-uint8array.js
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}

// node_modules/uint8arrays/esm/src/alloc.js
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}

// node_modules/uint8arrays/esm/src/concat.js
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output);
}

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});

// node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j7 = 0; j7 < BASE_MAP.length; j7++) {
    BASE_MAP[j7] = 255;
  }
  for (var i4 = 0; i4 < ALPHABET.length; i4++) {
    var x5 = ALPHABET.charAt(i4);
    var xc = x5.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x5 + " is ambiguous");
    }
    BASE_MAP[xc] = i4;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode8(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i5 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i5;
      pbegin++;
    }
    var it22 = size2 - length2;
    while (it22 !== size2 && b58[it22] === 0) {
      it22++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it22 < size2; ++it22) {
      str += ALPHABET.charAt(b58[it22]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i5 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i5 < length2) && it3 !== -1; it3--, i5++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i5;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j8 = zeroes;
    while (it4 !== size2) {
      vch[j8++] = b256[it4++];
    }
    return vch;
  }
  function decode8(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode8,
    decodeUnsafe,
    decode: decode8
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// node_modules/multiformats/esm/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o3) => {
  if (o3 instanceof Uint8Array && o3.constructor.name === "Uint8Array")
    return o3;
  if (o3 instanceof ArrayBuffer)
    return new Uint8Array(o3);
  if (ArrayBuffer.isView(o3)) {
    return new Uint8Array(o3.buffer, o3.byteOffset, o3.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b6) => new TextDecoder().decode(b6);

// node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name2, prefix, encode: encode8, decode: decode8 }) => new Codec(name2, prefix, encode8, decode8);
var baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode8, decode: decode8 } = base_x_default(alphabet2, name2);
  return from({
    prefix,
    name: name2,
    encode: encode8,
    decode: (text) => coerce(decode8(text))
  });
};
var decode = (string3, alphabet2, bitsPerChar, name2) => {
  const codes = {};
  for (let i4 = 0; i4 < alphabet2.length; ++i4) {
    codes[alphabet2[i4]] = i4;
  }
  let end = string3.length;
  while (string3[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i4 = 0; i4 < end; ++i4) {
    const value = codes[string3[i4]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode = (data3, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask2 = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i4 = 0; i4 < data3.length; ++i4) {
    buffer2 = buffer2 << 8 | data3[i4];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask2 & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask2 & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name2,
    encode(input) {
      return encode(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet2, bitsPerChar, name2);
    }
  });
};

// node_modules/multiformats/esm/src/bases/identity.js
var identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString(buf),
  decode: (str) => fromString(str)
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
var alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var alphabetBytesToChars = alphabet.reduce((p6, c5, i4) => {
  p6[i4] = c5;
  return p6;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p6, c5, i4) => {
  p6[c5.codePointAt(0)] = i4;
  return p6;
}, []);
function encode2(data3) {
  return data3.reduce((p6, c5) => {
    p6 += alphabetBytesToChars[c5];
    return p6;
  }, "");
}
function decode2(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "🚀",
  name: "base256emoji",
  encode: encode2,
  decode: decode2
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/multiformats/esm/vendor/varint.js
var encode_1 = encode3;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode3.bytes = offset - oldOffset + 1;
  return out;
}
var decode3 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b6, l4 = buf.length;
  do {
    if (counter >= l4) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b6 = buf[counter++];
    res += shift < 28 ? (b6 & REST$1) << shift : (b6 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b6 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode3,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// node_modules/multiformats/esm/src/varint.js
var decode4 = (data3, offset = 0) => {
  const code2 = varint_default.decode(data3, offset);
  return [
    code2,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// node_modules/multiformats/esm/src/hashes/digest.js
var create = (code2, digest2) => {
  const size2 = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size2);
  const bytes = new Uint8Array(digestOffset + size2);
  encodeTo(code2, bytes, 0);
  encodeTo(size2, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code2, size2, digest2, bytes);
};
var decode5 = (multihash) => {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode4(bytes);
  const [size2, digestOffset] = decode4(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size2) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size2, digest2, bytes);
};
var equals2 = (a4, b6) => {
  if (a4 === b6) {
    return true;
  } else {
    return a4.code === b6.code && a4.size === b6.size && equals(a4.bytes, b6.bytes);
  }
};
var Digest = class {
  constructor(code2, size2, digest2, bytes) {
    this.code = code2;
    this.size = size2;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// node_modules/multiformats/esm/src/hashes/hasher.js
var from2 = ({ name: name2, code: code2, encode: encode8 }) => new Hasher(name2, code2, encode8);
var Hasher = class {
  constructor(name2, code2, encode8) {
    this.name = name2;
    this.code = code2;
    this.encode = encode8;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha = (name2) => async (data3) => new Uint8Array(await crypto.subtle.digest(name2, data3));
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var code = 0;
var name = "identity";
var encode4 = coerce;
var digest = (input) => create(code, encode4(input));
var identity2 = {
  code,
  name,
  encode: encode4,
  digest
};

// node_modules/multiformats/esm/src/codecs/json.js
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// node_modules/multiformats/esm/src/cid.js
var CID = class _CID {
  constructor(version28, code2, multihash, bytes) {
    this.code = code2;
    this.version = version28;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return _CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create(code2, digest2);
        return _CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base4) {
    const { bytes, version: version28, _baseCache } = this;
    switch (version28) {
      case 0:
        return toStringV0(bytes, _baseCache, base4 || base58btc.encoder);
      default:
        return toStringV1(bytes, _baseCache, base4 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof _CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version28, code: code2, multihash, bytes } = value;
      return new _CID(version28, code2, multihash, bytes || encodeCID(version28, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version28, multihash, code: code2 } = value;
      const digest2 = decode5(multihash);
      return _CID.create(version28, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version28, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version28) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new _CID(version28, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version28, code2, digest2.bytes);
        return new _CID(version28, code2, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return _CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return _CID.create(1, code2, digest2);
  }
  static decode(bytes) {
    const [cid, remainder] = _CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = _CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? _CID.createV0(digest2) : _CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i4, length2] = decode4(initialBytes.subarray(offset));
      offset += length2;
      return i4;
    };
    let version28 = next();
    let codec = DAG_PB_CODE;
    if (version28 === 18) {
      version28 = 0;
      offset = 0;
    } else if (version28 === 1) {
      codec = next();
    }
    if (version28 !== 0 && version28 !== 1) {
      throw new RangeError(`Invalid CID version ${version28}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size2 = offset + digestSize;
    const multihashSize = size2 - prefixSize;
    return {
      version: version28,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size: size2
    };
  }
  static parse(source, base4) {
    const [prefix, bytes] = parseCIDtoBytes(source, base4);
    const cid = _CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base4) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base4 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base4 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base4 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base4.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache, base4) => {
  const { prefix } = base4;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache, base4) => {
  const { prefix } = base4;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version28, code2, multihash) => {
  const codeOffset = encodingLength(version28);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version28, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range2, message) => {
  if (range2.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports2
};

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode8, decode8) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode8
    },
    decoder: { decode: decode8 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string3 = "a";
  for (let i4 = 0; i4 < buf.length; i4++) {
    string3 += String.fromCharCode(buf[i4]);
  }
  return string3;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i4 = 0; i4 < str.length; i4++) {
    buf[i4] = str.charCodeAt(i4);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// node_modules/uint8arrays/esm/src/from-string.js
function fromString2(string3, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string3, "utf-8"));
  }
  return base4.decoder.decode(`${base4.prefix}${string3}`);
}

// node_modules/uint8arrays/esm/src/to-string.js
function toString2(array2, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array2.buffer, array2.byteOffset, array2.byteLength).toString("utf8");
  }
  return base4.encoder.encode(array2).substring(1);
}

// node_modules/detect-browser/es/index.js
var __spreadArray = function(to, from4, pack3) {
  if (pack3 || arguments.length === 2)
    for (var i4 = 0, l4 = from4.length, ar2; i4 < l4; i4++) {
      if (ar2 || !(i4 in from4)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from4, 0, i4);
        ar2[i4] = from4[i4];
      }
    }
  return to.concat(ar2 || Array.prototype.slice.call(from4));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name2, version28, os3) {
      this.name = name2;
      this.version = version28;
      this.os = os3;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version28) {
      this.version = version28;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name2, version28, os3, bot) {
      this.name = name2;
      this.version = version28;
      this.os = os3;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version28 = versionParts.join(".");
  var os3 = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version28, os3, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version28, os3);
}
function detectOS(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a2 = operatingSystemRules[ii], os3 = _a2[0], regex = _a2[1];
    var match = regex.exec(ua);
    if (match) {
      return os3;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii = 0; ii < count2; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
var V = __toESM(require_query_string());

// node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js
var RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};

// node_modules/@walletconnect/utils/dist/index.es.js
var M = ":";
function ve(e3) {
  const [n3, t3] = e3.split(M);
  return { namespace: n3, reference: t3 };
}
function Rn(e3, n3 = []) {
  const t3 = [];
  return Object.keys(e3).forEach((r5) => {
    if (n3.length && !n3.includes(r5))
      return;
    const o3 = e3[r5];
    t3.push(...o3.accounts);
  }), t3;
}
function K(e3, n3) {
  return e3.includes(":") ? [e3] : n3.chains || [];
}
var J = "base10";
var p = "base16";
var x = "base64pad";
var F = "utf8";
var Q = 0;
var _ = 1;
var $n = 0;
var Ie = 1;
var Z = 12;
var X = 32;
function jn() {
  const e3 = fe.generateKeyPair();
  return { privateKey: toString2(e3.secretKey, p), publicKey: toString2(e3.publicKey, p) };
}
function Dn() {
  const e3 = (0, import_random.randomBytes)(X);
  return toString2(e3, p);
}
function kn(e3, n3) {
  const t3 = fe.sharedKey(fromString2(e3, p), fromString2(n3, p), true), r5 = new import_hkdf.HKDF(import_sha256.SHA256, t3).expand(X);
  return toString2(r5, p);
}
function Vn(e3) {
  const n3 = (0, import_sha256.hash)(fromString2(e3, p));
  return toString2(n3, p);
}
function Mn(e3) {
  const n3 = (0, import_sha256.hash)(fromString2(e3, F));
  return toString2(n3, p);
}
function Pe(e3) {
  return fromString2(`${e3}`, J);
}
function $(e3) {
  return Number(toString2(e3, J));
}
function Kn(e3) {
  const n3 = Pe(typeof e3.type < "u" ? e3.type : Q);
  if ($(n3) === _ && typeof e3.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t3 = typeof e3.senderPublicKey < "u" ? fromString2(e3.senderPublicKey, p) : void 0, r5 = typeof e3.iv < "u" ? fromString2(e3.iv, p) : (0, import_random.randomBytes)(Z), o3 = new import_chacha20poly1305.ChaCha20Poly1305(fromString2(e3.symKey, p)).seal(r5, fromString2(e3.message, F));
  return Te({ type: n3, sealed: o3, iv: r5, senderPublicKey: t3 });
}
function Ln(e3) {
  const n3 = new import_chacha20poly1305.ChaCha20Poly1305(fromString2(e3.symKey, p)), { sealed: t3, iv: r5 } = ee(e3.encoded), o3 = n3.open(r5, t3);
  if (o3 === null)
    throw new Error("Failed to decrypt");
  return toString2(o3, F);
}
function Te(e3) {
  if ($(e3.type) === _) {
    if (typeof e3.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString2(concat([e3.type, e3.senderPublicKey, e3.iv, e3.sealed]), x);
  }
  return toString2(concat([e3.type, e3.iv, e3.sealed]), x);
}
function ee(e3) {
  const n3 = fromString2(e3, x), t3 = n3.slice($n, Ie), r5 = Ie;
  if ($(t3) === _) {
    const l4 = r5 + X, d4 = l4 + Z, c5 = n3.slice(r5, l4), u5 = n3.slice(l4, d4), a4 = n3.slice(d4);
    return { type: t3, sealed: a4, iv: u5, senderPublicKey: c5 };
  }
  const o3 = r5 + Z, s3 = n3.slice(r5, o3), i4 = n3.slice(o3);
  return { type: t3, sealed: i4, iv: s3 };
}
function xn(e3, n3) {
  const t3 = ee(e3);
  return Re({ type: $(t3.type), senderPublicKey: typeof t3.senderPublicKey < "u" ? toString2(t3.senderPublicKey, p) : void 0, receiverPublicKey: n3 == null ? void 0 : n3.receiverPublicKey });
}
function Re(e3) {
  const n3 = (e3 == null ? void 0 : e3.type) || Q;
  if (n3 === _) {
    if (typeof (e3 == null ? void 0 : e3.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e3 == null ? void 0 : e3.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n3, senderPublicKey: e3 == null ? void 0 : e3.senderPublicKey, receiverPublicKey: e3 == null ? void 0 : e3.receiverPublicKey };
}
function Fn(e3) {
  return e3.type === _ && typeof e3.senderPublicKey == "string" && typeof e3.receiverPublicKey == "string";
}
var Hn = Object.defineProperty;
var Ae = Object.getOwnPropertySymbols;
var qn = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var Ue = (e3, n3, t3) => n3 in e3 ? Hn(e3, n3, { enumerable: true, configurable: true, writable: true, value: t3 }) : e3[n3] = t3;
var _e = (e3, n3) => {
  for (var t3 in n3 || (n3 = {}))
    qn.call(n3, t3) && Ue(e3, t3, n3[t3]);
  if (Ae)
    for (var t3 of Ae(n3))
      Bn.call(n3, t3) && Ue(e3, t3, n3[t3]);
  return e3;
};
var Ce = "ReactNative";
var m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var je = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function j() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === Ce;
}
function q() {
  return !te() && !!(0, import_window_getters.getNavigator)();
}
function R() {
  return j() ? m.reactNative : te() ? m.node : q() ? m.browser : m.unknown;
}
function De(e3, n3) {
  let t3 = V.parse(e3);
  return t3 = _e(_e({}, t3), n3), e3 = V.stringify(t3), e3;
}
function zn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function ke() {
  if (R() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t3, Version: r5 } = global.Platform;
    return [t3, r5].join("-");
  }
  const e3 = detect();
  if (e3 === null)
    return "unknown";
  const n3 = e3.os ? e3.os.replace(" ", "").toLowerCase() : "unknown";
  return e3.type === "browser" ? [n3, e3.name, e3.version].join("-") : [n3, e3.version].join("-");
}
function Ve() {
  var e3;
  const n3 = R();
  return n3 === m.browser ? [n3, ((e3 = (0, import_window_getters.getLocation)()) == null ? void 0 : e3.host) || "unknown"].join(":") : n3;
}
function Me(e3, n3, t3) {
  const r5 = ke(), o3 = Ve();
  return [[e3, n3].join("-"), [je, t3].join("-"), r5, o3].join("/");
}
function Jn({ protocol: e3, version: n3, relayUrl: t3, sdkVersion: r5, auth: o3, projectId: s3, useOnCloseEvent: i4 }) {
  const l4 = t3.split("?"), d4 = Me(e3, n3, r5), c5 = { auth: o3, ua: d4, projectId: s3, useOnCloseEvent: i4 || void 0 }, u5 = De(l4[1] || "", c5);
  return l4[0] + "?" + u5;
}
function O(e3, n3) {
  return e3.filter((t3) => n3.includes(t3)).length === e3.length;
}
function et(e3) {
  return Object.fromEntries(e3.entries());
}
function nt(e3) {
  return new Map(Object.entries(e3));
}
function st(e3 = import_time.FIVE_MINUTES, n3) {
  const t3 = (0, import_time.toMiliseconds)(e3 || import_time.FIVE_MINUTES);
  let r5, o3, s3;
  return { resolve: (i4) => {
    s3 && r5 && (clearTimeout(s3), r5(i4));
  }, reject: (i4) => {
    s3 && o3 && (clearTimeout(s3), o3(i4));
  }, done: () => new Promise((i4, l4) => {
    s3 = setTimeout(() => {
      l4(new Error(n3));
    }, t3), r5 = i4, o3 = l4;
  }) };
}
function it(e3, n3, t3) {
  return new Promise(async (r5, o3) => {
    const s3 = setTimeout(() => o3(new Error(t3)), n3);
    try {
      const i4 = await e3;
      r5(i4);
    } catch (i4) {
      o3(i4);
    }
    clearTimeout(s3);
  });
}
function re(e3, n3) {
  if (typeof n3 == "string" && n3.startsWith(`${e3}:`))
    return n3;
  if (e3.toLowerCase() === "topic") {
    if (typeof n3 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n3}`;
  } else if (e3.toLowerCase() === "id") {
    if (typeof n3 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n3}`;
  }
  throw new Error(`Unknown expirer target type: ${e3}`);
}
function ct(e3) {
  return re("topic", e3);
}
function at(e3) {
  return re("id", e3);
}
function ut(e3) {
  const [n3, t3] = e3.split(":"), r5 = { id: void 0, topic: void 0 };
  if (n3 === "topic" && typeof t3 == "string")
    r5.topic = t3;
  else if (n3 === "id" && Number.isInteger(Number(t3)))
    r5.id = Number(t3);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n3}:${t3}`);
  return r5;
}
function lt(e3, n3) {
  return (0, import_time.fromMiliseconds)((n3 || Date.now()) + (0, import_time.toMiliseconds)(e3));
}
function dt(e3) {
  return Date.now() >= (0, import_time.toMiliseconds)(e3);
}
function ft(e3, n3) {
  return `${e3}${n3 ? `:${n3}` : ""}`;
}
function S(e3 = [], n3 = []) {
  return [.../* @__PURE__ */ new Set([...e3, ...n3])];
}
async function pt({ id: e3, topic: n3, wcDeepLink: t3 }) {
  try {
    if (!t3)
      return;
    const r5 = typeof t3 == "string" ? JSON.parse(t3) : t3;
    let o3 = r5 == null ? void 0 : r5.href;
    if (typeof o3 != "string")
      return;
    o3.endsWith("/") && (o3 = o3.slice(0, -1));
    const s3 = `${o3}/wc?requestId=${e3}&sessionTopic=${n3}`, i4 = R();
    i4 === m.browser ? s3.startsWith("https://") ? window.open(s3, "_blank", "noreferrer noopener") : window.open(s3, "_self", "noreferrer noopener") : i4 === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s3);
  } catch (r5) {
    console.error(r5);
  }
}
var Fe = "irn";
function mt(e3) {
  return (e3 == null ? void 0 : e3.relay) || { protocol: Fe };
}
function yt(e3) {
  const n3 = RELAY_JSONRPC[e3];
  if (typeof n3 > "u")
    throw new Error(`Relay Protocol not supported: ${e3}`);
  return n3;
}
var ht = Object.defineProperty;
var He = Object.getOwnPropertySymbols;
var vt = Object.prototype.hasOwnProperty;
var gt = Object.prototype.propertyIsEnumerable;
var qe = (e3, n3, t3) => n3 in e3 ? ht(e3, n3, { enumerable: true, configurable: true, writable: true, value: t3 }) : e3[n3] = t3;
var Et = (e3, n3) => {
  for (var t3 in n3 || (n3 = {}))
    vt.call(n3, t3) && qe(e3, t3, n3[t3]);
  if (He)
    for (var t3 of He(n3))
      gt.call(n3, t3) && qe(e3, t3, n3[t3]);
  return e3;
};
function Be(e3, n3 = "-") {
  const t3 = {}, r5 = "relay" + n3;
  return Object.keys(e3).forEach((o3) => {
    if (o3.startsWith(r5)) {
      const s3 = o3.replace(r5, ""), i4 = e3[o3];
      t3[s3] = i4;
    }
  }), t3;
}
function bt(e3) {
  const n3 = e3.indexOf(":"), t3 = e3.indexOf("?") !== -1 ? e3.indexOf("?") : void 0, r5 = e3.substring(0, n3), o3 = e3.substring(n3 + 1, t3).split("@"), s3 = typeof t3 < "u" ? e3.substring(t3) : "", i4 = V.parse(s3);
  return { protocol: r5, topic: Ge(o3[0]), version: parseInt(o3[1], 10), symKey: i4.symKey, relay: Be(i4) };
}
function Ge(e3) {
  return e3.startsWith("//") ? e3.substring(2) : e3;
}
function We(e3, n3 = "-") {
  const t3 = "relay", r5 = {};
  return Object.keys(e3).forEach((o3) => {
    const s3 = t3 + n3 + o3;
    e3[o3] && (r5[s3] = e3[o3]);
  }), r5;
}
function Nt(e3) {
  return `${e3.protocol}:${e3.topic}@${e3.version}?` + V.stringify(Et({ symKey: e3.symKey }, We(e3.relay)));
}
function A(e3) {
  const n3 = [];
  return e3.forEach((t3) => {
    const [r5, o3] = t3.split(":");
    n3.push(`${r5}:${o3}`);
  }), n3;
}
function Je(e3) {
  const n3 = [];
  return Object.values(e3).forEach((t3) => {
    n3.push(...A(t3.accounts));
  }), n3;
}
function Qe(e3, n3) {
  const t3 = [];
  return Object.values(e3).forEach((r5) => {
    A(r5.accounts).includes(n3) && t3.push(...r5.methods);
  }), t3;
}
function Ze(e3, n3) {
  const t3 = [];
  return Object.values(e3).forEach((r5) => {
    A(r5.accounts).includes(n3) && t3.push(...r5.events);
  }), t3;
}
function At(e3, n3) {
  const t3 = cn(e3, n3);
  if (t3)
    throw new Error(t3.message);
  const r5 = {};
  for (const [o3, s3] of Object.entries(e3))
    r5[o3] = { methods: s3.methods, events: s3.events, chains: s3.accounts.map((i4) => `${i4.split(":")[0]}:${i4.split(":")[1]}`) };
  return r5;
}
function oe(e3) {
  return e3.includes(":");
}
function Xe(e3) {
  return oe(e3) ? e3.split(":")[0] : e3;
}
var _t = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var Ct = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e3, n3) {
  const { message: t3, code: r5 } = Ct[e3];
  return { message: n3 ? `${t3} ${n3}` : t3, code: r5 };
}
function U(e3, n3) {
  const { message: t3, code: r5 } = _t[e3];
  return { message: n3 ? `${t3} ${n3}` : t3, code: r5 };
}
function D(e3, n3) {
  return Array.isArray(e3) ? typeof n3 < "u" && e3.length ? e3.every(n3) : true : false;
}
function B(e3) {
  return Object.getPrototypeOf(e3) === Object.prototype && Object.keys(e3).length;
}
function w(e3) {
  return typeof e3 > "u";
}
function h(e3, n3) {
  return n3 && w(e3) ? true : typeof e3 == "string" && !!e3.trim().length;
}
function G(e3, n3) {
  return n3 && w(e3) ? true : typeof e3 == "number" && !isNaN(e3);
}
function $t(e3, n3) {
  const { requiredNamespaces: t3 } = n3, r5 = Object.keys(e3.namespaces), o3 = Object.keys(t3);
  let s3 = true;
  return O(o3, r5) ? (r5.forEach((i4) => {
    const { accounts: l4, methods: d4, events: c5 } = e3.namespaces[i4], u5 = A(l4), a4 = t3[i4];
    (!O(K(i4, a4), u5) || !O(a4.methods, d4) || !O(a4.events, c5)) && (s3 = false);
  }), s3) : false;
}
function k(e3) {
  return h(e3, false) && e3.includes(":") ? e3.split(":").length === 2 : false;
}
function en(e3) {
  if (h(e3, false) && e3.includes(":")) {
    const n3 = e3.split(":");
    if (n3.length === 3) {
      const t3 = n3[0] + ":" + n3[1];
      return !!n3[2] && k(t3);
    }
  }
  return false;
}
function jt(e3) {
  if (h(e3, false))
    try {
      return typeof new URL(e3) < "u";
    } catch {
      return false;
    }
  return false;
}
function Dt(e3) {
  var n3;
  return (n3 = e3 == null ? void 0 : e3.proposer) == null ? void 0 : n3.publicKey;
}
function kt(e3) {
  return e3 == null ? void 0 : e3.topic;
}
function Vt(e3, n3) {
  let t3 = null;
  return h(e3 == null ? void 0 : e3.publicKey, false) || (t3 = N("MISSING_OR_INVALID", `${n3} controller public key should be a string`)), t3;
}
function ie(e3) {
  let n3 = true;
  return D(e3) ? e3.length && (n3 = e3.every((t3) => h(t3, false))) : n3 = false, n3;
}
function nn(e3, n3, t3) {
  let r5 = null;
  return D(n3) && n3.length ? n3.forEach((o3) => {
    r5 || k(o3) || (r5 = U("UNSUPPORTED_CHAINS", `${t3}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : k(e3) || (r5 = U("UNSUPPORTED_CHAINS", `${t3}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r5;
}
function tn(e3, n3, t3) {
  let r5 = null;
  return Object.entries(e3).forEach(([o3, s3]) => {
    if (r5)
      return;
    const i4 = nn(o3, K(o3, s3), `${n3} ${t3}`);
    i4 && (r5 = i4);
  }), r5;
}
function rn(e3, n3) {
  let t3 = null;
  return D(e3) ? e3.forEach((r5) => {
    t3 || en(r5) || (t3 = U("UNSUPPORTED_ACCOUNTS", `${n3}, account ${r5} should be a string and conform to "namespace:chainId:address" format`));
  }) : t3 = U("UNSUPPORTED_ACCOUNTS", `${n3}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t3;
}
function on(e3, n3) {
  let t3 = null;
  return Object.values(e3).forEach((r5) => {
    if (t3)
      return;
    const o3 = rn(r5 == null ? void 0 : r5.accounts, `${n3} namespace`);
    o3 && (t3 = o3);
  }), t3;
}
function sn(e3, n3) {
  let t3 = null;
  return ie(e3 == null ? void 0 : e3.methods) ? ie(e3 == null ? void 0 : e3.events) || (t3 = U("UNSUPPORTED_EVENTS", `${n3}, events should be an array of strings or empty array for no events`)) : t3 = U("UNSUPPORTED_METHODS", `${n3}, methods should be an array of strings or empty array for no methods`), t3;
}
function ce(e3, n3) {
  let t3 = null;
  return Object.values(e3).forEach((r5) => {
    if (t3)
      return;
    const o3 = sn(r5, `${n3}, namespace`);
    o3 && (t3 = o3);
  }), t3;
}
function Mt(e3, n3, t3) {
  let r5 = null;
  if (e3 && B(e3)) {
    const o3 = ce(e3, n3);
    o3 && (r5 = o3);
    const s3 = tn(e3, n3, t3);
    s3 && (r5 = s3);
  } else
    r5 = N("MISSING_OR_INVALID", `${n3}, ${t3} should be an object with data`);
  return r5;
}
function cn(e3, n3) {
  let t3 = null;
  if (e3 && B(e3)) {
    const r5 = ce(e3, n3);
    r5 && (t3 = r5);
    const o3 = on(e3, n3);
    o3 && (t3 = o3);
  } else
    t3 = N("MISSING_OR_INVALID", `${n3}, namespaces should be an object with data`);
  return t3;
}
function an(e3) {
  return h(e3.protocol, true);
}
function Kt(e3, n3) {
  let t3 = false;
  return n3 && !e3 ? t3 = true : e3 && D(e3) && e3.length && e3.forEach((r5) => {
    t3 = an(r5);
  }), t3;
}
function Lt(e3) {
  return typeof e3 == "number";
}
function xt(e3) {
  return typeof e3 < "u" && typeof e3 !== null;
}
function Ft(e3) {
  return !(!e3 || typeof e3 != "object" || !e3.code || !G(e3.code, false) || !e3.message || !h(e3.message, false));
}
function Ht(e3) {
  return !(w(e3) || !h(e3.method, false));
}
function qt(e3) {
  return !(w(e3) || w(e3.result) && w(e3.error) || !G(e3.id, false) || !h(e3.jsonrpc, false));
}
function Bt(e3) {
  return !(w(e3) || !h(e3.name, false));
}
function Gt(e3, n3) {
  return !(!k(n3) || !Je(e3).includes(n3));
}
function Wt(e3, n3, t3) {
  return h(t3, false) ? Qe(e3, n3).includes(t3) : false;
}
function zt(e3, n3, t3) {
  return h(t3, false) ? Ze(e3, n3).includes(t3) : false;
}
function un(e3, n3, t3) {
  let r5 = null;
  const o3 = Yt(e3), s3 = Jt(n3), i4 = Object.keys(o3), l4 = Object.keys(s3), d4 = ln(Object.keys(e3)), c5 = ln(Object.keys(n3)), u5 = d4.filter((a4) => !c5.includes(a4));
  return u5.length && (r5 = N("NON_CONFORMING_NAMESPACES", `${t3} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u5.toString()}
      Received: ${Object.keys(n3).toString()}`)), O(i4, l4) || (r5 = N("NON_CONFORMING_NAMESPACES", `${t3} namespaces chains don't satisfy required namespaces.
      Required: ${i4.toString()}
      Approved: ${l4.toString()}`)), Object.keys(n3).forEach((a4) => {
    if (!a4.includes(":") || r5)
      return;
    const b6 = A(n3[a4].accounts);
    b6.includes(a4) || (r5 = N("NON_CONFORMING_NAMESPACES", `${t3} namespaces accounts don't satisfy namespace accounts for ${a4}
        Required: ${a4}
        Approved: ${b6.toString()}`));
  }), i4.forEach((a4) => {
    r5 || (O(o3[a4].methods, s3[a4].methods) ? O(o3[a4].events, s3[a4].events) || (r5 = N("NON_CONFORMING_NAMESPACES", `${t3} namespaces events don't satisfy namespace events for ${a4}`)) : r5 = N("NON_CONFORMING_NAMESPACES", `${t3} namespaces methods don't satisfy namespace methods for ${a4}`));
  }), r5;
}
function Yt(e3) {
  const n3 = {};
  return Object.keys(e3).forEach((t3) => {
    var r5;
    t3.includes(":") ? n3[t3] = e3[t3] : (r5 = e3[t3].chains) == null || r5.forEach((o3) => {
      n3[o3] = { methods: e3[t3].methods, events: e3[t3].events };
    });
  }), n3;
}
function ln(e3) {
  return [...new Set(e3.map((n3) => n3.includes(":") ? n3.split(":")[0] : n3))];
}
function Jt(e3) {
  const n3 = {};
  return Object.keys(e3).forEach((t3) => {
    if (t3.includes(":"))
      n3[t3] = e3[t3];
    else {
      const r5 = A(e3[t3].accounts);
      r5 == null ? void 0 : r5.forEach((o3) => {
        n3[o3] = { accounts: e3[t3].accounts.filter((s3) => s3.includes(`${o3}:`)), methods: e3[t3].methods, events: e3[t3].events };
      });
    }
  }), n3;
}
function Qt(e3, n3) {
  return G(e3, false) && e3 <= n3.max && e3 >= n3.min;
}
function Zt() {
  const e3 = R();
  return new Promise((n3) => {
    switch (e3) {
      case m.browser:
        n3(dn());
        break;
      case m.reactNative:
        n3(fn());
        break;
      case m.node:
        n3(pn());
        break;
      default:
        n3(true);
    }
  });
}
function dn() {
  return q() && (navigator == null ? void 0 : navigator.onLine);
}
async function fn() {
  if (j() && typeof global < "u" && global != null && global.NetInfo) {
    const e3 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e3 == null ? void 0 : e3.isConnected;
  }
  return true;
}
function pn() {
  return true;
}
function Xt(e3) {
  switch (R()) {
    case m.browser:
      mn(e3);
      break;
    case m.reactNative:
      yn(e3);
      break;
    case m.node:
      break;
  }
}
function mn(e3) {
  !j() && q() && (window.addEventListener("online", () => e3(true)), window.addEventListener("offline", () => e3(false)));
}
function yn(e3) {
  j() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n3) => e3(n3 == null ? void 0 : n3.isConnected)));
}
var ae = {};
var er = class {
  static get(n3) {
    return ae[n3];
  }
  static set(n3, t3) {
    ae[n3] = t3;
  }
  static delete(n3) {
    delete ae[n3];
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_events5 = __toESM(require_events());

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key2, value) {
  if (key2 === "__proto__" || key2 === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key2);
    return;
  }
  return value;
}
function warnKeyDropped(key2) {
  console.warn(`[destr] Dropping "${key2}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.at(-1) === '"' && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/unstorage/dist/shared/unstorage.8581f561.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type2 = typeof value;
  return value === null || type2 !== "object" && type2 !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify2(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify2(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === void 0) {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base642 = Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base642;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key2) {
  if (!key2) {
    return "";
  }
  return key2.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base4) {
  base4 = normalizeKey(base4);
  return base4 ? base4 + ":" : "";
}

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data3 = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    options: {},
    hasItem(key2) {
      return data3.has(key2);
    },
    getItem(key2) {
      return data3.get(key2) ?? null;
    },
    getItemRaw(key2) {
      return data3.get(key2) ?? null;
    },
    setItem(key2, value) {
      data3.set(key2, value);
    },
    setItemRaw(key2, value) {
      data3.set(key2, value);
    },
    removeItem(key2) {
      data3.delete(key2);
    },
    getKeys() {
      return Array.from(data3.keys());
    },
    clear() {
      data3.clear();
    },
    dispose() {
      data3.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key2) => {
    for (const base4 of context.mountpoints) {
      if (key2.startsWith(base4)) {
        return {
          base: base4,
          relativeKey: key2.slice(base4.length),
          driver: context.mounts[base4]
        };
      }
    }
    return {
      base: "",
      relativeKey: key2,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base4, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base4) || includeParent && base4.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base4.length > mountpoint.length ? base4.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key2) => {
    if (!context.watching) {
      return;
    }
    key2 = normalizeKey(key2);
    for (const listener of context.watchListeners) {
      listener(event, key2);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key2 = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key2);
      getBatch(mount).items.push({
        key: key2,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r5) => r5.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r5) => r5.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key2, opts = {}) {
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify2(value), opts);
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          await asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify2(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify2(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key2, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key2, opts);
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key2);
      }
    },
    async removeItem(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key2);
      }
    },
    // Meta
    async getMeta(key2, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key2 = normalizeKey(key2);
      const { relativeKey, driver } = getMount(key2);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key2, value, opts = {}) {
      return this.setItem(key2 + "$", value, opts);
    },
    removeMeta(key2, opts = {}) {
      return this.removeItem(key2 + "$", opts);
    },
    // Keys
    async getKeys(base4, opts = {}) {
      base4 = normalizeBaseKey(base4);
      const mounts = getMounts(base4, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        const keys2 = rawKeys.map((key2) => mount.mountpoint + normalizeKey(key2)).filter((key2) => !maskedMounts.some((p6) => key2.startsWith(p6)));
        allKeys.push(...keys2);
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p6) => !p6.startsWith(mount.mountpoint))
        ];
      }
      return base4 ? allKeys.filter((key2) => key2.startsWith(base4) && !key2.endsWith("$")) : allKeys.filter((key2) => !key2.endsWith("$"));
    },
    // Utils
    async clear(base4, opts = {}) {
      base4 = normalizeBaseKey(base4);
      await Promise.all(
        getMounts(base4, false).map(async (m5) => {
          if (m5.driver.clear) {
            return asyncCall(m5.driver.clear, m5.relativeBase, opts);
          }
          if (m5.driver.removeItem) {
            const keys2 = await m5.driver.getKeys(m5.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key2) => m5.driver.removeItem(key2, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base4, driver) {
      base4 = normalizeBaseKey(base4);
      if (base4 && context.mounts[base4]) {
        throw new Error(`already mounted at ${base4}`);
      }
      if (base4) {
        context.mountpoints.push(base4);
        context.mountpoints.sort((a4, b6) => b6.length - a4.length);
      }
      context.mounts[base4] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base4)).then((unwatcher) => {
          context.unwatch[base4] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base4, _dispose = true) {
      base4 = normalizeBaseKey(base4);
      if (!base4 || !context.mounts[base4]) {
        return;
      }
      if (context.watching && base4 in context.unwatch) {
        context.unwatch[base4]();
        delete context.unwatch[base4];
      }
      if (_dispose) {
        await dispose(context.mounts[base4]);
      }
      context.mountpoints = context.mountpoints.filter((key2) => key2 !== base4);
      delete context.mounts[base4];
    },
    getMount(key2 = "") {
      key2 = normalizeKey(key2) + ":";
      const m5 = getMount(key2);
      return {
        driver: m5.driver,
        base: m5.base
      };
    },
    getMounts(base4 = "", opts = {}) {
      base4 = normalizeKey(base4);
      const mounts = getMounts(base4, opts.parents);
      return mounts.map((m5) => ({
        driver: m5.driver,
        base: m5.mountpoint
      }));
    }
  };
  return storage;
}
function watch(driver, onChange, base4) {
  return driver.watch ? driver.watch((event, key2) => onChange(event, base4 + key2)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key2, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key2)));
}
function set(key2, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key2);
    return promisifyRequest(store.transaction);
  });
}
function del(key2, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key2);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@walletconnect/safe-json/dist/esm/index.js
var JSONStringify = (data3) => JSON.stringify(data3, (_6, value) => typeof value === "bigint" ? value.toString() + "n" : value);
var JSONParse = (json) => {
  const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
  const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
  return JSON.parse(serializedData, (_6, value) => {
    const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
    if (isCustomFormatBigInt)
      return BigInt(value.substring(0, value.length - 1));
    return value;
  });
};
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSONParse(value);
  } catch (_a2) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSONStringify(value) || "";
}

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x2 = "idb-keyval";
var z = (i4 = {}) => {
  const t3 = i4.base && i4.base.length > 0 ? `${i4.base}:` : "", e3 = (s3) => t3 + s3;
  let n3;
  return i4.dbName && i4.storeName && (n3 = createStore(i4.dbName, i4.storeName)), { name: x2, options: i4, async hasItem(s3) {
    return !(typeof await get(e3(s3), n3) > "u");
  }, async getItem(s3) {
    return await get(e3(s3), n3) ?? null;
  }, setItem(s3, a4) {
    return set(e3(s3), a4, n3);
  }, removeItem(s3) {
    return del(e3(s3), n3);
  }, getKeys() {
    return keys(n3);
  }, clear() {
    return clear(n3);
  } };
};
var D2 = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _2 = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D2, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t3) => [t3.key, t3.value]);
  }
  async getItem(t3) {
    const e3 = await this.indexedDb.getItem(t3);
    if (e3 !== null)
      return e3;
  }
  async setItem(t3, e3) {
    await this.indexedDb.setItem(t3, safeJsonStringify(e3));
  }
  async removeItem(t3) {
    await this.indexedDb.removeItem(t3);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i4;
  function t3() {
  }
  i4 = t3, i4.prototype.getItem = function(e3) {
    return this.hasOwnProperty(e3) ? String(this[e3]) : null;
  }, i4.prototype.setItem = function(e3, n3) {
    this[e3] = String(n3);
  }, i4.prototype.removeItem = function(e3) {
    delete this[e3];
  }, i4.prototype.clear = function() {
    const e3 = this;
    Object.keys(e3).forEach(function(n3) {
      e3[n3] = void 0, delete e3[n3];
    });
  }, i4.prototype.key = function(e3) {
    return e3 = e3 || 0, Object.keys(this)[e3];
  }, i4.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t3();
})();
function k2(i4) {
  var t3;
  return [i4[0], safeJsonParse((t3 = i4[1]) != null ? t3 : "")];
}
var K2 = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t3) {
    const e3 = this.localStorage.getItem(t3);
    if (e3 !== null)
      return safeJsonParse(e3);
  }
  async setItem(t3, e3) {
    this.localStorage.setItem(t3, safeJsonStringify(e3));
  }
  async removeItem(t3) {
    this.localStorage.removeItem(t3);
  }
};
var N10 = "wc_storage_version";
var y = 1;
var O2 = async (i4, t3, e3) => {
  const n3 = N10, s3 = await t3.getItem(n3);
  if (s3 && s3 >= y) {
    e3(t3);
    return;
  }
  const a4 = await i4.getKeys();
  if (!a4.length) {
    e3(t3);
    return;
  }
  const m5 = [];
  for (; a4.length; ) {
    const r5 = a4.shift();
    if (!r5)
      continue;
    const o3 = r5.toLowerCase();
    if (o3.includes("wc@") || o3.includes("walletconnect") || o3.includes("wc_") || o3.includes("wallet_connect")) {
      const f5 = await i4.getItem(r5);
      await t3.setItem(r5, f5), m5.push(r5);
    }
  }
  await t3.setItem(n3, y), e3(t3), j2(i4, m5);
};
var j2 = async (i4, t3) => {
  t3.length && t3.forEach(async (e3) => {
    await i4.removeItem(e3);
  });
};
var h2 = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e3) => {
      this.storage = e3, this.initialized = true;
    };
    const t3 = new K2();
    this.storage = t3;
    try {
      const e3 = new _2();
      O2(t3, e3, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t3) {
    return await this.initialize(), this.storage.getItem(t3);
  }
  async setItem(t3, e3) {
    return await this.initialize(), this.storage.setItem(t3, e3);
  }
  async removeItem(t3) {
    return await this.initialize(), this.storage.removeItem(t3);
  }
  async initialize() {
    this.initialized || await new Promise((t3) => {
      const e3 = setInterval(() => {
        this.initialized && (clearInterval(e3), t3());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_heartbeat = __toESM(require_cjs4());
var import_logger = __toESM(require_cjs5());

// node_modules/@walletconnect/types/dist/index.es.js
init_esm();
var import_events2 = __toESM(require_events());
var n = class extends IEvents {
  constructor(s3) {
    super(), this.opts = s3, this.protocol = "wc", this.version = 2;
  }
};
var h3 = class extends IEvents {
  constructor(s3, t3) {
    super(), this.core = s3, this.logger = t3, this.records = /* @__PURE__ */ new Map();
  }
};
var a = class {
  constructor(s3, t3) {
    this.logger = s3, this.core = t3;
  }
};
var u = class extends IEvents {
  constructor(s3, t3) {
    super(), this.relayer = s3, this.logger = t3;
  }
};
var g = class extends IEvents {
  constructor(s3) {
    super();
  }
};
var p2 = class {
  constructor(s3, t3, o3, w5) {
    this.core = s3, this.logger = t3, this.name = o3;
  }
};
var d = class extends IEvents {
  constructor(s3, t3) {
    super(), this.relayer = s3, this.logger = t3;
  }
};
var E2 = class extends IEvents {
  constructor(s3, t3) {
    super(), this.core = s3, this.logger = t3;
  }
};
var y2 = class {
  constructor(s3, t3) {
    this.projectId = s3, this.logger = t3;
  }
};
var b = class {
  constructor(s3) {
    this.opts = s3, this.protocol = "wc", this.version = 2;
  }
};
var S2 = class {
  constructor(s3) {
    this.client = s3;
  }
};

// node_modules/@walletconnect/relay-auth/dist/esm/api.js
var ed25519 = __toESM(require_ed25519());
var import_random2 = __toESM(require_random());
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/relay-auth/dist/esm/constants.js
var JWT_IRIDIUM_ALG = "EdDSA";
var JWT_IRIDIUM_TYP = "JWT";
var JWT_DELIMITER = ".";
var JWT_ENCODING = "base64url";
var JSON_ENCODING = "utf8";
var DATA_ENCODING = "utf8";
var DID_DELIMITER = ":";
var DID_PREFIX = "did";
var DID_METHOD = "key";
var MULTICODEC_ED25519_ENCODING = "base58btc";
var MULTICODEC_ED25519_BASE = "z";
var MULTICODEC_ED25519_HEADER = "K36";
var KEY_PAIR_SEED_LENGTH = 32;

// node_modules/@walletconnect/relay-auth/dist/esm/utils.js
function encodeJSON(val) {
  return toString2(fromString2(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
}
function encodeIss(publicKey) {
  const header = fromString2(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
  const multicodec = MULTICODEC_ED25519_BASE + toString2(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
}
function encodeSig(bytes) {
  return toString2(bytes, JWT_ENCODING);
}
function encodeData(params) {
  return fromString2([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
}
function encodeJWT(params) {
  return [
    encodeJSON(params.header),
    encodeJSON(params.payload),
    encodeSig(params.signature)
  ].join(JWT_DELIMITER);
}

// node_modules/@walletconnect/relay-auth/dist/esm/api.js
function generateKeyPair2(seed = (0, import_random2.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
  return ed25519.generateKeyPairFromSeed(seed);
}
async function signJWT(sub, aud, ttl, keyPair2, iat = (0, import_time2.fromMiliseconds)(Date.now())) {
  const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
  const iss = encodeIss(keyPair2.publicKey);
  const exp = iat + ttl;
  const payload = { iss, sub, aud, iat, exp };
  const data3 = encodeData({ header, payload });
  const signature2 = ed25519.sign(keyPair2.secretKey, data3);
  return encodeJWT({ header, payload, signature: signature2 });
}

// node_modules/@walletconnect/core/dist/index.es.js
var import_time3 = __toESM(require_cjs());

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
  IEvents: () => IEvents2,
  IJsonRpcConnection: () => IJsonRpcConnection,
  IJsonRpcProvider: () => IJsonRpcProvider,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code2) {
  return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code2) {
  return RESERVED_ERROR_CODES.includes(code2);
}
function isValidErrorCode(code2) {
  return typeof code2 === "number";
}
function getError(type2) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type2)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type2];
}
function getErrorByCode(code2) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e3) => e3.code === code2);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e3, url, type2) {
  return e3.message.includes("getaddrinfo ENOTFOUND") || e3.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type2} RPC url at ${url}`) : e3;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs6());
__reExport(env_exports, __toESM(require_cjs6()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports2, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date2 = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date2 + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id2) {
  return {
    id: id2 || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id2, result) {
  return {
    id: id2,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id2, error, data3) {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data3)
  };
}
function formatErrorMessage(error, data3) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data3 !== "undefined") {
    error.data = data3;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x5) => x5.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
var IEvents2 = class {
};

// node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
var IJsonRpcConnection = class extends IEvents2 {
  constructor(opts) {
    super();
  }
};
var IBaseJsonRpcProvider = class extends IEvents2 {
  constructor() {
    super();
  }
};
var IJsonRpcProvider = class extends IBaseJsonRpcProvider {
  constructor(connection) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
var JsonRpcProvider = class extends IJsonRpcProvider {
  constructor(connection) {
    super(connection);
    this.events = new import_events3.EventEmitter();
    this.hasRegisteredEventListeners = false;
    this.connection = this.setConnection(connection);
    if (this.connection.connected) {
      this.registerEventListeners();
    }
  }
  async connect(connection = this.connection) {
    await this.open(connection);
  }
  async disconnect() {
    await this.close();
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async request(request, context) {
    return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
  }
  async requestStrict(request, context) {
    return new Promise(async (resolve, reject) => {
      if (!this.connection.connected) {
        try {
          await this.open();
        } catch (e3) {
          reject(e3);
        }
      }
      this.events.on(`${request.id}`, (response) => {
        if (isJsonRpcError(response)) {
          reject(response.error);
        } else {
          resolve(response.result);
        }
      });
      try {
        await this.connection.send(request, context);
      } catch (e3) {
        reject(e3);
      }
    });
  }
  setConnection(connection = this.connection) {
    return connection;
  }
  onPayload(payload) {
    this.events.emit("payload", payload);
    if (isJsonRpcResponse(payload)) {
      this.events.emit(`${payload.id}`, payload);
    } else {
      this.events.emit("message", {
        type: payload.method,
        data: payload.params
      });
    }
  }
  onClose(event) {
    if (event && event.code === 3e3) {
      this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
    }
    this.events.emit("disconnect");
  }
  async open(connection = this.connection) {
    if (this.connection === connection && this.connection.connected)
      return;
    if (this.connection.connected)
      this.close();
    if (typeof connection === "string") {
      await this.connection.open(connection);
      connection = this.connection;
    }
    this.connection = this.setConnection(connection);
    await this.connection.open();
    this.registerEventListeners();
    this.events.emit("connect");
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    if (this.hasRegisteredEventListeners)
      return;
    this.connection.on("payload", (payload) => this.onPayload(payload));
    this.connection.on("close", (event) => this.onClose(event));
    this.connection.on("error", (error) => this.events.emit("error", error));
    this.connection.on("register_error", (error) => this.onClose());
    this.hasRegisteredEventListeners = true;
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
var import_events4 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/utils.js
var resolveWebSocketImplementation = () => {
  if (typeof WebSocket !== "undefined") {
    return WebSocket;
  } else if (typeof global !== "undefined" && typeof global.WebSocket !== "undefined") {
    return global.WebSocket;
  } else if (typeof window !== "undefined" && typeof window.WebSocket !== "undefined") {
    return window.WebSocket;
  } else if (typeof self !== "undefined" && typeof self.WebSocket !== "undefined") {
    return self.WebSocket;
  }
  return require_browser3();
};
var hasBuiltInWebSocket = () => typeof WebSocket !== "undefined" || typeof global !== "undefined" && typeof global.WebSocket !== "undefined" || typeof window !== "undefined" && typeof window.WebSocket !== "undefined" || typeof self !== "undefined" && typeof self.WebSocket !== "undefined";
var truncateQuery = (wssUrl) => wssUrl.split("?")[0];

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/ws.js
var EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
var WS = resolveWebSocketImplementation();
var WsConnection = class {
  constructor(url) {
    this.url = url;
    this.events = new import_events4.EventEmitter();
    this.registering = false;
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    this.url = url;
  }
  get connected() {
    return typeof this.socket !== "undefined";
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    return new Promise((resolve, reject) => {
      if (typeof this.socket === "undefined") {
        reject(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (event) => {
        this.onClose(event);
        resolve();
      };
      this.socket.close();
    });
  }
  async send(payload, context) {
    if (typeof this.socket === "undefined") {
      this.socket = await this.register();
    }
    try {
      this.socket.send(safeJsonStringify(payload));
    } catch (e3) {
      this.onError(payload.id, e3);
    }
  }
  register(url = this.url) {
    if (!isWsUrl(url)) {
      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.socket === "undefined") {
            return reject(new Error("WebSocket connection is missing or invalid"));
          }
          resolve(this.socket);
        });
      });
    }
    this.url = url;
    this.registering = true;
    return new Promise((resolve, reject) => {
      const opts = !(0, esm_exports2.isReactNative)() ? { rejectUnauthorized: !isLocalhostUrl(url) } : void 0;
      const socket = new WS(url, [], opts);
      if (hasBuiltInWebSocket()) {
        socket.onerror = (event) => {
          const errorEvent = event;
          reject(this.emitError(errorEvent.error));
        };
      } else {
        socket.on("error", (errorEvent) => {
          reject(this.emitError(errorEvent));
        });
      }
      socket.onopen = () => {
        this.onOpen(socket);
        resolve(socket);
      };
    });
  }
  onOpen(socket) {
    socket.onmessage = (event) => this.onPayload(event);
    socket.onclose = (event) => this.onClose(event);
    this.socket = socket;
    this.registering = false;
    this.events.emit("open");
  }
  onClose(event) {
    this.socket = void 0;
    this.registering = false;
    this.events.emit("close", event);
  }
  onPayload(e3) {
    if (typeof e3.data === "undefined")
      return;
    const payload = typeof e3.data === "string" ? safeJsonParse(e3.data) : e3.data;
    this.events.emit("payload", payload);
  }
  onError(id2, e3) {
    const error = this.parseError(e3);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id2, message);
    this.events.emit("payload", payload);
  }
  parseError(e3, url = this.url) {
    return parseConnectionError(e3, truncateQuery(url), "WS");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
    }
  }
  emitError(errorEvent) {
    const error = this.parseError(new Error((errorEvent === null || errorEvent === void 0 ? void 0 : errorEvent.message) || `WebSocket connection failed for host: ${truncateQuery(this.url)}`));
    this.events.emit("register_error", error);
    return error;
  }
};
var ws_default = WsConnection;

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/esm/index.js
var esm_default = ws_default;

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
function Ki(r5, e3) {
  if (r5.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t3 = new Uint8Array(256), i4 = 0; i4 < t3.length; i4++)
    t3[i4] = 255;
  for (var s3 = 0; s3 < r5.length; s3++) {
    var n3 = r5.charAt(s3), a4 = n3.charCodeAt(0);
    if (t3[a4] !== 255)
      throw new TypeError(n3 + " is ambiguous");
    t3[a4] = s3;
  }
  var o3 = r5.length, h6 = r5.charAt(0), u5 = Math.log(o3) / Math.log(256), d4 = Math.log(256) / Math.log(o3);
  function p6(c5) {
    if (c5 instanceof Uint8Array || (ArrayBuffer.isView(c5) ? c5 = new Uint8Array(c5.buffer, c5.byteOffset, c5.byteLength) : Array.isArray(c5) && (c5 = Uint8Array.from(c5))), !(c5 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c5.length === 0)
      return "";
    for (var m5 = 0, z5 = 0, I3 = 0, _6 = c5.length; I3 !== _6 && c5[I3] === 0; )
      I3++, m5++;
    for (var S5 = (_6 - I3) * d4 + 1 >>> 0, b6 = new Uint8Array(S5); I3 !== _6; ) {
      for (var P4 = c5[I3], A5 = 0, C2 = S5 - 1; (P4 !== 0 || A5 < z5) && C2 !== -1; C2--, A5++)
        P4 += 256 * b6[C2] >>> 0, b6[C2] = P4 % o3 >>> 0, P4 = P4 / o3 >>> 0;
      if (P4 !== 0)
        throw new Error("Non-zero carry");
      z5 = A5, I3++;
    }
    for (var x5 = S5 - z5; x5 !== S5 && b6[x5] === 0; )
      x5++;
    for (var q5 = h6.repeat(m5); x5 < S5; ++x5)
      q5 += r5.charAt(b6[x5]);
    return q5;
  }
  function y7(c5) {
    if (typeof c5 != "string")
      throw new TypeError("Expected String");
    if (c5.length === 0)
      return new Uint8Array();
    var m5 = 0;
    if (c5[m5] !== " ") {
      for (var z5 = 0, I3 = 0; c5[m5] === h6; )
        z5++, m5++;
      for (var _6 = (c5.length - m5) * u5 + 1 >>> 0, S5 = new Uint8Array(_6); c5[m5]; ) {
        var b6 = t3[c5.charCodeAt(m5)];
        if (b6 === 255)
          return;
        for (var P4 = 0, A5 = _6 - 1; (b6 !== 0 || P4 < I3) && A5 !== -1; A5--, P4++)
          b6 += o3 * S5[A5] >>> 0, S5[A5] = b6 % 256 >>> 0, b6 = b6 / 256 >>> 0;
        if (b6 !== 0)
          throw new Error("Non-zero carry");
        I3 = P4, m5++;
      }
      if (c5[m5] !== " ") {
        for (var C2 = _6 - I3; C2 !== _6 && S5[C2] === 0; )
          C2++;
        for (var x5 = new Uint8Array(z5 + (_6 - C2)), q5 = z5; C2 !== _6; )
          x5[q5++] = S5[C2++];
        return x5;
      }
    }
  }
  function $4(c5) {
    var m5 = y7(c5);
    if (m5)
      return m5;
    throw new Error(`Non-${e3} character`);
  }
  return { encode: p6, decodeUnsafe: y7, decode: $4 };
}
var Bi = Ki;
var Vi = Bi;
var ze = (r5) => {
  if (r5 instanceof Uint8Array && r5.constructor.name === "Uint8Array")
    return r5;
  if (r5 instanceof ArrayBuffer)
    return new Uint8Array(r5);
  if (ArrayBuffer.isView(r5))
    return new Uint8Array(r5.buffer, r5.byteOffset, r5.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var qi = (r5) => new TextEncoder().encode(r5);
var ji = (r5) => new TextDecoder().decode(r5);
var Yi = class {
  constructor(e3, t3, i4) {
    this.name = e3, this.prefix = t3, this.baseEncode = i4;
  }
  encode(e3) {
    if (e3 instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e3)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Gi = class {
  constructor(e3, t3, i4) {
    if (this.name = e3, this.prefix = t3, t3.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t3.codePointAt(0), this.baseDecode = i4;
  }
  decode(e3) {
    if (typeof e3 == "string") {
      if (e3.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e3)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e3.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e3) {
    return Ne(this, e3);
  }
};
var Hi = class {
  constructor(e3) {
    this.decoders = e3;
  }
  or(e3) {
    return Ne(this, e3);
  }
  decode(e3) {
    const t3 = e3[0], i4 = this.decoders[t3];
    if (i4)
      return i4.decode(e3);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e3)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Ne = (r5, e3) => new Hi({ ...r5.decoders || { [r5.prefix]: r5 }, ...e3.decoders || { [e3.prefix]: e3 } });
var Ji = class {
  constructor(e3, t3, i4, s3) {
    this.name = e3, this.prefix = t3, this.baseEncode = i4, this.baseDecode = s3, this.encoder = new Yi(e3, t3, i4), this.decoder = new Gi(e3, t3, s3);
  }
  encode(e3) {
    return this.encoder.encode(e3);
  }
  decode(e3) {
    return this.decoder.decode(e3);
  }
};
var W2 = ({ name: r5, prefix: e3, encode: t3, decode: i4 }) => new Ji(r5, e3, t3, i4);
var K3 = ({ prefix: r5, name: e3, alphabet: t3 }) => {
  const { encode: i4, decode: s3 } = Vi(t3, e3);
  return W2({ prefix: r5, name: e3, encode: i4, decode: (n3) => ze(s3(n3)) });
};
var Wi = (r5, e3, t3, i4) => {
  const s3 = {};
  for (let d4 = 0; d4 < e3.length; ++d4)
    s3[e3[d4]] = d4;
  let n3 = r5.length;
  for (; r5[n3 - 1] === "="; )
    --n3;
  const a4 = new Uint8Array(n3 * t3 / 8 | 0);
  let o3 = 0, h6 = 0, u5 = 0;
  for (let d4 = 0; d4 < n3; ++d4) {
    const p6 = s3[r5[d4]];
    if (p6 === void 0)
      throw new SyntaxError(`Non-${i4} character`);
    h6 = h6 << t3 | p6, o3 += t3, o3 >= 8 && (o3 -= 8, a4[u5++] = 255 & h6 >> o3);
  }
  if (o3 >= t3 || 255 & h6 << 8 - o3)
    throw new SyntaxError("Unexpected end of data");
  return a4;
};
var Xi = (r5, e3, t3) => {
  const i4 = e3[e3.length - 1] === "=", s3 = (1 << t3) - 1;
  let n3 = "", a4 = 0, o3 = 0;
  for (let h6 = 0; h6 < r5.length; ++h6)
    for (o3 = o3 << 8 | r5[h6], a4 += 8; a4 > t3; )
      a4 -= t3, n3 += e3[s3 & o3 >> a4];
  if (a4 && (n3 += e3[s3 & o3 << t3 - a4]), i4)
    for (; n3.length * t3 & 7; )
      n3 += "=";
  return n3;
};
var g2 = ({ name: r5, prefix: e3, bitsPerChar: t3, alphabet: i4 }) => W2({ prefix: e3, name: r5, encode(s3) {
  return Xi(s3, i4, t3);
}, decode(s3) {
  return Wi(s3, i4, t3, r5);
} });
var Qi = W2({ prefix: "\0", name: "identity", encode: (r5) => ji(r5), decode: (r5) => qi(r5) });
var Zi = Object.freeze({ __proto__: null, identity: Qi });
var es = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var ts = Object.freeze({ __proto__: null, base2: es });
var is = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var ss = Object.freeze({ __proto__: null, base8: is });
var rs = K3({ prefix: "9", name: "base10", alphabet: "0123456789" });
var ns = Object.freeze({ __proto__: null, base10: rs });
var as = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var os = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var hs = Object.freeze({ __proto__: null, base16: as, base16upper: os });
var cs = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var us = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var ls = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var ds = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var gs = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var ps = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Ds = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var ys = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var ms = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var bs = Object.freeze({ __proto__: null, base32: cs, base32upper: us, base32pad: ls, base32padupper: ds, base32hex: gs, base32hexupper: ps, base32hexpad: Ds, base32hexpadupper: ys, base32z: ms });
var fs = K3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Es = K3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ws = Object.freeze({ __proto__: null, base36: fs, base36upper: Es });
var vs = K3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Is = K3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Cs = Object.freeze({ __proto__: null, base58btc: vs, base58flickr: Is });
var Rs = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var _s = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Ss = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Ps = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ts = Object.freeze({ __proto__: null, base64: Rs, base64pad: _s, base64url: Ss, base64urlpad: Ps });
var Le = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var xs = Le.reduce((r5, e3, t3) => (r5[t3] = e3, r5), []);
var Os = Le.reduce((r5, e3, t3) => (r5[e3.codePointAt(0)] = t3, r5), []);
function As(r5) {
  return r5.reduce((e3, t3) => (e3 += xs[t3], e3), "");
}
function zs(r5) {
  const e3 = [];
  for (const t3 of r5) {
    const i4 = Os[t3.codePointAt(0)];
    if (i4 === void 0)
      throw new Error(`Non-base256emoji character: ${t3}`);
    e3.push(i4);
  }
  return new Uint8Array(e3);
}
var Ns = W2({ prefix: "🚀", name: "base256emoji", encode: As, decode: zs });
var Ls = Object.freeze({ __proto__: null, base256emoji: Ns });
var Us = Fe2;
var Ue2 = 128;
var Fs = 127;
var $s = ~Fs;
var Ms = Math.pow(2, 31);
function Fe2(r5, e3, t3) {
  e3 = e3 || [], t3 = t3 || 0;
  for (var i4 = t3; r5 >= Ms; )
    e3[t3++] = r5 & 255 | Ue2, r5 /= 128;
  for (; r5 & $s; )
    e3[t3++] = r5 & 255 | Ue2, r5 >>>= 7;
  return e3[t3] = r5 | 0, Fe2.bytes = t3 - i4 + 1, e3;
}
var ks = oe2;
var Ks = 128;
var $e = 127;
function oe2(r5, i4) {
  var t3 = 0, i4 = i4 || 0, s3 = 0, n3 = i4, a4, o3 = r5.length;
  do {
    if (n3 >= o3)
      throw oe2.bytes = 0, new RangeError("Could not decode varint");
    a4 = r5[n3++], t3 += s3 < 28 ? (a4 & $e) << s3 : (a4 & $e) * Math.pow(2, s3), s3 += 7;
  } while (a4 >= Ks);
  return oe2.bytes = n3 - i4, t3;
}
var Bs = Math.pow(2, 7);
var Vs = Math.pow(2, 14);
var qs = Math.pow(2, 21);
var js = Math.pow(2, 28);
var Ys = Math.pow(2, 35);
var Gs = Math.pow(2, 42);
var Hs = Math.pow(2, 49);
var Js = Math.pow(2, 56);
var Ws = Math.pow(2, 63);
var Xs = function(r5) {
  return r5 < Bs ? 1 : r5 < Vs ? 2 : r5 < qs ? 3 : r5 < js ? 4 : r5 < Ys ? 5 : r5 < Gs ? 6 : r5 < Hs ? 7 : r5 < Js ? 8 : r5 < Ws ? 9 : 10;
};
var Qs = { encode: Us, decode: ks, encodingLength: Xs };
var Me2 = Qs;
var ke2 = (r5, e3, t3 = 0) => (Me2.encode(r5, e3, t3), e3);
var Ke = (r5) => Me2.encodingLength(r5);
var he2 = (r5, e3) => {
  const t3 = e3.byteLength, i4 = Ke(r5), s3 = i4 + Ke(t3), n3 = new Uint8Array(s3 + t3);
  return ke2(r5, n3, 0), ke2(t3, n3, i4), n3.set(e3, s3), new Zs(r5, t3, e3, n3);
};
var Zs = class {
  constructor(e3, t3, i4, s3) {
    this.code = e3, this.size = t3, this.digest = i4, this.bytes = s3;
  }
};
var Be2 = ({ name: r5, code: e3, encode: t3 }) => new er2(r5, e3, t3);
var er2 = class {
  constructor(e3, t3, i4) {
    this.name = e3, this.code = t3, this.encode = i4;
  }
  digest(e3) {
    if (e3 instanceof Uint8Array) {
      const t3 = this.encode(e3);
      return t3 instanceof Uint8Array ? he2(this.code, t3) : t3.then((i4) => he2(this.code, i4));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var Ve2 = (r5) => async (e3) => new Uint8Array(await crypto.subtle.digest(r5, e3));
var tr = Be2({ name: "sha2-256", code: 18, encode: Ve2("SHA-256") });
var ir = Be2({ name: "sha2-512", code: 19, encode: Ve2("SHA-512") });
var sr = Object.freeze({ __proto__: null, sha256: tr, sha512: ir });
var qe2 = 0;
var rr = "identity";
var je2 = ze;
var nr = (r5) => he2(qe2, je2(r5));
var ar = { code: qe2, name: rr, encode: je2, digest: nr };
var or2 = Object.freeze({ __proto__: null, identity: ar });
new TextEncoder(), new TextDecoder();
var Ye = { ...Zi, ...ts, ...ss, ...ns, ...hs, ...bs, ...ws, ...Cs, ...Ts, ...Ls };
({ ...sr, ...or2 });
function Ge2(r5) {
  return globalThis.Buffer != null ? new Uint8Array(r5.buffer, r5.byteOffset, r5.byteLength) : r5;
}
function hr(r5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Ge2(globalThis.Buffer.allocUnsafe(r5)) : new Uint8Array(r5);
}
function He2(r5, e3, t3, i4) {
  return { name: r5, prefix: e3, encoder: { name: r5, prefix: e3, encode: t3 }, decoder: { decode: i4 } };
}
var Je2 = He2("utf8", "u", (r5) => "u" + new TextDecoder("utf8").decode(r5), (r5) => new TextEncoder().encode(r5.substring(1)));
var ce2 = He2("ascii", "a", (r5) => {
  let e3 = "a";
  for (let t3 = 0; t3 < r5.length; t3++)
    e3 += String.fromCharCode(r5[t3]);
  return e3;
}, (r5) => {
  r5 = r5.substring(1);
  const e3 = hr(r5.length);
  for (let t3 = 0; t3 < r5.length; t3++)
    e3[t3] = r5.charCodeAt(t3);
  return e3;
});
var cr = { utf8: Je2, "utf-8": Je2, hex: Ye.base16, latin1: ce2, ascii: ce2, binary: ce2, ...Ye };
function ur(r5, e3 = "utf8") {
  const t3 = cr[e3];
  if (!t3)
    throw new Error(`Unsupported encoding "${e3}"`);
  return (e3 === "utf8" || e3 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Ge2(globalThis.Buffer.from(r5, "utf-8")) : t3.decoder.decode(`${t3.prefix}${r5}`);
}
var ue2 = "wc";
var We2 = 2;
var X2 = "core";
var O3 = `${ue2}@2:${X2}:`;
var Xe2 = { name: X2, logger: "error" };
var Qe2 = { database: ":memory:" };
var Ze2 = "crypto";
var le2 = "client_ed25519_seed";
var et2 = import_time3.ONE_DAY;
var tt = "keychain";
var it2 = "0.3";
var st2 = "messages";
var rt = "0.3";
var nt2 = import_time3.SIX_HOURS;
var at2 = "publisher";
var ot = "irn";
var ht2 = "error";
var de2 = "wss://relay.walletconnect.com";
var ge = "wss://relay.walletconnect.org";
var ct2 = "relayer";
var D3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var ut2 = "_subscription";
var T = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var lt2 = import_time3.ONE_SECOND;
var dt2 = "2.10.2";
var gt2 = 1e4;
var pt2 = "0.3";
var Dt2 = "WALLETCONNECT_CLIENT_ID";
var w2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var yt2 = "subscription";
var mt2 = "0.3";
var bt2 = import_time3.FIVE_SECONDS * 1e3;
var ft2 = "pairing";
var Et2 = "0.3";
var F2 = { wc_pairingDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time3.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 0 } } };
var B2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var R2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var wt = "history";
var vt2 = "0.3";
var It = "expirer";
var v = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Ct2 = "0.3";
var Q2 = "verify-api";
var Z2 = "https://verify.walletconnect.com";
var pe = "https://verify.walletconnect.org";
var Rt = class {
  constructor(e3, t3) {
    this.core = e3, this.logger = t3, this.keychain = /* @__PURE__ */ new Map(), this.name = tt, this.version = it2, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        const i4 = await this.getKeyChain();
        typeof i4 < "u" && (this.keychain = i4), this.initialized = true;
      }
    }, this.has = (i4) => (this.isInitialized(), this.keychain.has(i4)), this.set = async (i4, s3) => {
      this.isInitialized(), this.keychain.set(i4, s3), await this.persist();
    }, this.get = (i4) => {
      this.isInitialized();
      const s3 = this.keychain.get(i4);
      if (typeof s3 > "u") {
        const { message: n3 } = N("NO_MATCHING_KEY", `${this.name}: ${i4}`);
        throw new Error(n3);
      }
      return s3;
    }, this.del = async (i4) => {
      this.isInitialized(), this.keychain.delete(i4), await this.persist();
    }, this.core = e3, this.logger = (0, import_logger.generateChildLogger)(t3, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e3) {
    await this.core.storage.setItem(this.storageKey, et(e3));
  }
  async getKeyChain() {
    const e3 = await this.core.storage.getItem(this.storageKey);
    return typeof e3 < "u" ? nt(e3) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var _t2 = class {
  constructor(e3, t3, i4) {
    this.core = e3, this.logger = t3, this.name = Ze2, this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (s3) => (this.isInitialized(), this.keychain.has(s3)), this.getClientId = async () => {
      this.isInitialized();
      const s3 = await this.getClientSeed(), n3 = generateKeyPair2(s3);
      return encodeIss(n3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const s3 = jn();
      return this.setPrivateKey(s3.publicKey, s3.privateKey);
    }, this.signJWT = async (s3) => {
      this.isInitialized();
      const n3 = await this.getClientSeed(), a4 = generateKeyPair2(n3), o3 = Dn(), h6 = et2;
      return await signJWT(o3, s3, h6, a4);
    }, this.generateSharedKey = (s3, n3, a4) => {
      this.isInitialized();
      const o3 = this.getPrivateKey(s3), h6 = kn(o3, n3);
      return this.setSymKey(h6, a4);
    }, this.setSymKey = async (s3, n3) => {
      this.isInitialized();
      const a4 = n3 || Vn(s3);
      return await this.keychain.set(a4, s3), a4;
    }, this.deleteKeyPair = async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }, this.deleteSymKey = async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }, this.encode = async (s3, n3, a4) => {
      this.isInitialized();
      const o3 = Re(a4), h6 = safeJsonStringify(n3);
      if (Fn(o3)) {
        const y7 = o3.senderPublicKey, $4 = o3.receiverPublicKey;
        s3 = await this.generateSharedKey(y7, $4);
      }
      const u5 = this.getSymKey(s3), { type: d4, senderPublicKey: p6 } = o3;
      return Kn({ type: d4, symKey: u5, message: h6, senderPublicKey: p6 });
    }, this.decode = async (s3, n3, a4) => {
      this.isInitialized();
      const o3 = xn(n3, a4);
      if (Fn(o3)) {
        const h6 = o3.receiverPublicKey, u5 = o3.senderPublicKey;
        s3 = await this.generateSharedKey(h6, u5);
      }
      try {
        const h6 = this.getSymKey(s3), u5 = Ln({ symKey: h6, encoded: n3 });
        return safeJsonParse(u5);
      } catch (h6) {
        this.logger.error(`Failed to decode message from topic: '${s3}', clientId: '${await this.getClientId()}'`), this.logger.error(h6);
      }
    }, this.getPayloadType = (s3) => {
      const n3 = ee(s3);
      return $(n3.type);
    }, this.getPayloadSenderPublicKey = (s3) => {
      const n3 = ee(s3);
      return n3.senderPublicKey ? toString2(n3.senderPublicKey, p) : void 0;
    }, this.core = e3, this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.keychain = i4 || new Rt(this.core, this.logger);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async setPrivateKey(e3, t3) {
    return await this.keychain.set(e3, t3), e3;
  }
  getPrivateKey(e3) {
    return this.keychain.get(e3);
  }
  async getClientSeed() {
    let e3 = "";
    try {
      e3 = this.keychain.get(le2);
    } catch {
      e3 = Dn(), await this.keychain.set(le2, e3);
    }
    return ur(e3, "base16");
  }
  getSymKey(e3) {
    return this.keychain.get(e3);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var St = class extends a {
  constructor(e3, t3) {
    super(e3, t3), this.logger = e3, this.core = t3, this.messages = /* @__PURE__ */ new Map(), this.name = st2, this.version = rt, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i4 = await this.getRelayerMessages();
          typeof i4 < "u" && (this.messages = i4), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i4) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i4);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (i4, s3) => {
      this.isInitialized();
      const n3 = Mn(s3);
      let a4 = this.messages.get(i4);
      return typeof a4 > "u" && (a4 = {}), typeof a4[n3] < "u" || (a4[n3] = s3, this.messages.set(i4, a4), await this.persist()), n3;
    }, this.get = (i4) => {
      this.isInitialized();
      let s3 = this.messages.get(i4);
      return typeof s3 > "u" && (s3 = {}), s3;
    }, this.has = (i4, s3) => {
      this.isInitialized();
      const n3 = this.get(i4), a4 = Mn(s3);
      return typeof n3[a4] < "u";
    }, this.del = async (i4) => {
      this.isInitialized(), this.messages.delete(i4), await this.persist();
    }, this.logger = (0, import_logger.generateChildLogger)(e3, this.name), this.core = t3;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e3) {
    await this.core.storage.setItem(this.storageKey, et(e3));
  }
  async getRelayerMessages() {
    const e3 = await this.core.storage.getItem(this.storageKey);
    return typeof e3 < "u" ? nt(e3) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Dr = class extends u {
  constructor(e3, t3) {
    super(e3, t3), this.relayer = e3, this.logger = t3, this.events = new import_events5.EventEmitter(), this.name = at2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time3.toMiliseconds)(import_time3.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i4, s3, n3) => {
      var a4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i4, message: s3, opts: n3 } });
      try {
        const o3 = (n3 == null ? void 0 : n3.ttl) || nt2, h6 = mt(n3), u5 = (n3 == null ? void 0 : n3.prompt) || false, d4 = (n3 == null ? void 0 : n3.tag) || 0, p6 = (n3 == null ? void 0 : n3.id) || getBigIntRpcId().toString(), y7 = { topic: i4, message: s3, opts: { ttl: o3, relay: h6, prompt: u5, tag: d4, id: p6 } }, $4 = setTimeout(() => this.queue.set(p6, y7), this.publishTimeout);
        try {
          await await it(this.rpcPublish(i4, s3, o3, h6, u5, d4, p6), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p6), this.relayer.events.emit(D3.publish, y7);
        } catch (c5) {
          if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (a4 = n3 == null ? void 0 : n3.internal) != null && a4.throwOnFailedPublish)
            throw this.removeRequestFromQueue(p6), c5;
          return;
        } finally {
          clearTimeout($4);
        }
        this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i4, message: s3, opts: n3 } });
      } catch (o3) {
        throw this.logger.debug("Failed to Publish Payload"), this.logger.error(o3), o3;
      }
    }, this.on = (i4, s3) => {
      this.events.on(i4, s3);
    }, this.once = (i4, s3) => {
      this.events.once(i4, s3);
    }, this.off = (i4, s3) => {
      this.events.off(i4, s3);
    }, this.removeListener = (i4, s3) => {
      this.events.removeListener(i4, s3);
    }, this.relayer = e3, this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.registerEventListeners();
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  rpcPublish(e3, t3, i4, s3, n3, a4, o3) {
    var h6, u5, d4, p6;
    const y7 = { method: yt(s3.protocol).publish, params: { topic: e3, message: t3, ttl: i4, prompt: n3, tag: a4 }, id: o3 };
    return w((h6 = y7.params) == null ? void 0 : h6.prompt) && ((u5 = y7.params) == null || delete u5.prompt), w((d4 = y7.params) == null ? void 0 : d4.tag) && ((p6 = y7.params) == null || delete p6.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y7 }), this.relayer.request(y7);
  }
  removeRequestFromQueue(e3) {
    this.queue.delete(e3);
  }
  checkQueue() {
    this.queue.forEach(async (e3) => {
      const { topic: t3, message: i4, opts: s3 } = e3;
      await this.publish(t3, i4, s3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(D3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(D3.message_ack, (e3) => {
      this.removeRequestFromQueue(e3.id.toString());
    });
  }
};
var yr = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e3, t3) => {
      const i4 = this.get(e3);
      this.exists(e3, t3) || this.map.set(e3, [...i4, t3]);
    }, this.get = (e3) => this.map.get(e3) || [], this.exists = (e3, t3) => this.get(e3).includes(t3), this.delete = (e3, t3) => {
      if (typeof t3 > "u") {
        this.map.delete(e3);
        return;
      }
      if (!this.map.has(e3))
        return;
      const i4 = this.get(e3);
      if (!this.exists(e3, t3))
        return;
      const s3 = i4.filter((n3) => n3 !== t3);
      if (!s3.length) {
        this.map.delete(e3);
        return;
      }
      this.map.set(e3, s3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var mr = Object.defineProperty;
var br = Object.defineProperties;
var fr = Object.getOwnPropertyDescriptors;
var Pt = Object.getOwnPropertySymbols;
var Er = Object.prototype.hasOwnProperty;
var wr = Object.prototype.propertyIsEnumerable;
var Tt = (r5, e3, t3) => e3 in r5 ? mr(r5, e3, { enumerable: true, configurable: true, writable: true, value: t3 }) : r5[e3] = t3;
var V2 = (r5, e3) => {
  for (var t3 in e3 || (e3 = {}))
    Er.call(e3, t3) && Tt(r5, t3, e3[t3]);
  if (Pt)
    for (var t3 of Pt(e3))
      wr.call(e3, t3) && Tt(r5, t3, e3[t3]);
  return r5;
};
var De2 = (r5, e3) => br(r5, fr(e3));
var xt2 = class extends d {
  constructor(e3, t3) {
    super(e3, t3), this.relayer = e3, this.logger = t3, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new yr(), this.events = new import_events5.EventEmitter(), this.name = yt2, this.version = mt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O3, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
    }, this.subscribe = async (i4, s3) => {
      await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s3 } });
      try {
        const n3 = mt(s3), a4 = { topic: i4, relay: n3 };
        this.pending.set(i4, a4);
        const o3 = await this.rpcSubscribe(i4, n3);
        return this.onSubscribe(o3, a4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i4, opts: s3 } }), o3;
      } catch (n3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n3), n3;
      }
    }, this.unsubscribe = async (i4, s3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (s3 == null ? void 0 : s3.id) < "u" ? await this.unsubscribeById(i4, s3.id, s3) : await this.unsubscribeByTopic(i4, s3);
    }, this.isSubscribed = async (i4) => this.topics.includes(i4) ? true : await new Promise((s3, n3) => {
      const a4 = new import_time3.Watch();
      a4.start(this.pendingSubscriptionWatchLabel);
      const o3 = setInterval(() => {
        !this.pending.has(i4) && this.topics.includes(i4) && (clearInterval(o3), a4.stop(this.pendingSubscriptionWatchLabel), s3(true)), a4.elapsed(this.pendingSubscriptionWatchLabel) >= bt2 && (clearInterval(o3), a4.stop(this.pendingSubscriptionWatchLabel), n3(new Error("Subscription resolution timeout")));
      }, this.pollingInterval);
    }).catch(() => false), this.on = (i4, s3) => {
      this.events.on(i4, s3);
    }, this.once = (i4, s3) => {
      this.events.once(i4, s3);
    }, this.off = (i4, s3) => {
      this.events.off(i4, s3);
    }, this.removeListener = (i4, s3) => {
      this.events.removeListener(i4, s3);
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e3, this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.clientId = "";
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e3, t3) {
    let i4 = false;
    try {
      i4 = this.getSubscription(e3).topic === t3;
    } catch {
    }
    return i4;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e3, t3) {
    const i4 = this.topicMap.get(e3);
    await Promise.all(i4.map(async (s3) => await this.unsubscribeById(e3, s3, t3)));
  }
  async unsubscribeById(e3, t3, i4) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e3, id: t3, opts: i4 } });
    try {
      const s3 = mt(i4);
      await this.rpcUnsubscribe(e3, t3, s3);
      const n3 = U("USER_DISCONNECTED", `${this.name}, ${e3}`);
      await this.onUnsubscribe(e3, t3, n3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e3, id: t3, opts: i4 } });
    } catch (s3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s3), s3;
    }
  }
  async rpcSubscribe(e3, t3) {
    const i4 = { method: yt(t3.protocol).subscribe, params: { topic: e3 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    try {
      await await it(this.relayer.request(i4), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
    return Mn(e3 + this.clientId);
  }
  async rpcBatchSubscribe(e3) {
    if (!e3.length)
      return;
    const t3 = e3[0].relay, i4 = { method: yt(t3.protocol).batchSubscribe, params: { topics: e3.map((s3) => s3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i4 });
    try {
      return await await it(this.relayer.request(i4), this.subscribeTimeout);
    } catch {
      this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
    }
  }
  rpcUnsubscribe(e3, t3, i4) {
    const s3 = { method: yt(i4.protocol).unsubscribe, params: { topic: e3, id: t3 } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s3 }), this.relayer.request(s3);
  }
  onSubscribe(e3, t3) {
    this.setSubscription(e3, De2(V2({}, t3), { id: e3 })), this.pending.delete(t3.topic);
  }
  onBatchSubscribe(e3) {
    e3.length && e3.forEach((t3) => {
      this.setSubscription(t3.id, V2({}, t3)), this.pending.delete(t3.topic);
    });
  }
  async onUnsubscribe(e3, t3, i4) {
    this.events.removeAllListeners(t3), this.hasSubscription(t3, e3) && this.deleteSubscription(t3, i4), await this.relayer.messages.del(e3);
  }
  async setRelayerSubscriptions(e3) {
    await this.relayer.core.storage.setItem(this.storageKey, e3);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e3, t3) {
    this.subscriptions.has(e3) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e3, subscription: t3 }), this.addSubscription(e3, t3));
  }
  addSubscription(e3, t3) {
    this.subscriptions.set(e3, V2({}, t3)), this.topicMap.set(t3.topic, e3), this.events.emit(w2.created, t3);
  }
  getSubscription(e3) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e3 });
    const t3 = this.subscriptions.get(e3);
    if (!t3) {
      const { message: i4 } = N("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw new Error(i4);
    }
    return t3;
  }
  deleteSubscription(e3, t3) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e3, reason: t3 });
    const i4 = this.getSubscription(e3);
    this.subscriptions.delete(e3), this.topicMap.delete(i4.topic, e3), this.events.emit(w2.deleted, De2(V2({}, i4), { reason: t3 }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(w2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e3 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t3 = 0; t3 < e3; t3++) {
        const i4 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(i4);
      }
    }
    this.events.emit(w2.resubscribed);
  }
  async restore() {
    try {
      const e3 = await this.getRelayerSubscriptions();
      if (typeof e3 > "u" || !e3.length)
        return;
      if (this.subscriptions.size) {
        const { message: t3 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t3);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e3);
    }
  }
  async batchSubscribe(e3) {
    if (!e3.length)
      return;
    const t3 = await this.rpcBatchSubscribe(e3);
    D(t3) && this.onBatchSubscribe(t3.map((i4, s3) => De2(V2({}, e3[s3]), { id: i4 })));
  }
  async onConnect() {
    this.restartInProgress || (await this.restart(), this.onEnable());
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || this.relayer.transportExplicitlyClosed)
      return;
    const e3 = [];
    this.pending.forEach((t3) => {
      e3.push(t3);
    }), await this.batchSubscribe(e3);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
      await this.checkPending();
    }), this.relayer.on(D3.connect, async () => {
      await this.onConnect();
    }), this.relayer.on(D3.disconnect, () => {
      this.onDisconnect();
    }), this.events.on(w2.created, async (e3) => {
      const t3 = w2.created;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e3 }), await this.persist();
    }), this.events.on(w2.deleted, async (e3) => {
      const t3 = w2.deleted;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e3 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  async restartToComplete() {
    this.restartInProgress && await new Promise((e3) => {
      const t3 = setInterval(() => {
        this.restartInProgress || (clearInterval(t3), e3());
      }, this.pollingInterval);
    });
  }
};
var vr = Object.defineProperty;
var Ot = Object.getOwnPropertySymbols;
var Ir = Object.prototype.hasOwnProperty;
var Cr = Object.prototype.propertyIsEnumerable;
var At2 = (r5, e3, t3) => e3 in r5 ? vr(r5, e3, { enumerable: true, configurable: true, writable: true, value: t3 }) : r5[e3] = t3;
var Rr = (r5, e3) => {
  for (var t3 in e3 || (e3 = {}))
    Ir.call(e3, t3) && At2(r5, t3, e3[t3]);
  if (Ot)
    for (var t3 of Ot(e3))
      Cr.call(e3, t3) && At2(r5, t3, e3[t3]);
  return r5;
};
var zt2 = class extends g {
  constructor(e3) {
    super(e3), this.protocol = "wc", this.version = 2, this.events = new import_events5.EventEmitter(), this.name = ct2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t3) => {
      this.logger.debug("Publishing Request Payload");
      try {
        return await this.toEstablishConnection(), await this.provider.request(t3);
      } catch (i4) {
        throw this.logger.debug("Failed to Publish Request"), this.logger.error(i4), i4;
      }
    }, this.onPayloadHandler = (t3) => {
      this.onProviderPayload(t3);
    }, this.onConnectHandler = () => {
      this.events.emit(D3.connect);
    }, this.onDisconnectHandler = () => {
      this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t3) => {
      this.logger.error(t3), this.events.emit(D3.error, t3), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(T.payload, this.onPayloadHandler), this.provider.on(T.connect, this.onConnectHandler), this.provider.on(T.disconnect, this.onDisconnectHandler), this.provider.on(T.error, this.onProviderErrorHandler);
    }, this.core = e3.core, this.logger = typeof e3.logger < "u" && typeof e3.logger != "string" ? (0, import_logger.generateChildLogger)(e3.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e3.logger || ht2 })), this.messages = new St(this.logger, e3.core), this.subscriber = new xt2(this, this.logger), this.publisher = new Dr(this, this.logger), this.relayUrl = (e3 == null ? void 0 : e3.relayUrl) || de2, this.projectId = e3.projectId, this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
    try {
      await this.transportOpen();
    } catch {
      this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${ge}...`), await this.restartTransport(ge);
    }
    this.initialized = true, setTimeout(async () => {
      this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
    }, gt2);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get connected() {
    return this.provider.connection.connected;
  }
  get connecting() {
    return this.provider.connection.connecting;
  }
  async publish(e3, t3, i4) {
    this.isInitialized(), await this.publisher.publish(e3, t3, i4), await this.recordMessageEvent({ topic: e3, message: t3, publishedAt: Date.now() });
  }
  async subscribe(e3, t3) {
    var i4;
    this.isInitialized();
    let s3 = ((i4 = this.subscriber.topicMap.get(e3)) == null ? void 0 : i4[0]) || "";
    if (s3)
      return s3;
    let n3;
    const a4 = (o3) => {
      o3.topic === e3 && (this.subscriber.off(w2.created, a4), n3());
    };
    return await Promise.all([new Promise((o3) => {
      n3 = o3, this.subscriber.on(w2.created, a4);
    }), new Promise(async (o3) => {
      s3 = await this.subscriber.subscribe(e3, t3), o3();
    })]), s3;
  }
  async unsubscribe(e3, t3) {
    this.isInitialized(), await this.subscriber.unsubscribe(e3, t3);
  }
  on(e3, t3) {
    this.events.on(e3, t3);
  }
  once(e3, t3) {
    this.events.once(e3, t3);
  }
  off(e3, t3) {
    this.events.off(e3, t3);
  }
  removeListener(e3, t3) {
    this.events.removeListener(e3, t3);
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await it(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
  }
  async transportOpen(e3) {
    if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
      e3 && e3 !== this.relayUrl && (this.relayUrl = e3, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
      try {
        await Promise.all([new Promise((t3) => {
          if (!this.initialized)
            return t3();
          this.subscriber.once(w2.resubscribed, () => {
            t3();
          });
        }), new Promise(async (t3, i4) => {
          try {
            await it(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
          } catch (s3) {
            i4(s3);
            return;
          }
          t3();
        })]);
      } catch (t3) {
        this.logger.error(t3);
        const i4 = t3;
        if (!this.isConnectionStalled(i4.message))
          throw t3;
        this.provider.events.emit(T.disconnect);
      } finally {
        this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
      }
    }
  }
  async restartTransport(e3) {
    await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e3 || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Zt())
      throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  isConnectionStalled(e3) {
    return this.staleConnectionErrors.some((t3) => e3.includes(t3));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e3 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new JsonRpcProvider(new esm_default(Jn({ sdkVersion: dt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e3, useOnCloseEvent: true }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e3) {
    const { topic: t3, message: i4 } = e3;
    await this.messages.set(t3, i4);
  }
  async shouldIgnoreMessageEvent(e3) {
    const { topic: t3, message: i4 } = e3;
    if (!i4 || i4.length === 0)
      return this.logger.debug(`Ignoring invalid/empty message: ${i4}`), true;
    if (!await this.subscriber.isSubscribed(t3))
      return this.logger.debug(`Ignoring message for non-subscribed topic ${t3}`), true;
    const s3 = this.messages.has(t3, i4);
    return s3 && this.logger.debug(`Ignoring duplicate message: ${i4}`), s3;
  }
  async onProviderPayload(e3) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e3 }), isJsonRpcRequest(e3)) {
      if (!e3.method.endsWith(ut2))
        return;
      const t3 = e3.params, { topic: i4, message: s3, publishedAt: n3 } = t3.data, a4 = { topic: i4, message: s3, publishedAt: n3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Rr({ type: "event", event: t3.id }, a4)), this.events.emit(t3.id, a4), await this.acknowledgePayload(e3), await this.onMessageEvent(a4);
    } else
      isJsonRpcResponse(e3) && this.events.emit(D3.message_ack, e3);
  }
  async onMessageEvent(e3) {
    await this.shouldIgnoreMessageEvent(e3) || (this.events.emit(D3.message, e3), await this.recordMessageEvent(e3));
  }
  async acknowledgePayload(e3) {
    const t3 = formatJsonRpcResult(e3.id, true);
    await this.provider.connection.send(t3);
  }
  unregisterProviderListeners() {
    this.provider.off(T.payload, this.onPayloadHandler), this.provider.off(T.connect, this.onConnectHandler), this.provider.off(T.disconnect, this.onDisconnectHandler), this.provider.off(T.error, this.onProviderErrorHandler);
  }
  async registerEventListeners() {
    this.events.on(D3.connection_stalled, () => {
      this.restartTransport().catch((t3) => this.logger.error(t3));
    });
    let e3 = await Zt();
    Xt(async (t3) => {
      this.initialized && e3 !== t3 && (e3 = t3, t3 ? await this.restartTransport().catch((i4) => this.logger.error(i4)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i4) => this.logger.error(i4))));
    });
  }
  onProviderDisconnect() {
    this.events.emit(D3.disconnect), this.attemptToReconnect();
  }
  attemptToReconnect() {
    this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
      await this.restartTransport().catch((e3) => this.logger.error(e3));
    }, (0, import_time3.toMiliseconds)(lt2)));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectionAttemptInProgress)
        return await new Promise((e3) => {
          const t3 = setInterval(() => {
            this.connected && (clearInterval(t3), e3());
          }, this.connectionStatusPollingInterval);
        });
      await this.restartTransport();
    }
  }
};
var _r = Object.defineProperty;
var Nt2 = Object.getOwnPropertySymbols;
var Sr = Object.prototype.hasOwnProperty;
var Pr = Object.prototype.propertyIsEnumerable;
var Lt2 = (r5, e3, t3) => e3 in r5 ? _r(r5, e3, { enumerable: true, configurable: true, writable: true, value: t3 }) : r5[e3] = t3;
var Ut = (r5, e3) => {
  for (var t3 in e3 || (e3 = {}))
    Sr.call(e3, t3) && Lt2(r5, t3, e3[t3]);
  if (Nt2)
    for (var t3 of Nt2(e3))
      Pr.call(e3, t3) && Lt2(r5, t3, e3[t3]);
  return r5;
};
var Ft2 = class extends p2 {
  constructor(e3, t3, i4, s3 = O3, n3 = void 0) {
    super(e3, t3, i4, s3), this.core = e3, this.logger = t3, this.name = i4, this.map = /* @__PURE__ */ new Map(), this.version = pt2, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((a4) => {
        this.getKey && a4 !== null && !w(a4) ? this.map.set(this.getKey(a4), a4) : Dt(a4) ? this.map.set(a4.id, a4) : kt(a4) && this.map.set(a4.topic, a4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (a4, o3) => {
      this.isInitialized(), this.map.has(a4) ? await this.update(a4, o3) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: a4, value: o3 }), this.map.set(a4, o3), await this.persist());
    }, this.get = (a4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: a4 }), this.getData(a4)), this.getAll = (a4) => (this.isInitialized(), a4 ? this.values.filter((o3) => Object.keys(a4).every((h6) => (0, import_lodash.default)(o3[h6], a4[h6]))) : this.values), this.update = async (a4, o3) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: a4, update: o3 });
      const h6 = Ut(Ut({}, this.getData(a4)), o3);
      this.map.set(a4, h6), await this.persist();
    }, this.delete = async (a4, o3) => {
      this.isInitialized(), this.map.has(a4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: a4, reason: o3 }), this.map.delete(a4), await this.persist());
    }, this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.storagePrefix = s3, this.getKey = n3;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  async setDataStore(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e3) {
    const t3 = this.map.get(e3);
    if (!t3) {
      const { message: i4 } = N("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw this.logger.error(i4), new Error(i4);
    }
    return t3;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e3 = await this.getDataStore();
      if (typeof e3 > "u" || !e3.length)
        return;
      if (this.map.size) {
        const { message: t3 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), new Error(t3);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var $t2 = class {
  constructor(e3, t3) {
    this.core = e3, this.logger = t3, this.name = ft2, this.version = Et2, this.events = new import_events5.default(), this.initialized = false, this.storagePrefix = O3, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: i4 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i4])];
    }, this.create = async () => {
      this.isInitialized();
      const i4 = Dn(), s3 = await this.core.crypto.setSymKey(i4), n3 = lt(import_time3.FIVE_MINUTES), a4 = { protocol: ot }, o3 = { topic: s3, expiry: n3, relay: a4, active: false }, h6 = Nt({ protocol: this.core.protocol, version: this.core.version, topic: s3, symKey: i4, relay: a4 });
      return await this.pairings.set(s3, o3), await this.core.relayer.subscribe(s3), this.core.expirer.set(s3, n3), { topic: s3, uri: h6 };
    }, this.pair = async (i4) => {
      this.isInitialized(), this.isValidPair(i4);
      const { topic: s3, symKey: n3, relay: a4 } = bt(i4.uri);
      let o3;
      if (this.pairings.keys.includes(s3) && (o3 = this.pairings.get(s3), o3.active))
        throw new Error(`Pairing already exists: ${s3}. Please try again with a new connection URI.`);
      this.core.crypto.keychain.has(s3) || (await this.core.crypto.setSymKey(n3, s3), await this.core.relayer.subscribe(s3, { relay: a4 }));
      const h6 = lt(import_time3.FIVE_MINUTES), u5 = { topic: s3, relay: a4, expiry: h6, active: false };
      return await this.pairings.set(s3, u5), this.core.expirer.set(s3, h6), i4.activatePairing && await this.activate({ topic: s3 }), this.events.emit(B2.create, u5), u5;
    }, this.activate = async ({ topic: i4 }) => {
      this.isInitialized();
      const s3 = lt(import_time3.THIRTY_DAYS);
      await this.pairings.update(i4, { active: true, expiry: s3 }), this.core.expirer.set(i4, s3);
    }, this.ping = async (i4) => {
      this.isInitialized(), await this.isValidPing(i4);
      const { topic: s3 } = i4;
      if (this.pairings.keys.includes(s3)) {
        const n3 = await this.sendRequest(s3, "wc_pairingPing", {}), { done: a4, resolve: o3, reject: h6 } = st();
        this.events.once(ft("pairing_ping", n3), ({ error: u5 }) => {
          u5 ? h6(u5) : o3();
        }), await a4();
      }
    }, this.updateExpiry = async ({ topic: i4, expiry: s3 }) => {
      this.isInitialized(), await this.pairings.update(i4, { expiry: s3 });
    }, this.updateMetadata = async ({ topic: i4, metadata: s3 }) => {
      this.isInitialized(), await this.pairings.update(i4, { peerMetadata: s3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i4) => {
      this.isInitialized(), await this.isValidDisconnect(i4);
      const { topic: s3 } = i4;
      this.pairings.keys.includes(s3) && (await this.sendRequest(s3, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s3));
    }, this.sendRequest = async (i4, s3, n3) => {
      const a4 = formatJsonRpcRequest(s3, n3), o3 = await this.core.crypto.encode(i4, a4), h6 = F2[s3].req;
      return this.core.history.set(i4, a4), this.core.relayer.publish(i4, o3, h6), a4.id;
    }, this.sendResult = async (i4, s3, n3) => {
      const a4 = formatJsonRpcResult(i4, n3), o3 = await this.core.crypto.encode(s3, a4), h6 = await this.core.history.get(s3, i4), u5 = F2[h6.request.method].res;
      await this.core.relayer.publish(s3, o3, u5), await this.core.history.resolve(a4);
    }, this.sendError = async (i4, s3, n3) => {
      const a4 = formatJsonRpcError(i4, n3), o3 = await this.core.crypto.encode(s3, a4), h6 = await this.core.history.get(s3, i4), u5 = F2[h6.request.method] ? F2[h6.request.method].res : F2.unregistered_method.res;
      await this.core.relayer.publish(s3, o3, u5), await this.core.history.resolve(a4);
    }, this.deletePairing = async (i4, s3) => {
      await this.core.relayer.unsubscribe(i4), await Promise.all([this.pairings.delete(i4, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i4), s3 ? Promise.resolve() : this.core.expirer.del(i4)]);
    }, this.cleanup = async () => {
      const i4 = this.pairings.getAll().filter((s3) => dt(s3.expiry));
      await Promise.all(i4.map((s3) => this.deletePairing(s3.topic)));
    }, this.onRelayEventRequest = (i4) => {
      const { topic: s3, payload: n3 } = i4;
      switch (n3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(s3, n3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(s3, n3);
        default:
          return this.onUnknownRpcMethodRequest(s3, n3);
      }
    }, this.onRelayEventResponse = async (i4) => {
      const { topic: s3, payload: n3 } = i4, a4 = (await this.core.history.get(s3, n3.id)).request.method;
      switch (a4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s3, n3);
        default:
          return this.onUnknownRpcMethodResponse(a4);
      }
    }, this.onPairingPingRequest = async (i4, s3) => {
      const { id: n3 } = s3;
      try {
        this.isValidPing({ topic: i4 }), await this.sendResult(n3, i4, true), this.events.emit(B2.ping, { id: n3, topic: i4 });
      } catch (a4) {
        await this.sendError(n3, i4, a4), this.logger.error(a4);
      }
    }, this.onPairingPingResponse = (i4, s3) => {
      const { id: n3 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(ft("pairing_ping", n3), {}) : isJsonRpcError(s3) && this.events.emit(ft("pairing_ping", n3), { error: s3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (i4, s3) => {
      const { id: n3 } = s3;
      try {
        this.isValidDisconnect({ topic: i4 }), await this.deletePairing(i4), this.events.emit(B2.delete, { id: n3, topic: i4 });
      } catch (a4) {
        await this.sendError(n3, i4, a4), this.logger.error(a4);
      }
    }, this.onUnknownRpcMethodRequest = async (i4, s3) => {
      const { id: n3, method: a4 } = s3;
      try {
        if (this.registeredMethods.includes(a4))
          return;
        const o3 = U("WC_METHOD_UNSUPPORTED", a4);
        await this.sendError(n3, i4, o3), this.logger.error(o3);
      } catch (o3) {
        await this.sendError(n3, i4, o3), this.logger.error(o3);
      }
    }, this.onUnknownRpcMethodResponse = (i4) => {
      this.registeredMethods.includes(i4) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i4));
    }, this.isValidPair = (i4) => {
      if (!xt(i4)) {
        const { message: s3 } = N("MISSING_OR_INVALID", `pair() params: ${i4}`);
        throw new Error(s3);
      }
      if (!jt(i4.uri)) {
        const { message: s3 } = N("MISSING_OR_INVALID", `pair() uri: ${i4.uri}`);
        throw new Error(s3);
      }
    }, this.isValidPing = async (i4) => {
      if (!xt(i4)) {
        const { message: n3 } = N("MISSING_OR_INVALID", `ping() params: ${i4}`);
        throw new Error(n3);
      }
      const { topic: s3 } = i4;
      await this.isValidPairingTopic(s3);
    }, this.isValidDisconnect = async (i4) => {
      if (!xt(i4)) {
        const { message: n3 } = N("MISSING_OR_INVALID", `disconnect() params: ${i4}`);
        throw new Error(n3);
      }
      const { topic: s3 } = i4;
      await this.isValidPairingTopic(s3);
    }, this.isValidPairingTopic = async (i4) => {
      if (!h(i4, false)) {
        const { message: s3 } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i4}`);
        throw new Error(s3);
      }
      if (!this.pairings.keys.includes(i4)) {
        const { message: s3 } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i4}`);
        throw new Error(s3);
      }
      if (dt(this.pairings.get(i4).expiry)) {
        await this.deletePairing(i4);
        const { message: s3 } = N("EXPIRED", `pairing topic: ${i4}`);
        throw new Error(s3);
      }
    }, this.core = e3, this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.pairings = new Ft2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(D3.message, async (e3) => {
      const { topic: t3, message: i4 } = e3;
      if (!this.pairings.keys.includes(t3) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i4)))
        return;
      const s3 = await this.core.crypto.decode(t3, i4);
      try {
        isJsonRpcRequest(s3) ? (this.core.history.set(t3, s3), this.onRelayEventRequest({ topic: t3, payload: s3 })) : isJsonRpcResponse(s3) && (await this.core.history.resolve(s3), await this.onRelayEventResponse({ topic: t3, payload: s3 }), this.core.history.delete(t3, s3.id));
      } catch (n3) {
        this.logger.error(n3);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(v.expired, async (e3) => {
      const { topic: t3 } = ut(e3.target);
      t3 && this.pairings.keys.includes(t3) && (await this.deletePairing(t3, true), this.events.emit(B2.expire, { topic: t3 }));
    });
  }
};
var Mt2 = class extends h3 {
  constructor(e3, t3) {
    super(e3, t3), this.core = e3, this.logger = t3, this.records = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = wt, this.version = vt2, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.records.set(i4.id, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (i4, s3, n3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i4, request: s3, chainId: n3 }), this.records.has(s3.id))
        return;
      const a4 = { id: s3.id, topic: i4, request: { method: s3.method, params: s3.params || null }, chainId: n3, expiry: lt(import_time3.THIRTY_DAYS) };
      this.records.set(a4.id, a4), this.events.emit(R2.created, a4);
    }, this.resolve = async (i4) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i4 }), !this.records.has(i4.id))
        return;
      const s3 = await this.getRecord(i4.id);
      typeof s3.response > "u" && (s3.response = isJsonRpcError(i4) ? { error: i4.error } : { result: i4.result }, this.records.set(s3.id, s3), this.events.emit(R2.updated, s3));
    }, this.get = async (i4, s3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i4, id: s3 }), await this.getRecord(s3)), this.delete = (i4, s3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s3 }), this.values.forEach((n3) => {
        if (n3.topic === i4) {
          if (typeof s3 < "u" && n3.id !== s3)
            return;
          this.records.delete(n3.id), this.events.emit(R2.deleted, n3);
        }
      });
    }, this.exists = async (i4, s3) => (this.isInitialized(), this.records.has(s3) ? (await this.getRecord(s3)).topic === i4 : false), this.on = (i4, s3) => {
      this.events.on(i4, s3);
    }, this.once = (i4, s3) => {
      this.events.once(i4, s3);
    }, this.off = (i4, s3) => {
      this.events.off(i4, s3);
    }, this.removeListener = (i4, s3) => {
      this.events.removeListener(i4, s3);
    }, this.logger = (0, import_logger.generateChildLogger)(t3, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e3 = [];
    return this.values.forEach((t3) => {
      if (typeof t3.response < "u")
        return;
      const i4 = { topic: t3.topic, request: formatJsonRpcRequest(t3.request.method, t3.request.params, t3.id), chainId: t3.chainId };
      return e3.push(i4);
    }), e3;
  }
  async setJsonRpcRecords(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e3) {
    this.isInitialized();
    const t3 = this.records.get(e3);
    if (!t3) {
      const { message: i4 } = N("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw new Error(i4);
    }
    return t3;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(R2.sync);
  }
  async restore() {
    try {
      const e3 = await this.getJsonRpcRecords();
      if (typeof e3 > "u" || !e3.length)
        return;
      if (this.records.size) {
        const { message: t3 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), new Error(t3);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e3);
    }
  }
  registerEventListeners() {
    this.events.on(R2.created, (e3) => {
      const t3 = R2.created;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, record: e3 }), this.persist();
    }), this.events.on(R2.updated, (e3) => {
      const t3 = R2.updated;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, record: e3 }), this.persist();
    }), this.events.on(R2.deleted, (e3) => {
      const t3 = R2.deleted;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, record: e3 }), this.persist();
    }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.records.forEach((e3) => {
        (0, import_time3.toMiliseconds)(e3.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e3.id}`), this.delete(e3.topic, e3.id));
      });
    } catch (e3) {
      this.logger.warn(e3);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var kt2 = class extends E2 {
  constructor(e3, t3) {
    super(e3, t3), this.core = e3, this.logger = t3, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = It, this.version = Ct2, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i4) => this.expirations.set(i4.target, i4)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (i4) => {
      try {
        const s3 = this.formatTarget(i4);
        return typeof this.getExpiration(s3) < "u";
      } catch {
        return false;
      }
    }, this.set = (i4, s3) => {
      this.isInitialized();
      const n3 = this.formatTarget(i4), a4 = { target: n3, expiry: s3 };
      this.expirations.set(n3, a4), this.checkExpiry(n3, a4), this.events.emit(v.created, { target: n3, expiration: a4 });
    }, this.get = (i4) => {
      this.isInitialized();
      const s3 = this.formatTarget(i4);
      return this.getExpiration(s3);
    }, this.del = (i4) => {
      if (this.isInitialized(), this.has(i4)) {
        const s3 = this.formatTarget(i4), n3 = this.getExpiration(s3);
        this.expirations.delete(s3), this.events.emit(v.deleted, { target: s3, expiration: n3 });
      }
    }, this.on = (i4, s3) => {
      this.events.on(i4, s3);
    }, this.once = (i4, s3) => {
      this.events.once(i4, s3);
    }, this.off = (i4, s3) => {
      this.events.off(i4, s3);
    }, this.removeListener = (i4, s3) => {
      this.events.removeListener(i4, s3);
    }, this.logger = (0, import_logger.generateChildLogger)(t3, this.name);
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e3) {
    if (typeof e3 == "string")
      return ct(e3);
    if (typeof e3 == "number")
      return at(e3);
    const { message: t3 } = N("UNKNOWN_TYPE", `Target type: ${typeof e3}`);
    throw new Error(t3);
  }
  async setExpirations(e3) {
    await this.core.storage.setItem(this.storageKey, e3);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(v.sync);
  }
  async restore() {
    try {
      const e3 = await this.getExpirations();
      if (typeof e3 > "u" || !e3.length)
        return;
      if (this.expirations.size) {
        const { message: t3 } = N("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t3), new Error(t3);
      }
      this.cached = e3, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e3) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e3);
    }
  }
  getExpiration(e3) {
    const t3 = this.expirations.get(e3);
    if (!t3) {
      const { message: i4 } = N("NO_MATCHING_KEY", `${this.name}: ${e3}`);
      throw this.logger.error(i4), new Error(i4);
    }
    return t3;
  }
  checkExpiry(e3, t3) {
    const { expiry: i4 } = t3;
    (0, import_time3.toMiliseconds)(i4) - Date.now() <= 0 && this.expire(e3, t3);
  }
  expire(e3, t3) {
    this.expirations.delete(e3), this.events.emit(v.expired, { target: e3, expiration: t3 });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e3, t3) => this.checkExpiry(t3, e3));
  }
  registerEventListeners() {
    this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v.created, (e3) => {
      const t3 = v.created;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e3 }), this.persist();
    }), this.events.on(v.expired, (e3) => {
      const t3 = v.expired;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e3 }), this.persist();
    }), this.events.on(v.deleted, (e3) => {
      const t3 = v.deleted;
      this.logger.info(`Emitting ${t3}`), this.logger.debug({ type: "event", event: t3, data: e3 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e3 } = N("NOT_INITIALIZED", this.name);
      throw new Error(e3);
    }
  }
};
var Kt2 = class extends y2 {
  constructor(e3, t3) {
    super(e3, t3), this.projectId = e3, this.logger = t3, this.name = Q2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async () => {
      if (this.verifyDisabled || j() || !q())
        return;
      const i4 = Z2;
      this.verifyUrl !== i4 && this.removeIframe(), this.verifyUrl = i4;
      try {
        await this.createIframe();
      } catch (s3) {
        this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s3);
      }
      if (!this.initialized) {
        this.removeIframe(), this.verifyUrl = pe;
        try {
          await this.createIframe();
        } catch (s3) {
          this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(s3), this.verifyDisabled = true;
        }
      }
    }, this.register = async (i4) => {
      this.initialized ? this.sendPost(i4.attestationId) : (this.addToQueue(i4.attestationId), await this.init());
    }, this.resolve = async (i4) => {
      if (this.isDevEnv)
        return "";
      const s3 = (i4 == null ? void 0 : i4.verifyUrl) || Z2;
      let n3;
      try {
        n3 = await this.fetchAttestation(i4.attestationId, s3);
      } catch (a4) {
        this.logger.info(`failed to resolve attestation: ${i4.attestationId} from url: ${s3}`), this.logger.info(a4), n3 = await this.fetchAttestation(i4.attestationId, pe);
      }
      return n3;
    }, this.fetchAttestation = async (i4, s3) => {
      this.logger.info(`resolving attestation: ${i4} from url: ${s3}`);
      const n3 = this.startAbortTimer(import_time3.ONE_SECOND * 2), a4 = await fetch(`${s3}/attestation/${i4}`, { signal: this.abortController.signal });
      return clearTimeout(n3), a4.status === 200 ? await a4.json() : void 0;
    }, this.addToQueue = (i4) => {
      this.queue.push(i4);
    }, this.processQueue = () => {
      this.queue.length !== 0 && (this.queue.forEach((i4) => this.sendPost(i4)), this.queue = []);
    }, this.sendPost = (i4) => {
      var s3;
      try {
        if (!this.iframe)
          return;
        (s3 = this.iframe.contentWindow) == null || s3.postMessage(i4, "*"), this.logger.info(`postMessage sent: ${i4} ${this.verifyUrl}`);
      } catch {
      }
    }, this.createIframe = async () => {
      let i4;
      const s3 = (n3) => {
        n3.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s3), i4());
      };
      await Promise.race([new Promise((n3) => {
        if (document.getElementById(Q2))
          return n3();
        window.addEventListener("message", s3);
        const a4 = document.createElement("iframe");
        a4.id = Q2, a4.src = `${this.verifyUrl}/${this.projectId}`, a4.style.display = "none", document.body.append(a4), this.iframe = a4, i4 = n3;
      }), new Promise((n3, a4) => setTimeout(() => {
        window.removeEventListener("message", s3), a4("verify iframe load timeout");
      }, (0, import_time3.toMiliseconds)(import_time3.FIVE_SECONDS)))]);
    }, this.removeIframe = () => {
      this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
    }, this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.verifyUrl = Z2, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  startAbortTimer(e3) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time3.toMiliseconds)(e3));
  }
};
var Tr = Object.defineProperty;
var Bt2 = Object.getOwnPropertySymbols;
var xr = Object.prototype.hasOwnProperty;
var Or = Object.prototype.propertyIsEnumerable;
var Vt2 = (r5, e3, t3) => e3 in r5 ? Tr(r5, e3, { enumerable: true, configurable: true, writable: true, value: t3 }) : r5[e3] = t3;
var qt2 = (r5, e3) => {
  for (var t3 in e3 || (e3 = {}))
    xr.call(e3, t3) && Vt2(r5, t3, e3[t3]);
  if (Bt2)
    for (var t3 of Bt2(e3))
      Or.call(e3, t3) && Vt2(r5, t3, e3[t3]);
  return r5;
};
var ee2 = class _ee extends n {
  constructor(e3) {
    super(e3), this.protocol = ue2, this.version = We2, this.name = X2, this.events = new import_events5.EventEmitter(), this.initialized = false, this.on = (i4, s3) => this.events.on(i4, s3), this.once = (i4, s3) => this.events.once(i4, s3), this.off = (i4, s3) => this.events.off(i4, s3), this.removeListener = (i4, s3) => this.events.removeListener(i4, s3), this.projectId = e3 == null ? void 0 : e3.projectId, this.relayUrl = (e3 == null ? void 0 : e3.relayUrl) || de2, this.customStoragePrefix = e3 != null && e3.customStoragePrefix ? `:${e3.customStoragePrefix}` : "";
    const t3 = typeof (e3 == null ? void 0 : e3.logger) < "u" && typeof (e3 == null ? void 0 : e3.logger) != "string" ? e3.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: (e3 == null ? void 0 : e3.logger) || Xe2.logger }));
    this.logger = (0, import_logger.generateChildLogger)(t3, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new _t2(this, this.logger, e3 == null ? void 0 : e3.keychain), this.history = new Mt2(this, this.logger), this.expirer = new kt2(this, this.logger), this.storage = e3 != null && e3.storage ? e3.storage : new h2(qt2(qt2({}, Qe2), e3 == null ? void 0 : e3.storageOptions)), this.relayer = new zt2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new $t2(this, this.logger), this.verify = new Kt2(this.projectId || "", this.logger);
  }
  static async init(e3) {
    const t3 = new _ee(e3);
    await t3.initialize();
    const i4 = await t3.crypto.getClientId();
    return await t3.storage.setItem(Dt2, i4), t3;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e3) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e3), this.logger.error(e3.message), e3;
    }
  }
};
var Ar = ee2;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_logger2 = __toESM(require_cjs5());
var import_events6 = __toESM(require_events());
var import_time4 = __toESM(require_cjs());
var X3 = "wc";
var F3 = 2;
var H = "client";
var G2 = `${X3}@${F3}:${H}:`;
var M2 = { name: H, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var W3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var ne = "proposal";
var oe3 = "Proposal expired";
var ae2 = "session";
var A2 = import_time4.SEVEN_DAYS;
var ce3 = "engine";
var V3 = { wc_sessionPropose: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time4.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time4.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
var U3 = { min: import_time4.FIVE_MINUTES, max: import_time4.SEVEN_DAYS };
var I = { idle: "IDLE", active: "ACTIVE" };
var le3 = "request";
var pe2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
var ns2 = Object.defineProperty;
var os2 = Object.defineProperties;
var as2 = Object.getOwnPropertyDescriptors;
var he3 = Object.getOwnPropertySymbols;
var cs2 = Object.prototype.hasOwnProperty;
var ls2 = Object.prototype.propertyIsEnumerable;
var de3 = (m5, r5, e3) => r5 in m5 ? ns2(m5, r5, { enumerable: true, configurable: true, writable: true, value: e3 }) : m5[r5] = e3;
var g3 = (m5, r5) => {
  for (var e3 in r5 || (r5 = {}))
    cs2.call(r5, e3) && de3(m5, e3, r5[e3]);
  if (he3)
    for (var e3 of he3(r5))
      ls2.call(r5, e3) && de3(m5, e3, r5[e3]);
  return m5;
};
var b2 = (m5, r5) => os2(m5, as2(r5));
var ps2 = class extends S2 {
  constructor(r5) {
    super(r5), this.name = ce3, this.events = new import_events6.default(), this.initialized = false, this.ignoredPayloadTypes = [_], this.requestQueue = { state: I.idle, queue: [] }, this.sessionRequestQueue = { state: I.idle, queue: [] }, this.requestQueueDelay = import_time4.ONE_SECOND, this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(V3) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e3) => {
      await this.isInitialized();
      const s3 = b2(g3({}, e3), { requiredNamespaces: e3.requiredNamespaces || {}, optionalNamespaces: e3.optionalNamespaces || {} });
      await this.isValidConnect(s3);
      const { pairingTopic: t3, requiredNamespaces: i4, optionalNamespaces: n3, sessionProperties: o3, relays: a4 } = s3;
      let c5 = t3, p6, d4 = false;
      if (c5 && (d4 = this.client.core.pairing.pairings.get(c5).active), !c5 || !d4) {
        const { topic: v5, uri: S5 } = await this.client.core.pairing.create();
        c5 = v5, p6 = S5;
      }
      const h6 = await this.client.core.crypto.generateKeyPair(), R3 = g3({ requiredNamespaces: i4, optionalNamespaces: n3, relays: a4 ?? [{ protocol: ot }], proposer: { publicKey: h6, metadata: this.client.metadata } }, o3 && { sessionProperties: o3 }), { reject: w5, resolve: T4, done: K4 } = st(import_time4.FIVE_MINUTES, oe3);
      if (this.events.once(ft("session_connect"), async ({ error: v5, session: S5 }) => {
        if (v5)
          w5(v5);
        else if (S5) {
          S5.self.publicKey = h6;
          const B5 = b2(g3({}, S5), { requiredNamespaces: S5.requiredNamespaces, optionalNamespaces: S5.optionalNamespaces });
          await this.client.session.set(S5.topic, B5), await this.setExpiry(S5.topic, S5.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S5.peer.metadata }), T4(B5);
        }
      }), !c5) {
        const { message: v5 } = N("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(v5);
      }
      const L4 = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: R3 }), ue3 = lt(import_time4.FIVE_MINUTES);
      return await this.setProposal(L4, g3({ id: L4, expiry: ue3 }, R3)), { uri: p6, approval: K4 };
    }, this.pair = async (e3) => (await this.isInitialized(), await this.client.core.pairing.pair(e3)), this.approve = async (e3) => {
      await this.isInitialized(), await this.isValidApprove(e3);
      const { id: s3, relayProtocol: t3, namespaces: i4, sessionProperties: n3 } = e3, o3 = this.client.proposal.get(s3);
      let { pairingTopic: a4, proposer: c5, requiredNamespaces: p6, optionalNamespaces: d4 } = o3;
      a4 = a4 || "", B(p6) || (p6 = At(i4, "approve()"));
      const h6 = await this.client.core.crypto.generateKeyPair(), R3 = c5.publicKey, w5 = await this.client.core.crypto.generateSharedKey(h6, R3);
      a4 && s3 && (await this.client.core.pairing.updateMetadata({ topic: a4, metadata: c5.metadata }), await this.sendResult({ id: s3, topic: a4, result: { relay: { protocol: t3 ?? "irn" }, responderPublicKey: h6 } }), await this.client.proposal.delete(s3, U("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a4 }));
      const T4 = g3({ relay: { protocol: t3 ?? "irn" }, namespaces: i4, requiredNamespaces: p6, optionalNamespaces: d4, pairingTopic: a4, controller: { publicKey: h6, metadata: this.client.metadata }, expiry: lt(A2) }, n3 && { sessionProperties: n3 });
      await this.client.core.relayer.subscribe(w5), await this.sendRequest({ topic: w5, method: "wc_sessionSettle", params: T4, throwOnFailedPublish: true });
      const K4 = b2(g3({}, T4), { topic: w5, pairingTopic: a4, acknowledged: false, self: T4.controller, peer: { publicKey: c5.publicKey, metadata: c5.metadata }, controller: h6 });
      return await this.client.session.set(w5, K4), await this.setExpiry(w5, lt(A2)), { topic: w5, acknowledged: () => new Promise((L4) => setTimeout(() => L4(this.client.session.get(w5)), 500)) };
    }, this.reject = async (e3) => {
      await this.isInitialized(), await this.isValidReject(e3);
      const { id: s3, reason: t3 } = e3, { pairingTopic: i4 } = this.client.proposal.get(s3);
      i4 && (await this.sendError(s3, i4, t3), await this.client.proposal.delete(s3, U("USER_DISCONNECTED")));
    }, this.update = async (e3) => {
      await this.isInitialized(), await this.isValidUpdate(e3);
      const { topic: s3, namespaces: t3 } = e3, i4 = await this.sendRequest({ topic: s3, method: "wc_sessionUpdate", params: { namespaces: t3 } }), { done: n3, resolve: o3, reject: a4 } = st();
      return this.events.once(ft("session_update", i4), ({ error: c5 }) => {
        c5 ? a4(c5) : o3();
      }), await this.client.session.update(s3, { namespaces: t3 }), { acknowledged: n3 };
    }, this.extend = async (e3) => {
      await this.isInitialized(), await this.isValidExtend(e3);
      const { topic: s3 } = e3, t3 = await this.sendRequest({ topic: s3, method: "wc_sessionExtend", params: {} }), { done: i4, resolve: n3, reject: o3 } = st();
      return this.events.once(ft("session_extend", t3), ({ error: a4 }) => {
        a4 ? o3(a4) : n3();
      }), await this.setExpiry(s3, lt(A2)), { acknowledged: i4 };
    }, this.request = async (e3) => {
      await this.isInitialized(), await this.isValidRequest(e3);
      const { chainId: s3, request: t3, topic: i4, expiry: n3 } = e3, o3 = payloadId(), { done: a4, resolve: c5, reject: p6 } = st(n3, "Request expired. Please try again.");
      return this.events.once(ft("session_request", o3), ({ error: d4, result: h6 }) => {
        d4 ? p6(d4) : c5(h6);
      }), await Promise.all([new Promise(async (d4) => {
        await this.sendRequest({ clientRpcId: o3, topic: i4, method: "wc_sessionRequest", params: { request: t3, chainId: s3 }, expiry: n3, throwOnFailedPublish: true }).catch((h6) => p6(h6)), this.client.events.emit("session_request_sent", { topic: i4, request: t3, chainId: s3, id: o3 }), d4();
      }), new Promise(async (d4) => {
        const h6 = await this.client.core.storage.getItem(W3);
        pt({ id: o3, topic: i4, wcDeepLink: h6 }), d4();
      }), a4()]).then((d4) => d4[2]);
    }, this.respond = async (e3) => {
      await this.isInitialized(), await this.isValidRespond(e3);
      const { topic: s3, response: t3 } = e3, { id: i4 } = t3;
      isJsonRpcResult(t3) ? await this.sendResult({ id: i4, topic: s3, result: t3.result, throwOnFailedPublish: true }) : isJsonRpcError(t3) && await this.sendError(i4, s3, t3.error), this.cleanupAfterResponse(e3);
    }, this.ping = async (e3) => {
      await this.isInitialized(), await this.isValidPing(e3);
      const { topic: s3 } = e3;
      if (this.client.session.keys.includes(s3)) {
        const t3 = await this.sendRequest({ topic: s3, method: "wc_sessionPing", params: {} }), { done: i4, resolve: n3, reject: o3 } = st();
        this.events.once(ft("session_ping", t3), ({ error: a4 }) => {
          a4 ? o3(a4) : n3();
        }), await i4();
      } else
        this.client.core.pairing.pairings.keys.includes(s3) && await this.client.core.pairing.ping({ topic: s3 });
    }, this.emit = async (e3) => {
      await this.isInitialized(), await this.isValidEmit(e3);
      const { topic: s3, event: t3, chainId: i4 } = e3;
      await this.sendRequest({ topic: s3, method: "wc_sessionEvent", params: { event: t3, chainId: i4 } });
    }, this.disconnect = async (e3) => {
      await this.isInitialized(), await this.isValidDisconnect(e3);
      const { topic: s3 } = e3;
      this.client.session.keys.includes(s3) ? (await this.sendRequest({ topic: s3, method: "wc_sessionDelete", params: U("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s3)) : await this.client.core.pairing.disconnect({ topic: s3 });
    }, this.find = (e3) => (this.isInitialized(), this.client.session.getAll().filter((s3) => $t(s3, e3))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e3) => {
      if (e3.pairingTopic)
        try {
          const s3 = this.client.core.pairing.pairings.get(e3.pairingTopic), t3 = this.client.core.pairing.pairings.getAll().filter((i4) => {
            var n3, o3;
            return ((n3 = i4.peerMetadata) == null ? void 0 : n3.url) && ((o3 = i4.peerMetadata) == null ? void 0 : o3.url) === e3.peer.metadata.url && i4.topic && i4.topic !== s3.topic;
          });
          if (t3.length === 0)
            return;
          this.client.logger.info(`Cleaning up ${t3.length} duplicate pairing(s)`), await Promise.all(t3.map((i4) => this.client.core.pairing.disconnect({ topic: i4.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
        } catch (s3) {
          this.client.logger.error(s3);
        }
    }, this.deleteSession = async (e3, s3) => {
      const { self: t3 } = this.client.session.get(e3);
      await this.client.core.relayer.unsubscribe(e3), this.client.session.delete(e3, U("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t3.publicKey) && await this.client.core.crypto.deleteKeyPair(t3.publicKey), this.client.core.crypto.keychain.has(e3) && await this.client.core.crypto.deleteSymKey(e3), s3 || this.client.core.expirer.del(e3), this.client.core.storage.removeItem(W3).catch((i4) => this.client.logger.warn(i4));
    }, this.deleteProposal = async (e3, s3) => {
      await Promise.all([this.client.proposal.delete(e3, U("USER_DISCONNECTED")), s3 ? Promise.resolve() : this.client.core.expirer.del(e3)]);
    }, this.deletePendingSessionRequest = async (e3, s3, t3 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e3, s3), t3 ? Promise.resolve() : this.client.core.expirer.del(e3)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i4) => i4.id !== e3), t3 && (this.sessionRequestQueue.state = I.idle);
    }, this.setExpiry = async (e3, s3) => {
      this.client.session.keys.includes(e3) && await this.client.session.update(e3, { expiry: s3 }), this.client.core.expirer.set(e3, s3);
    }, this.setProposal = async (e3, s3) => {
      await this.client.proposal.set(e3, s3), this.client.core.expirer.set(e3, s3.expiry);
    }, this.setPendingSessionRequest = async (e3) => {
      const s3 = V3.wc_sessionRequest.req.ttl, { id: t3, topic: i4, params: n3, verifyContext: o3 } = e3;
      await this.client.pendingRequest.set(t3, { id: t3, topic: i4, params: n3, verifyContext: o3 }), s3 && this.client.core.expirer.set(t3, lt(s3));
    }, this.sendRequest = async (e3) => {
      const { topic: s3, method: t3, params: i4, expiry: n3, relayRpcId: o3, clientRpcId: a4, throwOnFailedPublish: c5 } = e3, p6 = formatJsonRpcRequest(t3, i4, a4);
      if (q() && pe2.includes(t3)) {
        const R3 = Mn(JSON.stringify(p6));
        this.client.core.verify.register({ attestationId: R3 });
      }
      const d4 = await this.client.core.crypto.encode(s3, p6), h6 = V3[t3].req;
      return n3 && (h6.ttl = n3), o3 && (h6.id = o3), this.client.core.history.set(s3, p6), c5 ? (h6.internal = b2(g3({}, h6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s3, d4, h6)) : this.client.core.relayer.publish(s3, d4, h6).catch((R3) => this.client.logger.error(R3)), p6.id;
    }, this.sendResult = async (e3) => {
      const { id: s3, topic: t3, result: i4, throwOnFailedPublish: n3 } = e3, o3 = formatJsonRpcResult(s3, i4), a4 = await this.client.core.crypto.encode(t3, o3), c5 = await this.client.core.history.get(t3, s3), p6 = V3[c5.request.method].res;
      n3 ? (p6.internal = b2(g3({}, p6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t3, a4, p6)) : this.client.core.relayer.publish(t3, a4, p6).catch((d4) => this.client.logger.error(d4)), await this.client.core.history.resolve(o3);
    }, this.sendError = async (e3, s3, t3) => {
      const i4 = formatJsonRpcError(e3, t3), n3 = await this.client.core.crypto.encode(s3, i4), o3 = await this.client.core.history.get(s3, e3), a4 = V3[o3.request.method].res;
      this.client.core.relayer.publish(s3, n3, a4), await this.client.core.history.resolve(i4);
    }, this.cleanup = async () => {
      const e3 = [], s3 = [];
      this.client.session.getAll().forEach((t3) => {
        dt(t3.expiry) && e3.push(t3.topic);
      }), this.client.proposal.getAll().forEach((t3) => {
        dt(t3.expiry) && s3.push(t3.id);
      }), await Promise.all([...e3.map((t3) => this.deleteSession(t3)), ...s3.map((t3) => this.deleteProposal(t3))]);
    }, this.onRelayEventRequest = async (e3) => {
      this.requestQueue.queue.push(e3), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === I.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = I.active;
        const e3 = this.requestQueue.queue.shift();
        if (e3)
          try {
            this.processRequest(e3), await new Promise((s3) => setTimeout(s3, 300));
          } catch (s3) {
            this.client.logger.warn(s3);
          }
      }
      this.requestQueue.state = I.idle;
    }, this.processRequest = (e3) => {
      const { topic: s3, payload: t3 } = e3, i4 = t3.method;
      switch (i4) {
        case "wc_sessionPropose":
          return this.onSessionProposeRequest(s3, t3);
        case "wc_sessionSettle":
          return this.onSessionSettleRequest(s3, t3);
        case "wc_sessionUpdate":
          return this.onSessionUpdateRequest(s3, t3);
        case "wc_sessionExtend":
          return this.onSessionExtendRequest(s3, t3);
        case "wc_sessionPing":
          return this.onSessionPingRequest(s3, t3);
        case "wc_sessionDelete":
          return this.onSessionDeleteRequest(s3, t3);
        case "wc_sessionRequest":
          return this.onSessionRequest(s3, t3);
        case "wc_sessionEvent":
          return this.onSessionEventRequest(s3, t3);
        default:
          return this.client.logger.info(`Unsupported request method ${i4}`);
      }
    }, this.onRelayEventResponse = async (e3) => {
      const { topic: s3, payload: t3 } = e3, i4 = (await this.client.core.history.get(s3, t3.id)).request.method;
      switch (i4) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(s3, t3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(s3, t3);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(s3, t3);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(s3, t3);
        case "wc_sessionPing":
          return this.onSessionPingResponse(s3, t3);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(s3, t3);
        default:
          return this.client.logger.info(`Unsupported response method ${i4}`);
      }
    }, this.onRelayEventUnknownPayload = (e3) => {
      const { topic: s3 } = e3, { message: t3 } = N("MISSING_OR_INVALID", `Decoded payload on topic ${s3} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(t3);
    }, this.onSessionProposeRequest = async (e3, s3) => {
      const { params: t3, id: i4 } = s3;
      try {
        this.isValidConnect(g3({}, s3.params));
        const n3 = lt(import_time4.FIVE_MINUTES), o3 = g3({ id: i4, pairingTopic: e3, expiry: n3 }, t3);
        await this.setProposal(i4, o3);
        const a4 = Mn(JSON.stringify(s3)), c5 = await this.getVerifyContext(a4, o3.proposer.metadata);
        this.client.events.emit("session_proposal", { id: i4, params: o3, verifyContext: c5 });
      } catch (n3) {
        await this.sendError(i4, e3, n3), this.client.logger.error(n3);
      }
    }, this.onSessionProposeResponse = async (e3, s3) => {
      const { id: t3 } = s3;
      if (isJsonRpcResult(s3)) {
        const { result: i4 } = s3;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i4 });
        const n3 = this.client.proposal.get(t3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n3 });
        const o3 = n3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o3 });
        const a4 = i4.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a4 });
        const c5 = await this.client.core.crypto.generateSharedKey(o3, a4);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c5 });
        const p6 = await this.client.core.relayer.subscribe(c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p6 }), await this.client.core.pairing.activate({ topic: e3 });
      } else
        isJsonRpcError(s3) && (await this.client.proposal.delete(t3, U("USER_DISCONNECTED")), this.events.emit(ft("session_connect"), { error: s3.error }));
    }, this.onSessionSettleRequest = async (e3, s3) => {
      const { id: t3, params: i4 } = s3;
      try {
        this.isValidSessionSettleRequest(i4);
        const { relay: n3, controller: o3, expiry: a4, namespaces: c5, requiredNamespaces: p6, optionalNamespaces: d4, sessionProperties: h6, pairingTopic: R3 } = s3.params, w5 = g3({ topic: e3, relay: n3, expiry: a4, namespaces: c5, acknowledged: true, pairingTopic: R3, requiredNamespaces: p6, optionalNamespaces: d4, controller: o3.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, h6 && { sessionProperties: h6 });
        await this.sendResult({ id: s3.id, topic: e3, result: true }), this.events.emit(ft("session_connect"), { session: w5 }), this.cleanupDuplicatePairings(w5);
      } catch (n3) {
        await this.sendError(t3, e3, n3), this.client.logger.error(n3);
      }
    }, this.onSessionSettleResponse = async (e3, s3) => {
      const { id: t3 } = s3;
      isJsonRpcResult(s3) ? (await this.client.session.update(e3, { acknowledged: true }), this.events.emit(ft("session_approve", t3), {})) : isJsonRpcError(s3) && (await this.client.session.delete(e3, U("USER_DISCONNECTED")), this.events.emit(ft("session_approve", t3), { error: s3.error }));
    }, this.onSessionUpdateRequest = async (e3, s3) => {
      const { params: t3, id: i4 } = s3;
      try {
        const n3 = `${e3}_session_update`, o3 = er.get(n3);
        if (o3 && this.isRequestOutOfSync(o3, i4)) {
          this.client.logger.info(`Discarding out of sync request - ${i4}`);
          return;
        }
        this.isValidUpdate(g3({ topic: e3 }, t3)), await this.client.session.update(e3, { namespaces: t3.namespaces }), await this.sendResult({ id: i4, topic: e3, result: true }), this.client.events.emit("session_update", { id: i4, topic: e3, params: t3 }), er.set(n3, i4);
      } catch (n3) {
        await this.sendError(i4, e3, n3), this.client.logger.error(n3);
      }
    }, this.isRequestOutOfSync = (e3, s3) => parseInt(s3.toString().slice(0, -3)) <= parseInt(e3.toString().slice(0, -3)), this.onSessionUpdateResponse = (e3, s3) => {
      const { id: t3 } = s3;
      isJsonRpcResult(s3) ? this.events.emit(ft("session_update", t3), {}) : isJsonRpcError(s3) && this.events.emit(ft("session_update", t3), { error: s3.error });
    }, this.onSessionExtendRequest = async (e3, s3) => {
      const { id: t3 } = s3;
      try {
        this.isValidExtend({ topic: e3 }), await this.setExpiry(e3, lt(A2)), await this.sendResult({ id: t3, topic: e3, result: true }), this.client.events.emit("session_extend", { id: t3, topic: e3 });
      } catch (i4) {
        await this.sendError(t3, e3, i4), this.client.logger.error(i4);
      }
    }, this.onSessionExtendResponse = (e3, s3) => {
      const { id: t3 } = s3;
      isJsonRpcResult(s3) ? this.events.emit(ft("session_extend", t3), {}) : isJsonRpcError(s3) && this.events.emit(ft("session_extend", t3), { error: s3.error });
    }, this.onSessionPingRequest = async (e3, s3) => {
      const { id: t3 } = s3;
      try {
        this.isValidPing({ topic: e3 }), await this.sendResult({ id: t3, topic: e3, result: true }), this.client.events.emit("session_ping", { id: t3, topic: e3 });
      } catch (i4) {
        await this.sendError(t3, e3, i4), this.client.logger.error(i4);
      }
    }, this.onSessionPingResponse = (e3, s3) => {
      const { id: t3 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(ft("session_ping", t3), {}) : isJsonRpcError(s3) && this.events.emit(ft("session_ping", t3), { error: s3.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e3, s3) => {
      const { id: t3 } = s3;
      try {
        this.isValidDisconnect({ topic: e3, reason: s3.params }), await Promise.all([new Promise((i4) => {
          this.client.core.relayer.once(D3.publish, async () => {
            i4(await this.deleteSession(e3));
          });
        }), this.sendResult({ id: t3, topic: e3, result: true })]), this.client.events.emit("session_delete", { id: t3, topic: e3 });
      } catch (i4) {
        this.client.logger.error(i4);
      }
    }, this.onSessionRequest = async (e3, s3) => {
      const { id: t3, params: i4 } = s3;
      try {
        this.isValidRequest(g3({ topic: e3 }, i4));
        const n3 = Mn(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i4, t3))), o3 = this.client.session.get(e3), a4 = await this.getVerifyContext(n3, o3.peer.metadata), c5 = { id: t3, topic: e3, params: i4, verifyContext: a4 };
        await this.setPendingSessionRequest(c5), this.addSessionRequestToSessionRequestQueue(c5), this.processSessionRequestQueue();
      } catch (n3) {
        await this.sendError(t3, e3, n3), this.client.logger.error(n3);
      }
    }, this.onSessionRequestResponse = (e3, s3) => {
      const { id: t3 } = s3;
      isJsonRpcResult(s3) ? this.events.emit(ft("session_request", t3), { result: s3.result }) : isJsonRpcError(s3) && this.events.emit(ft("session_request", t3), { error: s3.error });
    }, this.onSessionEventRequest = async (e3, s3) => {
      const { id: t3, params: i4 } = s3;
      try {
        const n3 = `${e3}_session_event_${i4.event.name}`, o3 = er.get(n3);
        if (o3 && this.isRequestOutOfSync(o3, t3)) {
          this.client.logger.info(`Discarding out of sync request - ${t3}`);
          return;
        }
        this.isValidEmit(g3({ topic: e3 }, i4)), this.client.events.emit("session_event", { id: t3, topic: e3, params: i4 }), er.set(n3, t3);
      } catch (n3) {
        await this.sendError(t3, e3, n3), this.client.logger.error(n3);
      }
    }, this.addSessionRequestToSessionRequestQueue = (e3) => {
      this.sessionRequestQueue.queue.push(e3);
    }, this.cleanupAfterResponse = (e3) => {
      this.deletePendingSessionRequest(e3.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = I.idle, this.processSessionRequestQueue();
      }, (0, import_time4.toMiliseconds)(this.requestQueueDelay));
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === I.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e3 = this.sessionRequestQueue.queue[0];
      if (!e3) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = I.active, this.client.events.emit("session_request", e3);
      } catch (s3) {
        this.client.logger.error(s3);
      }
    }, this.onPairingCreated = (e3) => {
      if (e3.active)
        return;
      const s3 = this.client.proposal.getAll().find((t3) => t3.pairingTopic === e3.topic);
      s3 && this.onSessionProposeRequest(e3.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s3.requiredNamespaces, optionalNamespaces: s3.optionalNamespaces, relays: s3.relays, proposer: s3.proposer }, s3.id));
    }, this.isValidConnect = async (e3) => {
      if (!xt(e3)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e3)}`);
        throw new Error(a4);
      }
      const { pairingTopic: s3, requiredNamespaces: t3, optionalNamespaces: i4, sessionProperties: n3, relays: o3 } = e3;
      if (w(s3) || await this.isValidPairingTopic(s3), !Kt(o3, true)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `connect() relays: ${o3}`);
        throw new Error(a4);
      }
      !w(t3) && B(t3) !== 0 && this.validateNamespaces(t3, "requiredNamespaces"), !w(i4) && B(i4) !== 0 && this.validateNamespaces(i4, "optionalNamespaces"), w(n3) || this.validateSessionProps(n3, "sessionProperties");
    }, this.validateNamespaces = (e3, s3) => {
      const t3 = Mt(e3, "connect()", s3);
      if (t3)
        throw new Error(t3.message);
    }, this.isValidApprove = async (e3) => {
      if (!xt(e3))
        throw new Error(N("MISSING_OR_INVALID", `approve() params: ${e3}`).message);
      const { id: s3, namespaces: t3, relayProtocol: i4, sessionProperties: n3 } = e3;
      await this.isValidProposalId(s3);
      const o3 = this.client.proposal.get(s3), a4 = cn(t3, "approve()");
      if (a4)
        throw new Error(a4.message);
      const c5 = un(o3.requiredNamespaces, t3, "approve()");
      if (c5)
        throw new Error(c5.message);
      if (!h(i4, true)) {
        const { message: p6 } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${i4}`);
        throw new Error(p6);
      }
      w(n3) || this.validateSessionProps(n3, "sessionProperties");
    }, this.isValidReject = async (e3) => {
      if (!xt(e3)) {
        const { message: i4 } = N("MISSING_OR_INVALID", `reject() params: ${e3}`);
        throw new Error(i4);
      }
      const { id: s3, reason: t3 } = e3;
      if (await this.isValidProposalId(s3), !Ft(t3)) {
        const { message: i4 } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t3)}`);
        throw new Error(i4);
      }
    }, this.isValidSessionSettleRequest = (e3) => {
      if (!xt(e3)) {
        const { message: c5 } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e3}`);
        throw new Error(c5);
      }
      const { relay: s3, controller: t3, namespaces: i4, expiry: n3 } = e3;
      if (!an(s3)) {
        const { message: c5 } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const o3 = Vt(t3, "onSessionSettleRequest()");
      if (o3)
        throw new Error(o3.message);
      const a4 = cn(i4, "onSessionSettleRequest()");
      if (a4)
        throw new Error(a4.message);
      if (dt(n3)) {
        const { message: c5 } = N("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e3) => {
      if (!xt(e3)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `update() params: ${e3}`);
        throw new Error(a4);
      }
      const { topic: s3, namespaces: t3 } = e3;
      await this.isValidSessionTopic(s3);
      const i4 = this.client.session.get(s3), n3 = cn(t3, "update()");
      if (n3)
        throw new Error(n3.message);
      const o3 = un(i4.requiredNamespaces, t3, "update()");
      if (o3)
        throw new Error(o3.message);
    }, this.isValidExtend = async (e3) => {
      if (!xt(e3)) {
        const { message: t3 } = N("MISSING_OR_INVALID", `extend() params: ${e3}`);
        throw new Error(t3);
      }
      const { topic: s3 } = e3;
      await this.isValidSessionTopic(s3);
    }, this.isValidRequest = async (e3) => {
      if (!xt(e3)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `request() params: ${e3}`);
        throw new Error(a4);
      }
      const { topic: s3, request: t3, chainId: i4, expiry: n3 } = e3;
      await this.isValidSessionTopic(s3);
      const { namespaces: o3 } = this.client.session.get(s3);
      if (!Gt(o3, i4)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `request() chainId: ${i4}`);
        throw new Error(a4);
      }
      if (!Ht(t3)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(t3)}`);
        throw new Error(a4);
      }
      if (!Wt(o3, i4, t3.method)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `request() method: ${t3.method}`);
        throw new Error(a4);
      }
      if (n3 && !Qt(n3, U3)) {
        const { message: a4 } = N("MISSING_OR_INVALID", `request() expiry: ${n3}. Expiry must be a number (in seconds) between ${U3.min} and ${U3.max}`);
        throw new Error(a4);
      }
    }, this.isValidRespond = async (e3) => {
      if (!xt(e3)) {
        const { message: i4 } = N("MISSING_OR_INVALID", `respond() params: ${e3}`);
        throw new Error(i4);
      }
      const { topic: s3, response: t3 } = e3;
      if (await this.isValidSessionTopic(s3), !qt(t3)) {
        const { message: i4 } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t3)}`);
        throw new Error(i4);
      }
    }, this.isValidPing = async (e3) => {
      if (!xt(e3)) {
        const { message: t3 } = N("MISSING_OR_INVALID", `ping() params: ${e3}`);
        throw new Error(t3);
      }
      const { topic: s3 } = e3;
      await this.isValidSessionOrPairingTopic(s3);
    }, this.isValidEmit = async (e3) => {
      if (!xt(e3)) {
        const { message: o3 } = N("MISSING_OR_INVALID", `emit() params: ${e3}`);
        throw new Error(o3);
      }
      const { topic: s3, event: t3, chainId: i4 } = e3;
      await this.isValidSessionTopic(s3);
      const { namespaces: n3 } = this.client.session.get(s3);
      if (!Gt(n3, i4)) {
        const { message: o3 } = N("MISSING_OR_INVALID", `emit() chainId: ${i4}`);
        throw new Error(o3);
      }
      if (!Bt(t3)) {
        const { message: o3 } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t3)}`);
        throw new Error(o3);
      }
      if (!zt(n3, i4, t3.name)) {
        const { message: o3 } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t3)}`);
        throw new Error(o3);
      }
    }, this.isValidDisconnect = async (e3) => {
      if (!xt(e3)) {
        const { message: t3 } = N("MISSING_OR_INVALID", `disconnect() params: ${e3}`);
        throw new Error(t3);
      }
      const { topic: s3 } = e3;
      await this.isValidSessionOrPairingTopic(s3);
    }, this.getVerifyContext = async (e3, s3) => {
      const t3 = { verified: { verifyUrl: s3.verifyUrl || Z2, validation: "UNKNOWN", origin: s3.url || "" } };
      try {
        const i4 = await this.client.core.verify.resolve({ attestationId: e3, verifyUrl: s3.verifyUrl });
        i4 && (t3.verified.origin = i4.origin, t3.verified.isScam = i4.isScam, t3.verified.validation = i4.origin === new URL(s3.url).origin ? "VALID" : "INVALID");
      } catch (i4) {
        this.client.logger.info(i4);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(t3)}`), t3;
    }, this.validateSessionProps = (e3, s3) => {
      Object.values(e3).forEach((t3) => {
        if (!h(t3, false)) {
          const { message: i4 } = N("MISSING_OR_INVALID", `${s3} must be in Record<string, string> format. Received: ${JSON.stringify(t3)}`);
          throw new Error(i4);
        }
      });
    };
  }
  async isInitialized() {
    if (!this.initialized) {
      const { message: r5 } = N("NOT_INITIALIZED", this.name);
      throw new Error(r5);
    }
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D3.message, async (r5) => {
      const { topic: e3, message: s3 } = r5;
      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s3)))
        return;
      const t3 = await this.client.core.crypto.decode(e3, s3);
      try {
        isJsonRpcRequest(t3) ? (this.client.core.history.set(e3, t3), this.onRelayEventRequest({ topic: e3, payload: t3 })) : isJsonRpcResponse(t3) ? (await this.client.core.history.resolve(t3), await this.onRelayEventResponse({ topic: e3, payload: t3 }), this.client.core.history.delete(e3, t3.id)) : this.onRelayEventUnknownPayload({ topic: e3, payload: t3 });
      } catch (i4) {
        this.client.logger.error(i4);
      }
    });
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(v.expired, async (r5) => {
      const { topic: e3, id: s3 } = ut(r5.target);
      if (s3 && this.client.pendingRequest.keys.includes(s3))
        return await this.deletePendingSessionRequest(s3, N("EXPIRED"), true);
      e3 ? this.client.session.keys.includes(e3) && (await this.deleteSession(e3, true), this.client.events.emit("session_expire", { topic: e3 })) : s3 && (await this.deleteProposal(s3, true), this.client.events.emit("proposal_expire", { id: s3 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(B2.create, (r5) => this.onPairingCreated(r5));
  }
  isValidPairingTopic(r5) {
    if (!h(r5, false)) {
      const { message: e3 } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${r5}`);
      throw new Error(e3);
    }
    if (!this.client.core.pairing.pairings.keys.includes(r5)) {
      const { message: e3 } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r5}`);
      throw new Error(e3);
    }
    if (dt(this.client.core.pairing.pairings.get(r5).expiry)) {
      const { message: e3 } = N("EXPIRED", `pairing topic: ${r5}`);
      throw new Error(e3);
    }
  }
  async isValidSessionTopic(r5) {
    if (!h(r5, false)) {
      const { message: e3 } = N("MISSING_OR_INVALID", `session topic should be a string: ${r5}`);
      throw new Error(e3);
    }
    if (!this.client.session.keys.includes(r5)) {
      const { message: e3 } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${r5}`);
      throw new Error(e3);
    }
    if (dt(this.client.session.get(r5).expiry)) {
      await this.deleteSession(r5);
      const { message: e3 } = N("EXPIRED", `session topic: ${r5}`);
      throw new Error(e3);
    }
  }
  async isValidSessionOrPairingTopic(r5) {
    if (this.client.session.keys.includes(r5))
      await this.isValidSessionTopic(r5);
    else if (this.client.core.pairing.pairings.keys.includes(r5))
      this.isValidPairingTopic(r5);
    else if (h(r5, false)) {
      const { message: e3 } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r5}`);
      throw new Error(e3);
    } else {
      const { message: e3 } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r5}`);
      throw new Error(e3);
    }
  }
  async isValidProposalId(r5) {
    if (!Lt(r5)) {
      const { message: e3 } = N("MISSING_OR_INVALID", `proposal id should be a number: ${r5}`);
      throw new Error(e3);
    }
    if (!this.client.proposal.keys.includes(r5)) {
      const { message: e3 } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${r5}`);
      throw new Error(e3);
    }
    if (dt(this.client.proposal.get(r5).expiry)) {
      await this.deleteProposal(r5);
      const { message: e3 } = N("EXPIRED", `proposal id: ${r5}`);
      throw new Error(e3);
    }
  }
};
var hs2 = class extends Ft2 {
  constructor(r5, e3) {
    super(r5, e3, ne, G2), this.core = r5, this.logger = e3;
  }
};
var ds2 = class extends Ft2 {
  constructor(r5, e3) {
    super(r5, e3, ae2, G2), this.core = r5, this.logger = e3;
  }
};
var us2 = class extends Ft2 {
  constructor(r5, e3) {
    super(r5, e3, le3, G2, (s3) => s3.id), this.core = r5, this.logger = e3;
  }
};
var Q3 = class _Q extends b {
  constructor(r5) {
    super(r5), this.protocol = X3, this.version = F3, this.name = M2.name, this.events = new import_events6.EventEmitter(), this.on = (s3, t3) => this.events.on(s3, t3), this.once = (s3, t3) => this.events.once(s3, t3), this.off = (s3, t3) => this.events.off(s3, t3), this.removeListener = (s3, t3) => this.events.removeListener(s3, t3), this.removeAllListeners = (s3) => this.events.removeAllListeners(s3), this.connect = async (s3) => {
      try {
        return await this.engine.connect(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.pair = async (s3) => {
      try {
        return await this.engine.pair(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.approve = async (s3) => {
      try {
        return await this.engine.approve(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.reject = async (s3) => {
      try {
        return await this.engine.reject(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.update = async (s3) => {
      try {
        return await this.engine.update(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.extend = async (s3) => {
      try {
        return await this.engine.extend(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.request = async (s3) => {
      try {
        return await this.engine.request(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.respond = async (s3) => {
      try {
        return await this.engine.respond(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.ping = async (s3) => {
      try {
        return await this.engine.ping(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.emit = async (s3) => {
      try {
        return await this.engine.emit(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.disconnect = async (s3) => {
      try {
        return await this.engine.disconnect(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.find = (s3) => {
      try {
        return this.engine.find(s3);
      } catch (t3) {
        throw this.logger.error(t3.message), t3;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }, this.name = (r5 == null ? void 0 : r5.name) || M2.name, this.metadata = (r5 == null ? void 0 : r5.metadata) || zn();
    const e3 = typeof (r5 == null ? void 0 : r5.logger) < "u" && typeof (r5 == null ? void 0 : r5.logger) != "string" ? r5.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: (r5 == null ? void 0 : r5.logger) || M2.logger }));
    this.core = (r5 == null ? void 0 : r5.core) || new Ar(r5), this.logger = (0, import_logger2.generateChildLogger)(e3, this.name), this.session = new ds2(this.core, this.logger), this.proposal = new hs2(this.core, this.logger), this.pendingRequest = new us2(this.core, this.logger), this.engine = new ps2(this);
  }
  static async init(r5) {
    const e3 = new _Q(r5);
    return await e3.initialize(), e3;
  }
  get context() {
    return (0, import_logger2.getLoggerContext)(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
    } catch (r5) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r5.message), r5;
    }
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_logger3 = __toESM(require_cjs5());

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
var import_events7 = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var DEFAULT_HTTP_HEADERS = {
  Accept: "application/json",
  "Content-Type": "application/json"
};
var DEFAULT_HTTP_METHOD = "POST";
var DEFAULT_FETCH_OPTS = {
  headers: DEFAULT_HTTP_HEADERS,
  method: DEFAULT_HTTP_METHOD
};
var EVENT_EMITTER_MAX_LISTENERS_DEFAULT2 = 10;
var HttpConnection = class {
  constructor(url, disableProviderPing = false) {
    this.url = url;
    this.disableProviderPing = disableProviderPing;
    this.events = new import_events7.EventEmitter();
    this.isAvailable = false;
    this.registering = false;
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    this.url = url;
    this.disableProviderPing = disableProviderPing;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  removeListener(event, listener) {
    this.events.removeListener(event, listener);
  }
  async open(url = this.url) {
    await this.register(url);
  }
  async close() {
    if (!this.isAvailable) {
      throw new Error("Connection already closed");
    }
    this.onClose();
  }
  async send(payload, context) {
    if (!this.isAvailable) {
      await this.register();
    }
    try {
      const body = safeJsonStringify(payload);
      const res = await (0, import_cross_fetch.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      const data3 = await res.json();
      this.onPayload({ data: data3 });
    } catch (e3) {
      this.onError(payload.id, e3);
    }
  }
  async register(url = this.url) {
    if (!isHttpUrl(url)) {
      throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
    }
    if (this.registering) {
      const currentMaxListeners = this.events.getMaxListeners();
      if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
        this.events.setMaxListeners(currentMaxListeners + 1);
      }
      return new Promise((resolve, reject) => {
        this.events.once("register_error", (error) => {
          this.resetMaxListeners();
          reject(error);
        });
        this.events.once("open", () => {
          this.resetMaxListeners();
          if (typeof this.isAvailable === "undefined") {
            return reject(new Error("HTTP connection is missing or invalid"));
          }
          resolve();
        });
      });
    }
    this.url = url;
    this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await (0, import_cross_fetch.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
      }
      this.onOpen();
    } catch (e3) {
      const error = this.parseError(e3);
      this.events.emit("register_error", error);
      this.onClose();
      throw error;
    }
  }
  onOpen() {
    this.isAvailable = true;
    this.registering = false;
    this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false;
    this.registering = false;
    this.events.emit("close");
  }
  onPayload(e3) {
    if (typeof e3.data === "undefined")
      return;
    const payload = typeof e3.data === "string" ? safeJsonParse(e3.data) : e3.data;
    this.events.emit("payload", payload);
  }
  onError(id2, e3) {
    const error = this.parseError(e3);
    const message = error.message || error.toString();
    const payload = formatJsonRpcError(id2, message);
    this.events.emit("payload", payload);
  }
  parseError(e3, url = this.url) {
    return parseConnectionError(e3, url, "HTTP");
  }
  resetMaxListeners() {
    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT2) {
      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT2);
    }
  }
};
var http_default = HttpConnection;

// node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/index.js
var esm_default2 = http_default;

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events8 = __toESM(require_events());
var Ia = "error";
var Ug = "wss://relay.walletconnect.com";
var Wg = "wc";
var Fg = "universal_provider";
var xa = `${Wg}@2:${Fg}:`;
var Mg = "https://rpc.walletconnect.com/v1/";
var Vn2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var ge2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Ui = { exports: {} };
(function(C2, u5) {
  (function() {
    var i4, d4 = "4.17.21", w5 = 200, T4 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", $4 = "Expected a function", En2 = "Invalid `variable` option passed into `_.template`", zt3 = "__lodash_hash_undefined__", pr = 500, It2 = "__lodash_placeholder__", Ln2 = 1, Fn2 = 2, xt3 = 4, Et3 = 1, ve2 = 2, vn = 1, ct3 = 2, qi2 = 4, Dn2 = 8, yt3 = 16, Hn2 = 32, St2 = 64, Mn2 = 128, Kt3 = 256, dr = 512, La = 30, Da = "...", Ha = 800, Na = 16, Bi2 = 1, $a = 2, Ua = 3, ht3 = 1 / 0, kn2 = 9007199254740991, Wa = 17976931348623157e292, _e4 = 0 / 0, Nn = 4294967295, Fa = Nn - 1, Ma = Nn >>> 1, qa = [["ary", Mn2], ["bind", vn], ["bindKey", ct3], ["curry", Dn2], ["curryRight", yt3], ["flip", dr], ["partial", Hn2], ["partialRight", St2], ["rearg", Kt3]], Ot2 = "[object Arguments]", me3 = "[object Array]", Ba = "[object AsyncFunction]", Yt2 = "[object Boolean]", Zt2 = "[object Date]", Ga = "[object DOMException]", we = "[object Error]", Pe2 = "[object Function]", Gi2 = "[object GeneratorFunction]", yn2 = "[object Map]", Jt2 = "[object Number]", za = "[object Null]", qn2 = "[object Object]", zi2 = "[object Promise]", Ka = "[object Proxy]", Xt2 = "[object RegExp]", Sn2 = "[object Set]", Qt2 = "[object String]", Ae2 = "[object Symbol]", Ya = "[object Undefined]", Vt3 = "[object WeakMap]", Za = "[object WeakSet]", kt3 = "[object ArrayBuffer]", Rt2 = "[object DataView]", gr = "[object Float32Array]", vr2 = "[object Float64Array]", _r2 = "[object Int8Array]", mr2 = "[object Int16Array]", wr2 = "[object Int32Array]", Pr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Cr2 = "[object Uint16Array]", Ir2 = "[object Uint32Array]", Ja = /\b__p \+= '';/g, Xa = /\b(__p \+=) '' \+/g, Qa = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ki2 = /&(?:amp|lt|gt|quot|#39);/g, Yi2 = /[&<>"']/g, Va = RegExp(Ki2.source), ka = RegExp(Yi2.source), ja = /<%-([\s\S]+?)%>/g, no = /<%([\s\S]+?)%>/g, Zi2 = /<%=([\s\S]+?)%>/g, to = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, eo = /^\w*$/, ro = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xr2 = /[\\^$.*+?()[\]{}|]/g, io = RegExp(xr2.source), Er2 = /^\s+/, so = /\s/, uo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ao = /\{\n\/\* \[wrapped with (.+)\] \*/, oo = /,? & /, fo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, co = /[()=,{}\[\]\/\s]/, ho = /\\(\\)?/g, lo = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ji2 = /\w*$/, po = /^[-+]0x[0-9a-f]+$/i, go = /^0b[01]+$/i, vo = /^\[object .+?Constructor\]$/, _o = /^0o[0-7]+$/i, mo = /^(?:0|[1-9]\d*)$/, wo = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ce3 = /($^)/, Po = /['\n\r\u2028\u2029\\]/g, Ie3 = "\\ud800-\\udfff", Ao = "\\u0300-\\u036f", Co = "\\ufe20-\\ufe2f", Io = "\\u20d0-\\u20ff", Xi2 = Ao + Co + Io, Qi2 = "\\u2700-\\u27bf", Vi2 = "a-z\\xdf-\\xf6\\xf8-\\xff", xo = "\\xac\\xb1\\xd7\\xf7", Eo = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", yo = "\\u2000-\\u206f", So = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ki2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ji2 = "\\ufe0e\\ufe0f", ns3 = xo + Eo + yo + So, yr2 = "['’]", Oo = "[" + Ie3 + "]", ts2 = "[" + ns3 + "]", xe = "[" + Xi2 + "]", es2 = "\\d+", Ro = "[" + Qi2 + "]", rs2 = "[" + Vi2 + "]", is3 = "[^" + Ie3 + ns3 + es2 + Qi2 + Vi2 + ki2 + "]", Sr2 = "\\ud83c[\\udffb-\\udfff]", bo = "(?:" + xe + "|" + Sr2 + ")", ss2 = "[^" + Ie3 + "]", Or2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rr2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", bt3 = "[" + ki2 + "]", us3 = "\\u200d", as3 = "(?:" + rs2 + "|" + is3 + ")", To = "(?:" + bt3 + "|" + is3 + ")", os3 = "(?:" + yr2 + "(?:d|ll|m|re|s|t|ve))?", fs2 = "(?:" + yr2 + "(?:D|LL|M|RE|S|T|VE))?", cs3 = bo + "?", hs3 = "[" + ji2 + "]?", Lo = "(?:" + us3 + "(?:" + [ss2, Or2, Rr2].join("|") + ")" + hs3 + cs3 + ")*", Do = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Ho = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ls3 = hs3 + cs3 + Lo, No = "(?:" + [Ro, Or2, Rr2].join("|") + ")" + ls3, $o = "(?:" + [ss2 + xe + "?", xe, Or2, Rr2, Oo].join("|") + ")", Uo = RegExp(yr2, "g"), Wo = RegExp(xe, "g"), br2 = RegExp(Sr2 + "(?=" + Sr2 + ")|" + $o + ls3, "g"), Fo = RegExp([bt3 + "?" + rs2 + "+" + os3 + "(?=" + [ts2, bt3, "$"].join("|") + ")", To + "+" + fs2 + "(?=" + [ts2, bt3 + as3, "$"].join("|") + ")", bt3 + "?" + as3 + "+" + os3, bt3 + "+" + fs2, Ho, Do, es2, No].join("|"), "g"), Mo = RegExp("[" + us3 + Ie3 + Xi2 + ji2 + "]"), qo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Bo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Go = -1, B5 = {};
    B5[gr] = B5[vr2] = B5[_r2] = B5[mr2] = B5[wr2] = B5[Pr2] = B5[Ar2] = B5[Cr2] = B5[Ir2] = true, B5[Ot2] = B5[me3] = B5[kt3] = B5[Yt2] = B5[Rt2] = B5[Zt2] = B5[we] = B5[Pe2] = B5[yn2] = B5[Jt2] = B5[qn2] = B5[Xt2] = B5[Sn2] = B5[Qt2] = B5[Vt3] = false;
    var q5 = {};
    q5[Ot2] = q5[me3] = q5[kt3] = q5[Rt2] = q5[Yt2] = q5[Zt2] = q5[gr] = q5[vr2] = q5[_r2] = q5[mr2] = q5[wr2] = q5[yn2] = q5[Jt2] = q5[qn2] = q5[Xt2] = q5[Sn2] = q5[Qt2] = q5[Ae2] = q5[Pr2] = q5[Ar2] = q5[Cr2] = q5[Ir2] = true, q5[we] = q5[Pe2] = q5[Vt3] = false;
    var zo = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }, Ko = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Yo = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Zo = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Jo = parseFloat, Xo = parseInt, ps3 = typeof ge2 == "object" && ge2 && ge2.Object === Object && ge2, Qo = typeof self == "object" && self && self.Object === Object && self, k5 = ps3 || Qo || Function("return this")(), Tr2 = u5 && !u5.nodeType && u5, lt3 = Tr2 && true && C2 && !C2.nodeType && C2, ds3 = lt3 && lt3.exports === Tr2, Lr = ds3 && ps3.process, _n = function() {
      try {
        var h6 = lt3 && lt3.require && lt3.require("util").types;
        return h6 || Lr && Lr.binding && Lr.binding("util");
      } catch {
      }
    }(), gs2 = _n && _n.isArrayBuffer, vs2 = _n && _n.isDate, _s2 = _n && _n.isMap, ms2 = _n && _n.isRegExp, ws2 = _n && _n.isSet, Ps2 = _n && _n.isTypedArray;
    function cn2(h6, g7, p6) {
      switch (p6.length) {
        case 0:
          return h6.call(g7);
        case 1:
          return h6.call(g7, p6[0]);
        case 2:
          return h6.call(g7, p6[0], p6[1]);
        case 3:
          return h6.call(g7, p6[0], p6[1], p6[2]);
      }
      return h6.apply(g7, p6);
    }
    function Vo(h6, g7, p6, A5) {
      for (var S5 = -1, U5 = h6 == null ? 0 : h6.length; ++S5 < U5; ) {
        var X4 = h6[S5];
        g7(A5, X4, p6(X4), h6);
      }
      return A5;
    }
    function mn2(h6, g7) {
      for (var p6 = -1, A5 = h6 == null ? 0 : h6.length; ++p6 < A5 && g7(h6[p6], p6, h6) !== false; )
        ;
      return h6;
    }
    function ko(h6, g7) {
      for (var p6 = h6 == null ? 0 : h6.length; p6-- && g7(h6[p6], p6, h6) !== false; )
        ;
      return h6;
    }
    function As2(h6, g7) {
      for (var p6 = -1, A5 = h6 == null ? 0 : h6.length; ++p6 < A5; )
        if (!g7(h6[p6], p6, h6))
          return false;
      return true;
    }
    function jn2(h6, g7) {
      for (var p6 = -1, A5 = h6 == null ? 0 : h6.length, S5 = 0, U5 = []; ++p6 < A5; ) {
        var X4 = h6[p6];
        g7(X4, p6, h6) && (U5[S5++] = X4);
      }
      return U5;
    }
    function Ee2(h6, g7) {
      var p6 = h6 == null ? 0 : h6.length;
      return !!p6 && Tt2(h6, g7, 0) > -1;
    }
    function Dr2(h6, g7, p6) {
      for (var A5 = -1, S5 = h6 == null ? 0 : h6.length; ++A5 < S5; )
        if (p6(g7, h6[A5]))
          return true;
      return false;
    }
    function G3(h6, g7) {
      for (var p6 = -1, A5 = h6 == null ? 0 : h6.length, S5 = Array(A5); ++p6 < A5; )
        S5[p6] = g7(h6[p6], p6, h6);
      return S5;
    }
    function nt3(h6, g7) {
      for (var p6 = -1, A5 = g7.length, S5 = h6.length; ++p6 < A5; )
        h6[S5 + p6] = g7[p6];
      return h6;
    }
    function Hr(h6, g7, p6, A5) {
      var S5 = -1, U5 = h6 == null ? 0 : h6.length;
      for (A5 && U5 && (p6 = h6[++S5]); ++S5 < U5; )
        p6 = g7(p6, h6[S5], S5, h6);
      return p6;
    }
    function jo(h6, g7, p6, A5) {
      var S5 = h6 == null ? 0 : h6.length;
      for (A5 && S5 && (p6 = h6[--S5]); S5--; )
        p6 = g7(p6, h6[S5], S5, h6);
      return p6;
    }
    function Nr(h6, g7) {
      for (var p6 = -1, A5 = h6 == null ? 0 : h6.length; ++p6 < A5; )
        if (g7(h6[p6], p6, h6))
          return true;
      return false;
    }
    var nf = $r("length");
    function tf(h6) {
      return h6.split("");
    }
    function ef(h6) {
      return h6.match(fo) || [];
    }
    function Cs2(h6, g7, p6) {
      var A5;
      return p6(h6, function(S5, U5, X4) {
        if (g7(S5, U5, X4))
          return A5 = U5, false;
      }), A5;
    }
    function ye3(h6, g7, p6, A5) {
      for (var S5 = h6.length, U5 = p6 + (A5 ? 1 : -1); A5 ? U5-- : ++U5 < S5; )
        if (g7(h6[U5], U5, h6))
          return U5;
      return -1;
    }
    function Tt2(h6, g7, p6) {
      return g7 === g7 ? gf(h6, g7, p6) : ye3(h6, Is2, p6);
    }
    function rf(h6, g7, p6, A5) {
      for (var S5 = p6 - 1, U5 = h6.length; ++S5 < U5; )
        if (A5(h6[S5], g7))
          return S5;
      return -1;
    }
    function Is2(h6) {
      return h6 !== h6;
    }
    function xs2(h6, g7) {
      var p6 = h6 == null ? 0 : h6.length;
      return p6 ? Wr(h6, g7) / p6 : _e4;
    }
    function $r(h6) {
      return function(g7) {
        return g7 == null ? i4 : g7[h6];
      };
    }
    function Ur(h6) {
      return function(g7) {
        return h6 == null ? i4 : h6[g7];
      };
    }
    function Es2(h6, g7, p6, A5, S5) {
      return S5(h6, function(U5, X4, M5) {
        p6 = A5 ? (A5 = false, U5) : g7(p6, U5, X4, M5);
      }), p6;
    }
    function sf(h6, g7) {
      var p6 = h6.length;
      for (h6.sort(g7); p6--; )
        h6[p6] = h6[p6].value;
      return h6;
    }
    function Wr(h6, g7) {
      for (var p6, A5 = -1, S5 = h6.length; ++A5 < S5; ) {
        var U5 = g7(h6[A5]);
        U5 !== i4 && (p6 = p6 === i4 ? U5 : p6 + U5);
      }
      return p6;
    }
    function Fr(h6, g7) {
      for (var p6 = -1, A5 = Array(h6); ++p6 < h6; )
        A5[p6] = g7(p6);
      return A5;
    }
    function uf(h6, g7) {
      return G3(g7, function(p6) {
        return [p6, h6[p6]];
      });
    }
    function ys2(h6) {
      return h6 && h6.slice(0, bs2(h6) + 1).replace(Er2, "");
    }
    function hn(h6) {
      return function(g7) {
        return h6(g7);
      };
    }
    function Mr(h6, g7) {
      return G3(g7, function(p6) {
        return h6[p6];
      });
    }
    function jt3(h6, g7) {
      return h6.has(g7);
    }
    function Ss2(h6, g7) {
      for (var p6 = -1, A5 = h6.length; ++p6 < A5 && Tt2(g7, h6[p6], 0) > -1; )
        ;
      return p6;
    }
    function Os2(h6, g7) {
      for (var p6 = h6.length; p6-- && Tt2(g7, h6[p6], 0) > -1; )
        ;
      return p6;
    }
    function af(h6, g7) {
      for (var p6 = h6.length, A5 = 0; p6--; )
        h6[p6] === g7 && ++A5;
      return A5;
    }
    var of2 = Ur(zo), ff = Ur(Ko);
    function cf(h6) {
      return "\\" + Zo[h6];
    }
    function hf(h6, g7) {
      return h6 == null ? i4 : h6[g7];
    }
    function Lt3(h6) {
      return Mo.test(h6);
    }
    function lf(h6) {
      return qo.test(h6);
    }
    function pf(h6) {
      for (var g7, p6 = []; !(g7 = h6.next()).done; )
        p6.push(g7.value);
      return p6;
    }
    function qr(h6) {
      var g7 = -1, p6 = Array(h6.size);
      return h6.forEach(function(A5, S5) {
        p6[++g7] = [S5, A5];
      }), p6;
    }
    function Rs2(h6, g7) {
      return function(p6) {
        return h6(g7(p6));
      };
    }
    function tt2(h6, g7) {
      for (var p6 = -1, A5 = h6.length, S5 = 0, U5 = []; ++p6 < A5; ) {
        var X4 = h6[p6];
        (X4 === g7 || X4 === It2) && (h6[p6] = It2, U5[S5++] = p6);
      }
      return U5;
    }
    function Se2(h6) {
      var g7 = -1, p6 = Array(h6.size);
      return h6.forEach(function(A5) {
        p6[++g7] = A5;
      }), p6;
    }
    function df(h6) {
      var g7 = -1, p6 = Array(h6.size);
      return h6.forEach(function(A5) {
        p6[++g7] = [A5, A5];
      }), p6;
    }
    function gf(h6, g7, p6) {
      for (var A5 = p6 - 1, S5 = h6.length; ++A5 < S5; )
        if (h6[A5] === g7)
          return A5;
      return -1;
    }
    function vf(h6, g7, p6) {
      for (var A5 = p6 + 1; A5--; )
        if (h6[A5] === g7)
          return A5;
      return A5;
    }
    function Dt3(h6) {
      return Lt3(h6) ? mf(h6) : nf(h6);
    }
    function On2(h6) {
      return Lt3(h6) ? wf(h6) : tf(h6);
    }
    function bs2(h6) {
      for (var g7 = h6.length; g7-- && so.test(h6.charAt(g7)); )
        ;
      return g7;
    }
    var _f = Ur(Yo);
    function mf(h6) {
      for (var g7 = br2.lastIndex = 0; br2.test(h6); )
        ++g7;
      return g7;
    }
    function wf(h6) {
      return h6.match(br2) || [];
    }
    function Pf(h6) {
      return h6.match(Fo) || [];
    }
    var Af = function h6(g7) {
      g7 = g7 == null ? k5 : Ht2.defaults(k5.Object(), g7, Ht2.pick(k5, Bo));
      var p6 = g7.Array, A5 = g7.Date, S5 = g7.Error, U5 = g7.Function, X4 = g7.Math, M5 = g7.Object, Br = g7.RegExp, Cf = g7.String, wn2 = g7.TypeError, Oe = p6.prototype, If = U5.prototype, Nt3 = M5.prototype, Re4 = g7["__core-js_shared__"], be = If.toString, F6 = Nt3.hasOwnProperty, xf = 0, Ts2 = function() {
        var n3 = /[^.]+$/.exec(Re4 && Re4.keys && Re4.keys.IE_PROTO || "");
        return n3 ? "Symbol(src)_1." + n3 : "";
      }(), Te2 = Nt3.toString, Ef = be.call(M5), yf = k5._, Sf = Br("^" + be.call(F6).replace(xr2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Le2 = ds3 ? g7.Buffer : i4, et3 = g7.Symbol, De3 = g7.Uint8Array, Ls2 = Le2 ? Le2.allocUnsafe : i4, He3 = Rs2(M5.getPrototypeOf, M5), Ds2 = M5.create, Hs2 = Nt3.propertyIsEnumerable, Ne2 = Oe.splice, Ns2 = et3 ? et3.isConcatSpreadable : i4, ne2 = et3 ? et3.iterator : i4, pt3 = et3 ? et3.toStringTag : i4, $e2 = function() {
        try {
          var n3 = mt3(M5, "defineProperty");
          return n3({}, "", {}), n3;
        } catch {
        }
      }(), Of = g7.clearTimeout !== k5.clearTimeout && g7.clearTimeout, Rf = A5 && A5.now !== k5.Date.now && A5.now, bf = g7.setTimeout !== k5.setTimeout && g7.setTimeout, Ue3 = X4.ceil, We3 = X4.floor, Gr = M5.getOwnPropertySymbols, Tf = Le2 ? Le2.isBuffer : i4, $s2 = g7.isFinite, Lf = Oe.join, Df = Rs2(M5.keys, M5), Q5 = X4.max, nn2 = X4.min, Hf = A5.now, Nf = g7.parseInt, Us2 = X4.random, $f = Oe.reverse, zr = mt3(g7, "DataView"), te3 = mt3(g7, "Map"), Kr = mt3(g7, "Promise"), $t3 = mt3(g7, "Set"), ee3 = mt3(g7, "WeakMap"), re3 = mt3(M5, "create"), Fe3 = ee3 && new ee3(), Ut2 = {}, Uf = wt2(zr), Wf = wt2(te3), Ff = wt2(Kr), Mf = wt2($t3), qf = wt2(ee3), Me3 = et3 ? et3.prototype : i4, ie3 = Me3 ? Me3.valueOf : i4, Ws2 = Me3 ? Me3.toString : i4;
      function a4(n3) {
        if (Y(n3) && !O7(n3) && !(n3 instanceof H3)) {
          if (n3 instanceof Pn)
            return n3;
          if (F6.call(n3, "__wrapped__"))
            return Fu(n3);
        }
        return new Pn(n3);
      }
      var Wt2 = function() {
        function n3() {
        }
        return function(t3) {
          if (!K4(t3))
            return {};
          if (Ds2)
            return Ds2(t3);
          n3.prototype = t3;
          var e3 = new n3();
          return n3.prototype = i4, e3;
        };
      }();
      function qe3() {
      }
      function Pn(n3, t3) {
        this.__wrapped__ = n3, this.__actions__ = [], this.__chain__ = !!t3, this.__index__ = 0, this.__values__ = i4;
      }
      a4.templateSettings = { escape: ja, evaluate: no, interpolate: Zi2, variable: "", imports: { _: a4 } }, a4.prototype = qe3.prototype, a4.prototype.constructor = a4, Pn.prototype = Wt2(qe3.prototype), Pn.prototype.constructor = Pn;
      function H3(n3) {
        this.__wrapped__ = n3, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Nn, this.__views__ = [];
      }
      function Bf() {
        var n3 = new H3(this.__wrapped__);
        return n3.__actions__ = un2(this.__actions__), n3.__dir__ = this.__dir__, n3.__filtered__ = this.__filtered__, n3.__iteratees__ = un2(this.__iteratees__), n3.__takeCount__ = this.__takeCount__, n3.__views__ = un2(this.__views__), n3;
      }
      function Gf() {
        if (this.__filtered__) {
          var n3 = new H3(this);
          n3.__dir__ = -1, n3.__filtered__ = true;
        } else
          n3 = this.clone(), n3.__dir__ *= -1;
        return n3;
      }
      function zf() {
        var n3 = this.__wrapped__.value(), t3 = this.__dir__, e3 = O7(n3), r5 = t3 < 0, s3 = e3 ? n3.length : 0, o3 = eh(0, s3, this.__views__), f5 = o3.start, c5 = o3.end, l4 = c5 - f5, v5 = r5 ? c5 : f5 - 1, _6 = this.__iteratees__, m5 = _6.length, P4 = 0, I3 = nn2(l4, this.__takeCount__);
        if (!e3 || !r5 && s3 == l4 && I3 == l4)
          return ou(n3, this.__actions__);
        var E6 = [];
        n:
          for (; l4-- && P4 < I3; ) {
            v5 += t3;
            for (var b6 = -1, y7 = n3[v5]; ++b6 < m5; ) {
              var D6 = _6[b6], N15 = D6.iteratee, dn2 = D6.type, sn2 = N15(y7);
              if (dn2 == $a)
                y7 = sn2;
              else if (!sn2) {
                if (dn2 == Bi2)
                  continue n;
                break n;
              }
            }
            E6[P4++] = y7;
          }
        return E6;
      }
      H3.prototype = Wt2(qe3.prototype), H3.prototype.constructor = H3;
      function dt3(n3) {
        var t3 = -1, e3 = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t3 < e3; ) {
          var r5 = n3[t3];
          this.set(r5[0], r5[1]);
        }
      }
      function Kf() {
        this.__data__ = re3 ? re3(null) : {}, this.size = 0;
      }
      function Yf(n3) {
        var t3 = this.has(n3) && delete this.__data__[n3];
        return this.size -= t3 ? 1 : 0, t3;
      }
      function Zf(n3) {
        var t3 = this.__data__;
        if (re3) {
          var e3 = t3[n3];
          return e3 === zt3 ? i4 : e3;
        }
        return F6.call(t3, n3) ? t3[n3] : i4;
      }
      function Jf(n3) {
        var t3 = this.__data__;
        return re3 ? t3[n3] !== i4 : F6.call(t3, n3);
      }
      function Xf(n3, t3) {
        var e3 = this.__data__;
        return this.size += this.has(n3) ? 0 : 1, e3[n3] = re3 && t3 === i4 ? zt3 : t3, this;
      }
      dt3.prototype.clear = Kf, dt3.prototype.delete = Yf, dt3.prototype.get = Zf, dt3.prototype.has = Jf, dt3.prototype.set = Xf;
      function Bn2(n3) {
        var t3 = -1, e3 = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t3 < e3; ) {
          var r5 = n3[t3];
          this.set(r5[0], r5[1]);
        }
      }
      function Qf() {
        this.__data__ = [], this.size = 0;
      }
      function Vf(n3) {
        var t3 = this.__data__, e3 = Be3(t3, n3);
        if (e3 < 0)
          return false;
        var r5 = t3.length - 1;
        return e3 == r5 ? t3.pop() : Ne2.call(t3, e3, 1), --this.size, true;
      }
      function kf(n3) {
        var t3 = this.__data__, e3 = Be3(t3, n3);
        return e3 < 0 ? i4 : t3[e3][1];
      }
      function jf(n3) {
        return Be3(this.__data__, n3) > -1;
      }
      function nc(n3, t3) {
        var e3 = this.__data__, r5 = Be3(e3, n3);
        return r5 < 0 ? (++this.size, e3.push([n3, t3])) : e3[r5][1] = t3, this;
      }
      Bn2.prototype.clear = Qf, Bn2.prototype.delete = Vf, Bn2.prototype.get = kf, Bn2.prototype.has = jf, Bn2.prototype.set = nc;
      function Gn(n3) {
        var t3 = -1, e3 = n3 == null ? 0 : n3.length;
        for (this.clear(); ++t3 < e3; ) {
          var r5 = n3[t3];
          this.set(r5[0], r5[1]);
        }
      }
      function tc() {
        this.size = 0, this.__data__ = { hash: new dt3(), map: new (te3 || Bn2)(), string: new dt3() };
      }
      function ec2(n3) {
        var t3 = nr2(this, n3).delete(n3);
        return this.size -= t3 ? 1 : 0, t3;
      }
      function rc(n3) {
        return nr2(this, n3).get(n3);
      }
      function ic(n3) {
        return nr2(this, n3).has(n3);
      }
      function sc(n3, t3) {
        var e3 = nr2(this, n3), r5 = e3.size;
        return e3.set(n3, t3), this.size += e3.size == r5 ? 0 : 1, this;
      }
      Gn.prototype.clear = tc, Gn.prototype.delete = ec2, Gn.prototype.get = rc, Gn.prototype.has = ic, Gn.prototype.set = sc;
      function gt3(n3) {
        var t3 = -1, e3 = n3 == null ? 0 : n3.length;
        for (this.__data__ = new Gn(); ++t3 < e3; )
          this.add(n3[t3]);
      }
      function uc(n3) {
        return this.__data__.set(n3, zt3), this;
      }
      function ac(n3) {
        return this.__data__.has(n3);
      }
      gt3.prototype.add = gt3.prototype.push = uc, gt3.prototype.has = ac;
      function Rn2(n3) {
        var t3 = this.__data__ = new Bn2(n3);
        this.size = t3.size;
      }
      function oc() {
        this.__data__ = new Bn2(), this.size = 0;
      }
      function fc(n3) {
        var t3 = this.__data__, e3 = t3.delete(n3);
        return this.size = t3.size, e3;
      }
      function cc(n3) {
        return this.__data__.get(n3);
      }
      function hc(n3) {
        return this.__data__.has(n3);
      }
      function lc(n3, t3) {
        var e3 = this.__data__;
        if (e3 instanceof Bn2) {
          var r5 = e3.__data__;
          if (!te3 || r5.length < w5 - 1)
            return r5.push([n3, t3]), this.size = ++e3.size, this;
          e3 = this.__data__ = new Gn(r5);
        }
        return e3.set(n3, t3), this.size = e3.size, this;
      }
      Rn2.prototype.clear = oc, Rn2.prototype.delete = fc, Rn2.prototype.get = cc, Rn2.prototype.has = hc, Rn2.prototype.set = lc;
      function Fs2(n3, t3) {
        var e3 = O7(n3), r5 = !e3 && Pt2(n3), s3 = !e3 && !r5 && at3(n3), o3 = !e3 && !r5 && !s3 && Bt3(n3), f5 = e3 || r5 || s3 || o3, c5 = f5 ? Fr(n3.length, Cf) : [], l4 = c5.length;
        for (var v5 in n3)
          (t3 || F6.call(n3, v5)) && !(f5 && (v5 == "length" || s3 && (v5 == "offset" || v5 == "parent") || o3 && (v5 == "buffer" || v5 == "byteLength" || v5 == "byteOffset") || Zn(v5, l4))) && c5.push(v5);
        return c5;
      }
      function Ms2(n3) {
        var t3 = n3.length;
        return t3 ? n3[ei(0, t3 - 1)] : i4;
      }
      function pc(n3, t3) {
        return tr2(un2(n3), vt3(t3, 0, n3.length));
      }
      function dc(n3) {
        return tr2(un2(n3));
      }
      function Yr(n3, t3, e3) {
        (e3 !== i4 && !bn2(n3[t3], e3) || e3 === i4 && !(t3 in n3)) && zn2(n3, t3, e3);
      }
      function se(n3, t3, e3) {
        var r5 = n3[t3];
        (!(F6.call(n3, t3) && bn2(r5, e3)) || e3 === i4 && !(t3 in n3)) && zn2(n3, t3, e3);
      }
      function Be3(n3, t3) {
        for (var e3 = n3.length; e3--; )
          if (bn2(n3[e3][0], t3))
            return e3;
        return -1;
      }
      function gc(n3, t3, e3, r5) {
        return rt2(n3, function(s3, o3, f5) {
          t3(r5, s3, e3(s3), f5);
        }), r5;
      }
      function qs2(n3, t3) {
        return n3 && Un(t3, V5(t3), n3);
      }
      function vc(n3, t3) {
        return n3 && Un(t3, on2(t3), n3);
      }
      function zn2(n3, t3, e3) {
        t3 == "__proto__" && $e2 ? $e2(n3, t3, { configurable: true, enumerable: true, value: e3, writable: true }) : n3[t3] = e3;
      }
      function Zr(n3, t3) {
        for (var e3 = -1, r5 = t3.length, s3 = p6(r5), o3 = n3 == null; ++e3 < r5; )
          s3[e3] = o3 ? i4 : Si(n3, t3[e3]);
        return s3;
      }
      function vt3(n3, t3, e3) {
        return n3 === n3 && (e3 !== i4 && (n3 = n3 <= e3 ? n3 : e3), t3 !== i4 && (n3 = n3 >= t3 ? n3 : t3)), n3;
      }
      function An(n3, t3, e3, r5, s3, o3) {
        var f5, c5 = t3 & Ln2, l4 = t3 & Fn2, v5 = t3 & xt3;
        if (e3 && (f5 = s3 ? e3(n3, r5, s3, o3) : e3(n3)), f5 !== i4)
          return f5;
        if (!K4(n3))
          return n3;
        var _6 = O7(n3);
        if (_6) {
          if (f5 = ih(n3), !c5)
            return un2(n3, f5);
        } else {
          var m5 = tn2(n3), P4 = m5 == Pe2 || m5 == Gi2;
          if (at3(n3))
            return hu(n3, c5);
          if (m5 == qn2 || m5 == Ot2 || P4 && !s3) {
            if (f5 = l4 || P4 ? {} : bu(n3), !c5)
              return l4 ? Zc(n3, vc(f5, n3)) : Yc(n3, qs2(f5, n3));
          } else {
            if (!q5[m5])
              return s3 ? n3 : {};
            f5 = sh(n3, m5, c5);
          }
        }
        o3 || (o3 = new Rn2());
        var I3 = o3.get(n3);
        if (I3)
          return I3;
        o3.set(n3, f5), sa(n3) ? n3.forEach(function(y7) {
          f5.add(An(y7, t3, e3, y7, n3, o3));
        }) : ra(n3) && n3.forEach(function(y7, D6) {
          f5.set(D6, An(y7, t3, e3, D6, n3, o3));
        });
        var E6 = v5 ? l4 ? pi : li : l4 ? on2 : V5, b6 = _6 ? i4 : E6(n3);
        return mn2(b6 || n3, function(y7, D6) {
          b6 && (D6 = y7, y7 = n3[D6]), se(f5, D6, An(y7, t3, e3, D6, n3, o3));
        }), f5;
      }
      function _c(n3) {
        var t3 = V5(n3);
        return function(e3) {
          return Bs2(e3, n3, t3);
        };
      }
      function Bs2(n3, t3, e3) {
        var r5 = e3.length;
        if (n3 == null)
          return !r5;
        for (n3 = M5(n3); r5--; ) {
          var s3 = e3[r5], o3 = t3[s3], f5 = n3[s3];
          if (f5 === i4 && !(s3 in n3) || !o3(f5))
            return false;
        }
        return true;
      }
      function Gs2(n3, t3, e3) {
        if (typeof n3 != "function")
          throw new wn2($4);
        return le4(function() {
          n3.apply(i4, e3);
        }, t3);
      }
      function ue3(n3, t3, e3, r5) {
        var s3 = -1, o3 = Ee2, f5 = true, c5 = n3.length, l4 = [], v5 = t3.length;
        if (!c5)
          return l4;
        e3 && (t3 = G3(t3, hn(e3))), r5 ? (o3 = Dr2, f5 = false) : t3.length >= w5 && (o3 = jt3, f5 = false, t3 = new gt3(t3));
        n:
          for (; ++s3 < c5; ) {
            var _6 = n3[s3], m5 = e3 == null ? _6 : e3(_6);
            if (_6 = r5 || _6 !== 0 ? _6 : 0, f5 && m5 === m5) {
              for (var P4 = v5; P4--; )
                if (t3[P4] === m5)
                  continue n;
              l4.push(_6);
            } else
              o3(t3, m5, r5) || l4.push(_6);
          }
        return l4;
      }
      var rt2 = vu($n2), zs2 = vu(Xr, true);
      function mc(n3, t3) {
        var e3 = true;
        return rt2(n3, function(r5, s3, o3) {
          return e3 = !!t3(r5, s3, o3), e3;
        }), e3;
      }
      function Ge3(n3, t3, e3) {
        for (var r5 = -1, s3 = n3.length; ++r5 < s3; ) {
          var o3 = n3[r5], f5 = t3(o3);
          if (f5 != null && (c5 === i4 ? f5 === f5 && !pn2(f5) : e3(f5, c5)))
            var c5 = f5, l4 = o3;
        }
        return l4;
      }
      function wc(n3, t3, e3, r5) {
        var s3 = n3.length;
        for (e3 = R3(e3), e3 < 0 && (e3 = -e3 > s3 ? 0 : s3 + e3), r5 = r5 === i4 || r5 > s3 ? s3 : R3(r5), r5 < 0 && (r5 += s3), r5 = e3 > r5 ? 0 : aa(r5); e3 < r5; )
          n3[e3++] = t3;
        return n3;
      }
      function Ks2(n3, t3) {
        var e3 = [];
        return rt2(n3, function(r5, s3, o3) {
          t3(r5, s3, o3) && e3.push(r5);
        }), e3;
      }
      function j7(n3, t3, e3, r5, s3) {
        var o3 = -1, f5 = n3.length;
        for (e3 || (e3 = ah), s3 || (s3 = []); ++o3 < f5; ) {
          var c5 = n3[o3];
          t3 > 0 && e3(c5) ? t3 > 1 ? j7(c5, t3 - 1, e3, r5, s3) : nt3(s3, c5) : r5 || (s3[s3.length] = c5);
        }
        return s3;
      }
      var Jr = _u(), Ys2 = _u(true);
      function $n2(n3, t3) {
        return n3 && Jr(n3, t3, V5);
      }
      function Xr(n3, t3) {
        return n3 && Ys2(n3, t3, V5);
      }
      function ze3(n3, t3) {
        return jn2(t3, function(e3) {
          return Jn2(n3[e3]);
        });
      }
      function _t3(n3, t3) {
        t3 = st3(t3, n3);
        for (var e3 = 0, r5 = t3.length; n3 != null && e3 < r5; )
          n3 = n3[Wn(t3[e3++])];
        return e3 && e3 == r5 ? n3 : i4;
      }
      function Zs2(n3, t3, e3) {
        var r5 = t3(n3);
        return O7(n3) ? r5 : nt3(r5, e3(n3));
      }
      function en2(n3) {
        return n3 == null ? n3 === i4 ? Ya : za : pt3 && pt3 in M5(n3) ? th(n3) : dh(n3);
      }
      function Qr(n3, t3) {
        return n3 > t3;
      }
      function Pc(n3, t3) {
        return n3 != null && F6.call(n3, t3);
      }
      function Ac(n3, t3) {
        return n3 != null && t3 in M5(n3);
      }
      function Cc(n3, t3, e3) {
        return n3 >= nn2(t3, e3) && n3 < Q5(t3, e3);
      }
      function Vr(n3, t3, e3) {
        for (var r5 = e3 ? Dr2 : Ee2, s3 = n3[0].length, o3 = n3.length, f5 = o3, c5 = p6(o3), l4 = 1 / 0, v5 = []; f5--; ) {
          var _6 = n3[f5];
          f5 && t3 && (_6 = G3(_6, hn(t3))), l4 = nn2(_6.length, l4), c5[f5] = !e3 && (t3 || s3 >= 120 && _6.length >= 120) ? new gt3(f5 && _6) : i4;
        }
        _6 = n3[0];
        var m5 = -1, P4 = c5[0];
        n:
          for (; ++m5 < s3 && v5.length < l4; ) {
            var I3 = _6[m5], E6 = t3 ? t3(I3) : I3;
            if (I3 = e3 || I3 !== 0 ? I3 : 0, !(P4 ? jt3(P4, E6) : r5(v5, E6, e3))) {
              for (f5 = o3; --f5; ) {
                var b6 = c5[f5];
                if (!(b6 ? jt3(b6, E6) : r5(n3[f5], E6, e3)))
                  continue n;
              }
              P4 && P4.push(E6), v5.push(I3);
            }
          }
        return v5;
      }
      function Ic(n3, t3, e3, r5) {
        return $n2(n3, function(s3, o3, f5) {
          t3(r5, e3(s3), o3, f5);
        }), r5;
      }
      function ae3(n3, t3, e3) {
        t3 = st3(t3, n3), n3 = Hu(n3, t3);
        var r5 = n3 == null ? n3 : n3[Wn(In(t3))];
        return r5 == null ? i4 : cn2(r5, n3, e3);
      }
      function Js2(n3) {
        return Y(n3) && en2(n3) == Ot2;
      }
      function xc(n3) {
        return Y(n3) && en2(n3) == kt3;
      }
      function Ec(n3) {
        return Y(n3) && en2(n3) == Zt2;
      }
      function oe4(n3, t3, e3, r5, s3) {
        return n3 === t3 ? true : n3 == null || t3 == null || !Y(n3) && !Y(t3) ? n3 !== n3 && t3 !== t3 : yc(n3, t3, e3, r5, oe4, s3);
      }
      function yc(n3, t3, e3, r5, s3, o3) {
        var f5 = O7(n3), c5 = O7(t3), l4 = f5 ? me3 : tn2(n3), v5 = c5 ? me3 : tn2(t3);
        l4 = l4 == Ot2 ? qn2 : l4, v5 = v5 == Ot2 ? qn2 : v5;
        var _6 = l4 == qn2, m5 = v5 == qn2, P4 = l4 == v5;
        if (P4 && at3(n3)) {
          if (!at3(t3))
            return false;
          f5 = true, _6 = false;
        }
        if (P4 && !_6)
          return o3 || (o3 = new Rn2()), f5 || Bt3(n3) ? Su(n3, t3, e3, r5, s3, o3) : jc(n3, t3, l4, e3, r5, s3, o3);
        if (!(e3 & Et3)) {
          var I3 = _6 && F6.call(n3, "__wrapped__"), E6 = m5 && F6.call(t3, "__wrapped__");
          if (I3 || E6) {
            var b6 = I3 ? n3.value() : n3, y7 = E6 ? t3.value() : t3;
            return o3 || (o3 = new Rn2()), s3(b6, y7, e3, r5, o3);
          }
        }
        return P4 ? (o3 || (o3 = new Rn2()), nh(n3, t3, e3, r5, s3, o3)) : false;
      }
      function Sc(n3) {
        return Y(n3) && tn2(n3) == yn2;
      }
      function kr(n3, t3, e3, r5) {
        var s3 = e3.length, o3 = s3, f5 = !r5;
        if (n3 == null)
          return !o3;
        for (n3 = M5(n3); s3--; ) {
          var c5 = e3[s3];
          if (f5 && c5[2] ? c5[1] !== n3[c5[0]] : !(c5[0] in n3))
            return false;
        }
        for (; ++s3 < o3; ) {
          c5 = e3[s3];
          var l4 = c5[0], v5 = n3[l4], _6 = c5[1];
          if (f5 && c5[2]) {
            if (v5 === i4 && !(l4 in n3))
              return false;
          } else {
            var m5 = new Rn2();
            if (r5)
              var P4 = r5(v5, _6, l4, n3, t3, m5);
            if (!(P4 === i4 ? oe4(_6, v5, Et3 | ve2, r5, m5) : P4))
              return false;
          }
        }
        return true;
      }
      function Xs2(n3) {
        if (!K4(n3) || fh(n3))
          return false;
        var t3 = Jn2(n3) ? Sf : vo;
        return t3.test(wt2(n3));
      }
      function Oc(n3) {
        return Y(n3) && en2(n3) == Xt2;
      }
      function Rc(n3) {
        return Y(n3) && tn2(n3) == Sn2;
      }
      function bc(n3) {
        return Y(n3) && ar2(n3.length) && !!B5[en2(n3)];
      }
      function Qs2(n3) {
        return typeof n3 == "function" ? n3 : n3 == null ? fn2 : typeof n3 == "object" ? O7(n3) ? js2(n3[0], n3[1]) : ks2(n3) : ma(n3);
      }
      function jr(n3) {
        if (!he4(n3))
          return Df(n3);
        var t3 = [];
        for (var e3 in M5(n3))
          F6.call(n3, e3) && e3 != "constructor" && t3.push(e3);
        return t3;
      }
      function Tc(n3) {
        if (!K4(n3))
          return ph(n3);
        var t3 = he4(n3), e3 = [];
        for (var r5 in n3)
          r5 == "constructor" && (t3 || !F6.call(n3, r5)) || e3.push(r5);
        return e3;
      }
      function ni(n3, t3) {
        return n3 < t3;
      }
      function Vs2(n3, t3) {
        var e3 = -1, r5 = an2(n3) ? p6(n3.length) : [];
        return rt2(n3, function(s3, o3, f5) {
          r5[++e3] = t3(s3, o3, f5);
        }), r5;
      }
      function ks2(n3) {
        var t3 = gi(n3);
        return t3.length == 1 && t3[0][2] ? Lu(t3[0][0], t3[0][1]) : function(e3) {
          return e3 === n3 || kr(e3, n3, t3);
        };
      }
      function js2(n3, t3) {
        return _i(n3) && Tu(t3) ? Lu(Wn(n3), t3) : function(e3) {
          var r5 = Si(e3, n3);
          return r5 === i4 && r5 === t3 ? Oi(e3, n3) : oe4(t3, r5, Et3 | ve2);
        };
      }
      function Ke2(n3, t3, e3, r5, s3) {
        n3 !== t3 && Jr(t3, function(o3, f5) {
          if (s3 || (s3 = new Rn2()), K4(o3))
            Lc(n3, t3, f5, e3, Ke2, r5, s3);
          else {
            var c5 = r5 ? r5(wi(n3, f5), o3, f5 + "", n3, t3, s3) : i4;
            c5 === i4 && (c5 = o3), Yr(n3, f5, c5);
          }
        }, on2);
      }
      function Lc(n3, t3, e3, r5, s3, o3, f5) {
        var c5 = wi(n3, e3), l4 = wi(t3, e3), v5 = f5.get(l4);
        if (v5) {
          Yr(n3, e3, v5);
          return;
        }
        var _6 = o3 ? o3(c5, l4, e3 + "", n3, t3, f5) : i4, m5 = _6 === i4;
        if (m5) {
          var P4 = O7(l4), I3 = !P4 && at3(l4), E6 = !P4 && !I3 && Bt3(l4);
          _6 = l4, P4 || I3 || E6 ? O7(c5) ? _6 = c5 : Z3(c5) ? _6 = un2(c5) : I3 ? (m5 = false, _6 = hu(l4, true)) : E6 ? (m5 = false, _6 = lu(l4, true)) : _6 = [] : pe3(l4) || Pt2(l4) ? (_6 = c5, Pt2(c5) ? _6 = oa(c5) : (!K4(c5) || Jn2(c5)) && (_6 = bu(l4))) : m5 = false;
        }
        m5 && (f5.set(l4, _6), s3(_6, l4, r5, o3, f5), f5.delete(l4)), Yr(n3, e3, _6);
      }
      function nu(n3, t3) {
        var e3 = n3.length;
        if (e3)
          return t3 += t3 < 0 ? e3 : 0, Zn(t3, e3) ? n3[t3] : i4;
      }
      function tu(n3, t3, e3) {
        t3.length ? t3 = G3(t3, function(o3) {
          return O7(o3) ? function(f5) {
            return _t3(f5, o3.length === 1 ? o3[0] : o3);
          } : o3;
        }) : t3 = [fn2];
        var r5 = -1;
        t3 = G3(t3, hn(x5()));
        var s3 = Vs2(n3, function(o3, f5, c5) {
          var l4 = G3(t3, function(v5) {
            return v5(o3);
          });
          return { criteria: l4, index: ++r5, value: o3 };
        });
        return sf(s3, function(o3, f5) {
          return Kc(o3, f5, e3);
        });
      }
      function Dc(n3, t3) {
        return eu(n3, t3, function(e3, r5) {
          return Oi(n3, r5);
        });
      }
      function eu(n3, t3, e3) {
        for (var r5 = -1, s3 = t3.length, o3 = {}; ++r5 < s3; ) {
          var f5 = t3[r5], c5 = _t3(n3, f5);
          e3(c5, f5) && fe2(o3, st3(f5, n3), c5);
        }
        return o3;
      }
      function Hc(n3) {
        return function(t3) {
          return _t3(t3, n3);
        };
      }
      function ti(n3, t3, e3, r5) {
        var s3 = r5 ? rf : Tt2, o3 = -1, f5 = t3.length, c5 = n3;
        for (n3 === t3 && (t3 = un2(t3)), e3 && (c5 = G3(n3, hn(e3))); ++o3 < f5; )
          for (var l4 = 0, v5 = t3[o3], _6 = e3 ? e3(v5) : v5; (l4 = s3(c5, _6, l4, r5)) > -1; )
            c5 !== n3 && Ne2.call(c5, l4, 1), Ne2.call(n3, l4, 1);
        return n3;
      }
      function ru(n3, t3) {
        for (var e3 = n3 ? t3.length : 0, r5 = e3 - 1; e3--; ) {
          var s3 = t3[e3];
          if (e3 == r5 || s3 !== o3) {
            var o3 = s3;
            Zn(s3) ? Ne2.call(n3, s3, 1) : si(n3, s3);
          }
        }
        return n3;
      }
      function ei(n3, t3) {
        return n3 + We3(Us2() * (t3 - n3 + 1));
      }
      function Nc(n3, t3, e3, r5) {
        for (var s3 = -1, o3 = Q5(Ue3((t3 - n3) / (e3 || 1)), 0), f5 = p6(o3); o3--; )
          f5[r5 ? o3 : ++s3] = n3, n3 += e3;
        return f5;
      }
      function ri(n3, t3) {
        var e3 = "";
        if (!n3 || t3 < 1 || t3 > kn2)
          return e3;
        do
          t3 % 2 && (e3 += n3), t3 = We3(t3 / 2), t3 && (n3 += n3);
        while (t3);
        return e3;
      }
      function L4(n3, t3) {
        return Pi(Du(n3, t3, fn2), n3 + "");
      }
      function $c(n3) {
        return Ms2(Gt3(n3));
      }
      function Uc(n3, t3) {
        var e3 = Gt3(n3);
        return tr2(e3, vt3(t3, 0, e3.length));
      }
      function fe2(n3, t3, e3, r5) {
        if (!K4(n3))
          return n3;
        t3 = st3(t3, n3);
        for (var s3 = -1, o3 = t3.length, f5 = o3 - 1, c5 = n3; c5 != null && ++s3 < o3; ) {
          var l4 = Wn(t3[s3]), v5 = e3;
          if (l4 === "__proto__" || l4 === "constructor" || l4 === "prototype")
            return n3;
          if (s3 != f5) {
            var _6 = c5[l4];
            v5 = r5 ? r5(_6, l4, c5) : i4, v5 === i4 && (v5 = K4(_6) ? _6 : Zn(t3[s3 + 1]) ? [] : {});
          }
          se(c5, l4, v5), c5 = c5[l4];
        }
        return n3;
      }
      var iu = Fe3 ? function(n3, t3) {
        return Fe3.set(n3, t3), n3;
      } : fn2, Wc = $e2 ? function(n3, t3) {
        return $e2(n3, "toString", { configurable: true, enumerable: false, value: bi(t3), writable: true });
      } : fn2;
      function Fc(n3) {
        return tr2(Gt3(n3));
      }
      function Cn(n3, t3, e3) {
        var r5 = -1, s3 = n3.length;
        t3 < 0 && (t3 = -t3 > s3 ? 0 : s3 + t3), e3 = e3 > s3 ? s3 : e3, e3 < 0 && (e3 += s3), s3 = t3 > e3 ? 0 : e3 - t3 >>> 0, t3 >>>= 0;
        for (var o3 = p6(s3); ++r5 < s3; )
          o3[r5] = n3[r5 + t3];
        return o3;
      }
      function Mc(n3, t3) {
        var e3;
        return rt2(n3, function(r5, s3, o3) {
          return e3 = t3(r5, s3, o3), !e3;
        }), !!e3;
      }
      function Ye3(n3, t3, e3) {
        var r5 = 0, s3 = n3 == null ? r5 : n3.length;
        if (typeof t3 == "number" && t3 === t3 && s3 <= Ma) {
          for (; r5 < s3; ) {
            var o3 = r5 + s3 >>> 1, f5 = n3[o3];
            f5 !== null && !pn2(f5) && (e3 ? f5 <= t3 : f5 < t3) ? r5 = o3 + 1 : s3 = o3;
          }
          return s3;
        }
        return ii(n3, t3, fn2, e3);
      }
      function ii(n3, t3, e3, r5) {
        var s3 = 0, o3 = n3 == null ? 0 : n3.length;
        if (o3 === 0)
          return 0;
        t3 = e3(t3);
        for (var f5 = t3 !== t3, c5 = t3 === null, l4 = pn2(t3), v5 = t3 === i4; s3 < o3; ) {
          var _6 = We3((s3 + o3) / 2), m5 = e3(n3[_6]), P4 = m5 !== i4, I3 = m5 === null, E6 = m5 === m5, b6 = pn2(m5);
          if (f5)
            var y7 = r5 || E6;
          else
            v5 ? y7 = E6 && (r5 || P4) : c5 ? y7 = E6 && P4 && (r5 || !I3) : l4 ? y7 = E6 && P4 && !I3 && (r5 || !b6) : I3 || b6 ? y7 = false : y7 = r5 ? m5 <= t3 : m5 < t3;
          y7 ? s3 = _6 + 1 : o3 = _6;
        }
        return nn2(o3, Fa);
      }
      function su(n3, t3) {
        for (var e3 = -1, r5 = n3.length, s3 = 0, o3 = []; ++e3 < r5; ) {
          var f5 = n3[e3], c5 = t3 ? t3(f5) : f5;
          if (!e3 || !bn2(c5, l4)) {
            var l4 = c5;
            o3[s3++] = f5 === 0 ? 0 : f5;
          }
        }
        return o3;
      }
      function uu(n3) {
        return typeof n3 == "number" ? n3 : pn2(n3) ? _e4 : +n3;
      }
      function ln2(n3) {
        if (typeof n3 == "string")
          return n3;
        if (O7(n3))
          return G3(n3, ln2) + "";
        if (pn2(n3))
          return Ws2 ? Ws2.call(n3) : "";
        var t3 = n3 + "";
        return t3 == "0" && 1 / n3 == -ht3 ? "-0" : t3;
      }
      function it3(n3, t3, e3) {
        var r5 = -1, s3 = Ee2, o3 = n3.length, f5 = true, c5 = [], l4 = c5;
        if (e3)
          f5 = false, s3 = Dr2;
        else if (o3 >= w5) {
          var v5 = t3 ? null : Vc(n3);
          if (v5)
            return Se2(v5);
          f5 = false, s3 = jt3, l4 = new gt3();
        } else
          l4 = t3 ? [] : c5;
        n:
          for (; ++r5 < o3; ) {
            var _6 = n3[r5], m5 = t3 ? t3(_6) : _6;
            if (_6 = e3 || _6 !== 0 ? _6 : 0, f5 && m5 === m5) {
              for (var P4 = l4.length; P4--; )
                if (l4[P4] === m5)
                  continue n;
              t3 && l4.push(m5), c5.push(_6);
            } else
              s3(l4, m5, e3) || (l4 !== c5 && l4.push(m5), c5.push(_6));
          }
        return c5;
      }
      function si(n3, t3) {
        return t3 = st3(t3, n3), n3 = Hu(n3, t3), n3 == null || delete n3[Wn(In(t3))];
      }
      function au(n3, t3, e3, r5) {
        return fe2(n3, t3, e3(_t3(n3, t3)), r5);
      }
      function Ze3(n3, t3, e3, r5) {
        for (var s3 = n3.length, o3 = r5 ? s3 : -1; (r5 ? o3-- : ++o3 < s3) && t3(n3[o3], o3, n3); )
          ;
        return e3 ? Cn(n3, r5 ? 0 : o3, r5 ? o3 + 1 : s3) : Cn(n3, r5 ? o3 + 1 : 0, r5 ? s3 : o3);
      }
      function ou(n3, t3) {
        var e3 = n3;
        return e3 instanceof H3 && (e3 = e3.value()), Hr(t3, function(r5, s3) {
          return s3.func.apply(s3.thisArg, nt3([r5], s3.args));
        }, e3);
      }
      function ui(n3, t3, e3) {
        var r5 = n3.length;
        if (r5 < 2)
          return r5 ? it3(n3[0]) : [];
        for (var s3 = -1, o3 = p6(r5); ++s3 < r5; )
          for (var f5 = n3[s3], c5 = -1; ++c5 < r5; )
            c5 != s3 && (o3[s3] = ue3(o3[s3] || f5, n3[c5], t3, e3));
        return it3(j7(o3, 1), t3, e3);
      }
      function fu(n3, t3, e3) {
        for (var r5 = -1, s3 = n3.length, o3 = t3.length, f5 = {}; ++r5 < s3; ) {
          var c5 = r5 < o3 ? t3[r5] : i4;
          e3(f5, n3[r5], c5);
        }
        return f5;
      }
      function ai(n3) {
        return Z3(n3) ? n3 : [];
      }
      function oi(n3) {
        return typeof n3 == "function" ? n3 : fn2;
      }
      function st3(n3, t3) {
        return O7(n3) ? n3 : _i(n3, t3) ? [n3] : Wu(W4(n3));
      }
      var qc = L4;
      function ut3(n3, t3, e3) {
        var r5 = n3.length;
        return e3 = e3 === i4 ? r5 : e3, !t3 && e3 >= r5 ? n3 : Cn(n3, t3, e3);
      }
      var cu = Of || function(n3) {
        return k5.clearTimeout(n3);
      };
      function hu(n3, t3) {
        if (t3)
          return n3.slice();
        var e3 = n3.length, r5 = Ls2 ? Ls2(e3) : new n3.constructor(e3);
        return n3.copy(r5), r5;
      }
      function fi(n3) {
        var t3 = new n3.constructor(n3.byteLength);
        return new De3(t3).set(new De3(n3)), t3;
      }
      function Bc(n3, t3) {
        var e3 = t3 ? fi(n3.buffer) : n3.buffer;
        return new n3.constructor(e3, n3.byteOffset, n3.byteLength);
      }
      function Gc(n3) {
        var t3 = new n3.constructor(n3.source, Ji2.exec(n3));
        return t3.lastIndex = n3.lastIndex, t3;
      }
      function zc(n3) {
        return ie3 ? M5(ie3.call(n3)) : {};
      }
      function lu(n3, t3) {
        var e3 = t3 ? fi(n3.buffer) : n3.buffer;
        return new n3.constructor(e3, n3.byteOffset, n3.length);
      }
      function pu(n3, t3) {
        if (n3 !== t3) {
          var e3 = n3 !== i4, r5 = n3 === null, s3 = n3 === n3, o3 = pn2(n3), f5 = t3 !== i4, c5 = t3 === null, l4 = t3 === t3, v5 = pn2(t3);
          if (!c5 && !v5 && !o3 && n3 > t3 || o3 && f5 && l4 && !c5 && !v5 || r5 && f5 && l4 || !e3 && l4 || !s3)
            return 1;
          if (!r5 && !o3 && !v5 && n3 < t3 || v5 && e3 && s3 && !r5 && !o3 || c5 && e3 && s3 || !f5 && s3 || !l4)
            return -1;
        }
        return 0;
      }
      function Kc(n3, t3, e3) {
        for (var r5 = -1, s3 = n3.criteria, o3 = t3.criteria, f5 = s3.length, c5 = e3.length; ++r5 < f5; ) {
          var l4 = pu(s3[r5], o3[r5]);
          if (l4) {
            if (r5 >= c5)
              return l4;
            var v5 = e3[r5];
            return l4 * (v5 == "desc" ? -1 : 1);
          }
        }
        return n3.index - t3.index;
      }
      function du(n3, t3, e3, r5) {
        for (var s3 = -1, o3 = n3.length, f5 = e3.length, c5 = -1, l4 = t3.length, v5 = Q5(o3 - f5, 0), _6 = p6(l4 + v5), m5 = !r5; ++c5 < l4; )
          _6[c5] = t3[c5];
        for (; ++s3 < f5; )
          (m5 || s3 < o3) && (_6[e3[s3]] = n3[s3]);
        for (; v5--; )
          _6[c5++] = n3[s3++];
        return _6;
      }
      function gu(n3, t3, e3, r5) {
        for (var s3 = -1, o3 = n3.length, f5 = -1, c5 = e3.length, l4 = -1, v5 = t3.length, _6 = Q5(o3 - c5, 0), m5 = p6(_6 + v5), P4 = !r5; ++s3 < _6; )
          m5[s3] = n3[s3];
        for (var I3 = s3; ++l4 < v5; )
          m5[I3 + l4] = t3[l4];
        for (; ++f5 < c5; )
          (P4 || s3 < o3) && (m5[I3 + e3[f5]] = n3[s3++]);
        return m5;
      }
      function un2(n3, t3) {
        var e3 = -1, r5 = n3.length;
        for (t3 || (t3 = p6(r5)); ++e3 < r5; )
          t3[e3] = n3[e3];
        return t3;
      }
      function Un(n3, t3, e3, r5) {
        var s3 = !e3;
        e3 || (e3 = {});
        for (var o3 = -1, f5 = t3.length; ++o3 < f5; ) {
          var c5 = t3[o3], l4 = r5 ? r5(e3[c5], n3[c5], c5, e3, n3) : i4;
          l4 === i4 && (l4 = n3[c5]), s3 ? zn2(e3, c5, l4) : se(e3, c5, l4);
        }
        return e3;
      }
      function Yc(n3, t3) {
        return Un(n3, vi(n3), t3);
      }
      function Zc(n3, t3) {
        return Un(n3, Ou(n3), t3);
      }
      function Je4(n3, t3) {
        return function(e3, r5) {
          var s3 = O7(e3) ? Vo : gc, o3 = t3 ? t3() : {};
          return s3(e3, n3, x5(r5, 2), o3);
        };
      }
      function Ft3(n3) {
        return L4(function(t3, e3) {
          var r5 = -1, s3 = e3.length, o3 = s3 > 1 ? e3[s3 - 1] : i4, f5 = s3 > 2 ? e3[2] : i4;
          for (o3 = n3.length > 3 && typeof o3 == "function" ? (s3--, o3) : i4, f5 && rn2(e3[0], e3[1], f5) && (o3 = s3 < 3 ? i4 : o3, s3 = 1), t3 = M5(t3); ++r5 < s3; ) {
            var c5 = e3[r5];
            c5 && n3(t3, c5, r5, o3);
          }
          return t3;
        });
      }
      function vu(n3, t3) {
        return function(e3, r5) {
          if (e3 == null)
            return e3;
          if (!an2(e3))
            return n3(e3, r5);
          for (var s3 = e3.length, o3 = t3 ? s3 : -1, f5 = M5(e3); (t3 ? o3-- : ++o3 < s3) && r5(f5[o3], o3, f5) !== false; )
            ;
          return e3;
        };
      }
      function _u(n3) {
        return function(t3, e3, r5) {
          for (var s3 = -1, o3 = M5(t3), f5 = r5(t3), c5 = f5.length; c5--; ) {
            var l4 = f5[n3 ? c5 : ++s3];
            if (e3(o3[l4], l4, o3) === false)
              break;
          }
          return t3;
        };
      }
      function Jc(n3, t3, e3) {
        var r5 = t3 & vn, s3 = ce4(n3);
        function o3() {
          var f5 = this && this !== k5 && this instanceof o3 ? s3 : n3;
          return f5.apply(r5 ? e3 : this, arguments);
        }
        return o3;
      }
      function mu(n3) {
        return function(t3) {
          t3 = W4(t3);
          var e3 = Lt3(t3) ? On2(t3) : i4, r5 = e3 ? e3[0] : t3.charAt(0), s3 = e3 ? ut3(e3, 1).join("") : t3.slice(1);
          return r5[n3]() + s3;
        };
      }
      function Mt3(n3) {
        return function(t3) {
          return Hr(va(ga(t3).replace(Uo, "")), n3, "");
        };
      }
      function ce4(n3) {
        return function() {
          var t3 = arguments;
          switch (t3.length) {
            case 0:
              return new n3();
            case 1:
              return new n3(t3[0]);
            case 2:
              return new n3(t3[0], t3[1]);
            case 3:
              return new n3(t3[0], t3[1], t3[2]);
            case 4:
              return new n3(t3[0], t3[1], t3[2], t3[3]);
            case 5:
              return new n3(t3[0], t3[1], t3[2], t3[3], t3[4]);
            case 6:
              return new n3(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]);
            case 7:
              return new n3(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6]);
          }
          var e3 = Wt2(n3.prototype), r5 = n3.apply(e3, t3);
          return K4(r5) ? r5 : e3;
        };
      }
      function Xc(n3, t3, e3) {
        var r5 = ce4(n3);
        function s3() {
          for (var o3 = arguments.length, f5 = p6(o3), c5 = o3, l4 = qt3(s3); c5--; )
            f5[c5] = arguments[c5];
          var v5 = o3 < 3 && f5[0] !== l4 && f5[o3 - 1] !== l4 ? [] : tt2(f5, l4);
          if (o3 -= v5.length, o3 < e3)
            return Iu(n3, t3, Xe3, s3.placeholder, i4, f5, v5, i4, i4, e3 - o3);
          var _6 = this && this !== k5 && this instanceof s3 ? r5 : n3;
          return cn2(_6, this, f5);
        }
        return s3;
      }
      function wu(n3) {
        return function(t3, e3, r5) {
          var s3 = M5(t3);
          if (!an2(t3)) {
            var o3 = x5(e3, 3);
            t3 = V5(t3), e3 = function(c5) {
              return o3(s3[c5], c5, s3);
            };
          }
          var f5 = n3(t3, e3, r5);
          return f5 > -1 ? s3[o3 ? t3[f5] : f5] : i4;
        };
      }
      function Pu(n3) {
        return Yn(function(t3) {
          var e3 = t3.length, r5 = e3, s3 = Pn.prototype.thru;
          for (n3 && t3.reverse(); r5--; ) {
            var o3 = t3[r5];
            if (typeof o3 != "function")
              throw new wn2($4);
            if (s3 && !f5 && je4(o3) == "wrapper")
              var f5 = new Pn([], true);
          }
          for (r5 = f5 ? r5 : e3; ++r5 < e3; ) {
            o3 = t3[r5];
            var c5 = je4(o3), l4 = c5 == "wrapper" ? di(o3) : i4;
            l4 && mi(l4[0]) && l4[1] == (Mn2 | Dn2 | Hn2 | Kt3) && !l4[4].length && l4[9] == 1 ? f5 = f5[je4(l4[0])].apply(f5, l4[3]) : f5 = o3.length == 1 && mi(o3) ? f5[c5]() : f5.thru(o3);
          }
          return function() {
            var v5 = arguments, _6 = v5[0];
            if (f5 && v5.length == 1 && O7(_6))
              return f5.plant(_6).value();
            for (var m5 = 0, P4 = e3 ? t3[m5].apply(this, v5) : _6; ++m5 < e3; )
              P4 = t3[m5].call(this, P4);
            return P4;
          };
        });
      }
      function Xe3(n3, t3, e3, r5, s3, o3, f5, c5, l4, v5) {
        var _6 = t3 & Mn2, m5 = t3 & vn, P4 = t3 & ct3, I3 = t3 & (Dn2 | yt3), E6 = t3 & dr, b6 = P4 ? i4 : ce4(n3);
        function y7() {
          for (var D6 = arguments.length, N15 = p6(D6), dn2 = D6; dn2--; )
            N15[dn2] = arguments[dn2];
          if (I3)
            var sn2 = qt3(y7), gn = af(N15, sn2);
          if (r5 && (N15 = du(N15, r5, s3, I3)), o3 && (N15 = gu(N15, o3, f5, I3)), D6 -= gn, I3 && D6 < v5) {
            var J3 = tt2(N15, sn2);
            return Iu(n3, t3, Xe3, y7.placeholder, e3, N15, J3, c5, l4, v5 - D6);
          }
          var Tn = m5 ? e3 : this, Qn = P4 ? Tn[n3] : n3;
          return D6 = N15.length, c5 ? N15 = gh(N15, c5) : E6 && D6 > 1 && N15.reverse(), _6 && l4 < D6 && (N15.length = l4), this && this !== k5 && this instanceof y7 && (Qn = b6 || ce4(Qn)), Qn.apply(Tn, N15);
        }
        return y7;
      }
      function Au(n3, t3) {
        return function(e3, r5) {
          return Ic(e3, n3, t3(r5), {});
        };
      }
      function Qe3(n3, t3) {
        return function(e3, r5) {
          var s3;
          if (e3 === i4 && r5 === i4)
            return t3;
          if (e3 !== i4 && (s3 = e3), r5 !== i4) {
            if (s3 === i4)
              return r5;
            typeof e3 == "string" || typeof r5 == "string" ? (e3 = ln2(e3), r5 = ln2(r5)) : (e3 = uu(e3), r5 = uu(r5)), s3 = n3(e3, r5);
          }
          return s3;
        };
      }
      function ci(n3) {
        return Yn(function(t3) {
          return t3 = G3(t3, hn(x5())), L4(function(e3) {
            var r5 = this;
            return n3(t3, function(s3) {
              return cn2(s3, r5, e3);
            });
          });
        });
      }
      function Ve3(n3, t3) {
        t3 = t3 === i4 ? " " : ln2(t3);
        var e3 = t3.length;
        if (e3 < 2)
          return e3 ? ri(t3, n3) : t3;
        var r5 = ri(t3, Ue3(n3 / Dt3(t3)));
        return Lt3(t3) ? ut3(On2(r5), 0, n3).join("") : r5.slice(0, n3);
      }
      function Qc(n3, t3, e3, r5) {
        var s3 = t3 & vn, o3 = ce4(n3);
        function f5() {
          for (var c5 = -1, l4 = arguments.length, v5 = -1, _6 = r5.length, m5 = p6(_6 + l4), P4 = this && this !== k5 && this instanceof f5 ? o3 : n3; ++v5 < _6; )
            m5[v5] = r5[v5];
          for (; l4--; )
            m5[v5++] = arguments[++c5];
          return cn2(P4, s3 ? e3 : this, m5);
        }
        return f5;
      }
      function Cu(n3) {
        return function(t3, e3, r5) {
          return r5 && typeof r5 != "number" && rn2(t3, e3, r5) && (e3 = r5 = i4), t3 = Xn(t3), e3 === i4 ? (e3 = t3, t3 = 0) : e3 = Xn(e3), r5 = r5 === i4 ? t3 < e3 ? 1 : -1 : Xn(r5), Nc(t3, e3, r5, n3);
        };
      }
      function ke3(n3) {
        return function(t3, e3) {
          return typeof t3 == "string" && typeof e3 == "string" || (t3 = xn2(t3), e3 = xn2(e3)), n3(t3, e3);
        };
      }
      function Iu(n3, t3, e3, r5, s3, o3, f5, c5, l4, v5) {
        var _6 = t3 & Dn2, m5 = _6 ? f5 : i4, P4 = _6 ? i4 : f5, I3 = _6 ? o3 : i4, E6 = _6 ? i4 : o3;
        t3 |= _6 ? Hn2 : St2, t3 &= ~(_6 ? St2 : Hn2), t3 & qi2 || (t3 &= ~(vn | ct3));
        var b6 = [n3, t3, s3, I3, m5, E6, P4, c5, l4, v5], y7 = e3.apply(i4, b6);
        return mi(n3) && Nu(y7, b6), y7.placeholder = r5, $u(y7, n3, t3);
      }
      function hi(n3) {
        var t3 = X4[n3];
        return function(e3, r5) {
          if (e3 = xn2(e3), r5 = r5 == null ? 0 : nn2(R3(r5), 292), r5 && $s2(e3)) {
            var s3 = (W4(e3) + "e").split("e"), o3 = t3(s3[0] + "e" + (+s3[1] + r5));
            return s3 = (W4(o3) + "e").split("e"), +(s3[0] + "e" + (+s3[1] - r5));
          }
          return t3(e3);
        };
      }
      var Vc = $t3 && 1 / Se2(new $t3([, -0]))[1] == ht3 ? function(n3) {
        return new $t3(n3);
      } : Di;
      function xu(n3) {
        return function(t3) {
          var e3 = tn2(t3);
          return e3 == yn2 ? qr(t3) : e3 == Sn2 ? df(t3) : uf(t3, n3(t3));
        };
      }
      function Kn2(n3, t3, e3, r5, s3, o3, f5, c5) {
        var l4 = t3 & ct3;
        if (!l4 && typeof n3 != "function")
          throw new wn2($4);
        var v5 = r5 ? r5.length : 0;
        if (v5 || (t3 &= ~(Hn2 | St2), r5 = s3 = i4), f5 = f5 === i4 ? f5 : Q5(R3(f5), 0), c5 = c5 === i4 ? c5 : R3(c5), v5 -= s3 ? s3.length : 0, t3 & St2) {
          var _6 = r5, m5 = s3;
          r5 = s3 = i4;
        }
        var P4 = l4 ? i4 : di(n3), I3 = [n3, t3, e3, r5, s3, _6, m5, o3, f5, c5];
        if (P4 && lh(I3, P4), n3 = I3[0], t3 = I3[1], e3 = I3[2], r5 = I3[3], s3 = I3[4], c5 = I3[9] = I3[9] === i4 ? l4 ? 0 : n3.length : Q5(I3[9] - v5, 0), !c5 && t3 & (Dn2 | yt3) && (t3 &= ~(Dn2 | yt3)), !t3 || t3 == vn)
          var E6 = Jc(n3, t3, e3);
        else
          t3 == Dn2 || t3 == yt3 ? E6 = Xc(n3, t3, c5) : (t3 == Hn2 || t3 == (vn | Hn2)) && !s3.length ? E6 = Qc(n3, t3, e3, r5) : E6 = Xe3.apply(i4, I3);
        var b6 = P4 ? iu : Nu;
        return $u(b6(E6, I3), n3, t3);
      }
      function Eu(n3, t3, e3, r5) {
        return n3 === i4 || bn2(n3, Nt3[e3]) && !F6.call(r5, e3) ? t3 : n3;
      }
      function yu(n3, t3, e3, r5, s3, o3) {
        return K4(n3) && K4(t3) && (o3.set(t3, n3), Ke2(n3, t3, i4, yu, o3), o3.delete(t3)), n3;
      }
      function kc(n3) {
        return pe3(n3) ? i4 : n3;
      }
      function Su(n3, t3, e3, r5, s3, o3) {
        var f5 = e3 & Et3, c5 = n3.length, l4 = t3.length;
        if (c5 != l4 && !(f5 && l4 > c5))
          return false;
        var v5 = o3.get(n3), _6 = o3.get(t3);
        if (v5 && _6)
          return v5 == t3 && _6 == n3;
        var m5 = -1, P4 = true, I3 = e3 & ve2 ? new gt3() : i4;
        for (o3.set(n3, t3), o3.set(t3, n3); ++m5 < c5; ) {
          var E6 = n3[m5], b6 = t3[m5];
          if (r5)
            var y7 = f5 ? r5(b6, E6, m5, t3, n3, o3) : r5(E6, b6, m5, n3, t3, o3);
          if (y7 !== i4) {
            if (y7)
              continue;
            P4 = false;
            break;
          }
          if (I3) {
            if (!Nr(t3, function(D6, N15) {
              if (!jt3(I3, N15) && (E6 === D6 || s3(E6, D6, e3, r5, o3)))
                return I3.push(N15);
            })) {
              P4 = false;
              break;
            }
          } else if (!(E6 === b6 || s3(E6, b6, e3, r5, o3))) {
            P4 = false;
            break;
          }
        }
        return o3.delete(n3), o3.delete(t3), P4;
      }
      function jc(n3, t3, e3, r5, s3, o3, f5) {
        switch (e3) {
          case Rt2:
            if (n3.byteLength != t3.byteLength || n3.byteOffset != t3.byteOffset)
              return false;
            n3 = n3.buffer, t3 = t3.buffer;
          case kt3:
            return !(n3.byteLength != t3.byteLength || !o3(new De3(n3), new De3(t3)));
          case Yt2:
          case Zt2:
          case Jt2:
            return bn2(+n3, +t3);
          case we:
            return n3.name == t3.name && n3.message == t3.message;
          case Xt2:
          case Qt2:
            return n3 == t3 + "";
          case yn2:
            var c5 = qr;
          case Sn2:
            var l4 = r5 & Et3;
            if (c5 || (c5 = Se2), n3.size != t3.size && !l4)
              return false;
            var v5 = f5.get(n3);
            if (v5)
              return v5 == t3;
            r5 |= ve2, f5.set(n3, t3);
            var _6 = Su(c5(n3), c5(t3), r5, s3, o3, f5);
            return f5.delete(n3), _6;
          case Ae2:
            if (ie3)
              return ie3.call(n3) == ie3.call(t3);
        }
        return false;
      }
      function nh(n3, t3, e3, r5, s3, o3) {
        var f5 = e3 & Et3, c5 = li(n3), l4 = c5.length, v5 = li(t3), _6 = v5.length;
        if (l4 != _6 && !f5)
          return false;
        for (var m5 = l4; m5--; ) {
          var P4 = c5[m5];
          if (!(f5 ? P4 in t3 : F6.call(t3, P4)))
            return false;
        }
        var I3 = o3.get(n3), E6 = o3.get(t3);
        if (I3 && E6)
          return I3 == t3 && E6 == n3;
        var b6 = true;
        o3.set(n3, t3), o3.set(t3, n3);
        for (var y7 = f5; ++m5 < l4; ) {
          P4 = c5[m5];
          var D6 = n3[P4], N15 = t3[P4];
          if (r5)
            var dn2 = f5 ? r5(N15, D6, P4, t3, n3, o3) : r5(D6, N15, P4, n3, t3, o3);
          if (!(dn2 === i4 ? D6 === N15 || s3(D6, N15, e3, r5, o3) : dn2)) {
            b6 = false;
            break;
          }
          y7 || (y7 = P4 == "constructor");
        }
        if (b6 && !y7) {
          var sn2 = n3.constructor, gn = t3.constructor;
          sn2 != gn && "constructor" in n3 && "constructor" in t3 && !(typeof sn2 == "function" && sn2 instanceof sn2 && typeof gn == "function" && gn instanceof gn) && (b6 = false);
        }
        return o3.delete(n3), o3.delete(t3), b6;
      }
      function Yn(n3) {
        return Pi(Du(n3, i4, Bu), n3 + "");
      }
      function li(n3) {
        return Zs2(n3, V5, vi);
      }
      function pi(n3) {
        return Zs2(n3, on2, Ou);
      }
      var di = Fe3 ? function(n3) {
        return Fe3.get(n3);
      } : Di;
      function je4(n3) {
        for (var t3 = n3.name + "", e3 = Ut2[t3], r5 = F6.call(Ut2, t3) ? e3.length : 0; r5--; ) {
          var s3 = e3[r5], o3 = s3.func;
          if (o3 == null || o3 == n3)
            return s3.name;
        }
        return t3;
      }
      function qt3(n3) {
        var t3 = F6.call(a4, "placeholder") ? a4 : n3;
        return t3.placeholder;
      }
      function x5() {
        var n3 = a4.iteratee || Ti;
        return n3 = n3 === Ti ? Qs2 : n3, arguments.length ? n3(arguments[0], arguments[1]) : n3;
      }
      function nr2(n3, t3) {
        var e3 = n3.__data__;
        return oh(t3) ? e3[typeof t3 == "string" ? "string" : "hash"] : e3.map;
      }
      function gi(n3) {
        for (var t3 = V5(n3), e3 = t3.length; e3--; ) {
          var r5 = t3[e3], s3 = n3[r5];
          t3[e3] = [r5, s3, Tu(s3)];
        }
        return t3;
      }
      function mt3(n3, t3) {
        var e3 = hf(n3, t3);
        return Xs2(e3) ? e3 : i4;
      }
      function th(n3) {
        var t3 = F6.call(n3, pt3), e3 = n3[pt3];
        try {
          n3[pt3] = i4;
          var r5 = true;
        } catch {
        }
        var s3 = Te2.call(n3);
        return r5 && (t3 ? n3[pt3] = e3 : delete n3[pt3]), s3;
      }
      var vi = Gr ? function(n3) {
        return n3 == null ? [] : (n3 = M5(n3), jn2(Gr(n3), function(t3) {
          return Hs2.call(n3, t3);
        }));
      } : Hi2, Ou = Gr ? function(n3) {
        for (var t3 = []; n3; )
          nt3(t3, vi(n3)), n3 = He3(n3);
        return t3;
      } : Hi2, tn2 = en2;
      (zr && tn2(new zr(new ArrayBuffer(1))) != Rt2 || te3 && tn2(new te3()) != yn2 || Kr && tn2(Kr.resolve()) != zi2 || $t3 && tn2(new $t3()) != Sn2 || ee3 && tn2(new ee3()) != Vt3) && (tn2 = function(n3) {
        var t3 = en2(n3), e3 = t3 == qn2 ? n3.constructor : i4, r5 = e3 ? wt2(e3) : "";
        if (r5)
          switch (r5) {
            case Uf:
              return Rt2;
            case Wf:
              return yn2;
            case Ff:
              return zi2;
            case Mf:
              return Sn2;
            case qf:
              return Vt3;
          }
        return t3;
      });
      function eh(n3, t3, e3) {
        for (var r5 = -1, s3 = e3.length; ++r5 < s3; ) {
          var o3 = e3[r5], f5 = o3.size;
          switch (o3.type) {
            case "drop":
              n3 += f5;
              break;
            case "dropRight":
              t3 -= f5;
              break;
            case "take":
              t3 = nn2(t3, n3 + f5);
              break;
            case "takeRight":
              n3 = Q5(n3, t3 - f5);
              break;
          }
        }
        return { start: n3, end: t3 };
      }
      function rh(n3) {
        var t3 = n3.match(ao);
        return t3 ? t3[1].split(oo) : [];
      }
      function Ru(n3, t3, e3) {
        t3 = st3(t3, n3);
        for (var r5 = -1, s3 = t3.length, o3 = false; ++r5 < s3; ) {
          var f5 = Wn(t3[r5]);
          if (!(o3 = n3 != null && e3(n3, f5)))
            break;
          n3 = n3[f5];
        }
        return o3 || ++r5 != s3 ? o3 : (s3 = n3 == null ? 0 : n3.length, !!s3 && ar2(s3) && Zn(f5, s3) && (O7(n3) || Pt2(n3)));
      }
      function ih(n3) {
        var t3 = n3.length, e3 = new n3.constructor(t3);
        return t3 && typeof n3[0] == "string" && F6.call(n3, "index") && (e3.index = n3.index, e3.input = n3.input), e3;
      }
      function bu(n3) {
        return typeof n3.constructor == "function" && !he4(n3) ? Wt2(He3(n3)) : {};
      }
      function sh(n3, t3, e3) {
        var r5 = n3.constructor;
        switch (t3) {
          case kt3:
            return fi(n3);
          case Yt2:
          case Zt2:
            return new r5(+n3);
          case Rt2:
            return Bc(n3, e3);
          case gr:
          case vr2:
          case _r2:
          case mr2:
          case wr2:
          case Pr2:
          case Ar2:
          case Cr2:
          case Ir2:
            return lu(n3, e3);
          case yn2:
            return new r5();
          case Jt2:
          case Qt2:
            return new r5(n3);
          case Xt2:
            return Gc(n3);
          case Sn2:
            return new r5();
          case Ae2:
            return zc(n3);
        }
      }
      function uh(n3, t3) {
        var e3 = t3.length;
        if (!e3)
          return n3;
        var r5 = e3 - 1;
        return t3[r5] = (e3 > 1 ? "& " : "") + t3[r5], t3 = t3.join(e3 > 2 ? ", " : " "), n3.replace(uo, `{
/* [wrapped with ` + t3 + `] */
`);
      }
      function ah(n3) {
        return O7(n3) || Pt2(n3) || !!(Ns2 && n3 && n3[Ns2]);
      }
      function Zn(n3, t3) {
        var e3 = typeof n3;
        return t3 = t3 ?? kn2, !!t3 && (e3 == "number" || e3 != "symbol" && mo.test(n3)) && n3 > -1 && n3 % 1 == 0 && n3 < t3;
      }
      function rn2(n3, t3, e3) {
        if (!K4(e3))
          return false;
        var r5 = typeof t3;
        return (r5 == "number" ? an2(e3) && Zn(t3, e3.length) : r5 == "string" && t3 in e3) ? bn2(e3[t3], n3) : false;
      }
      function _i(n3, t3) {
        if (O7(n3))
          return false;
        var e3 = typeof n3;
        return e3 == "number" || e3 == "symbol" || e3 == "boolean" || n3 == null || pn2(n3) ? true : eo.test(n3) || !to.test(n3) || t3 != null && n3 in M5(t3);
      }
      function oh(n3) {
        var t3 = typeof n3;
        return t3 == "string" || t3 == "number" || t3 == "symbol" || t3 == "boolean" ? n3 !== "__proto__" : n3 === null;
      }
      function mi(n3) {
        var t3 = je4(n3), e3 = a4[t3];
        if (typeof e3 != "function" || !(t3 in H3.prototype))
          return false;
        if (n3 === e3)
          return true;
        var r5 = di(e3);
        return !!r5 && n3 === r5[0];
      }
      function fh(n3) {
        return !!Ts2 && Ts2 in n3;
      }
      var ch = Re4 ? Jn2 : Ni2;
      function he4(n3) {
        var t3 = n3 && n3.constructor, e3 = typeof t3 == "function" && t3.prototype || Nt3;
        return n3 === e3;
      }
      function Tu(n3) {
        return n3 === n3 && !K4(n3);
      }
      function Lu(n3, t3) {
        return function(e3) {
          return e3 == null ? false : e3[n3] === t3 && (t3 !== i4 || n3 in M5(e3));
        };
      }
      function hh(n3) {
        var t3 = sr2(n3, function(r5) {
          return e3.size === pr && e3.clear(), r5;
        }), e3 = t3.cache;
        return t3;
      }
      function lh(n3, t3) {
        var e3 = n3[1], r5 = t3[1], s3 = e3 | r5, o3 = s3 < (vn | ct3 | Mn2), f5 = r5 == Mn2 && e3 == Dn2 || r5 == Mn2 && e3 == Kt3 && n3[7].length <= t3[8] || r5 == (Mn2 | Kt3) && t3[7].length <= t3[8] && e3 == Dn2;
        if (!(o3 || f5))
          return n3;
        r5 & vn && (n3[2] = t3[2], s3 |= e3 & vn ? 0 : qi2);
        var c5 = t3[3];
        if (c5) {
          var l4 = n3[3];
          n3[3] = l4 ? du(l4, c5, t3[4]) : c5, n3[4] = l4 ? tt2(n3[3], It2) : t3[4];
        }
        return c5 = t3[5], c5 && (l4 = n3[5], n3[5] = l4 ? gu(l4, c5, t3[6]) : c5, n3[6] = l4 ? tt2(n3[5], It2) : t3[6]), c5 = t3[7], c5 && (n3[7] = c5), r5 & Mn2 && (n3[8] = n3[8] == null ? t3[8] : nn2(n3[8], t3[8])), n3[9] == null && (n3[9] = t3[9]), n3[0] = t3[0], n3[1] = s3, n3;
      }
      function ph(n3) {
        var t3 = [];
        if (n3 != null)
          for (var e3 in M5(n3))
            t3.push(e3);
        return t3;
      }
      function dh(n3) {
        return Te2.call(n3);
      }
      function Du(n3, t3, e3) {
        return t3 = Q5(t3 === i4 ? n3.length - 1 : t3, 0), function() {
          for (var r5 = arguments, s3 = -1, o3 = Q5(r5.length - t3, 0), f5 = p6(o3); ++s3 < o3; )
            f5[s3] = r5[t3 + s3];
          s3 = -1;
          for (var c5 = p6(t3 + 1); ++s3 < t3; )
            c5[s3] = r5[s3];
          return c5[t3] = e3(f5), cn2(n3, this, c5);
        };
      }
      function Hu(n3, t3) {
        return t3.length < 2 ? n3 : _t3(n3, Cn(t3, 0, -1));
      }
      function gh(n3, t3) {
        for (var e3 = n3.length, r5 = nn2(t3.length, e3), s3 = un2(n3); r5--; ) {
          var o3 = t3[r5];
          n3[r5] = Zn(o3, e3) ? s3[o3] : i4;
        }
        return n3;
      }
      function wi(n3, t3) {
        if (!(t3 === "constructor" && typeof n3[t3] == "function") && t3 != "__proto__")
          return n3[t3];
      }
      var Nu = Uu(iu), le4 = bf || function(n3, t3) {
        return k5.setTimeout(n3, t3);
      }, Pi = Uu(Wc);
      function $u(n3, t3, e3) {
        var r5 = t3 + "";
        return Pi(n3, uh(r5, vh(rh(r5), e3)));
      }
      function Uu(n3) {
        var t3 = 0, e3 = 0;
        return function() {
          var r5 = Hf(), s3 = Na - (r5 - e3);
          if (e3 = r5, s3 > 0) {
            if (++t3 >= Ha)
              return arguments[0];
          } else
            t3 = 0;
          return n3.apply(i4, arguments);
        };
      }
      function tr2(n3, t3) {
        var e3 = -1, r5 = n3.length, s3 = r5 - 1;
        for (t3 = t3 === i4 ? r5 : t3; ++e3 < t3; ) {
          var o3 = ei(e3, s3), f5 = n3[o3];
          n3[o3] = n3[e3], n3[e3] = f5;
        }
        return n3.length = t3, n3;
      }
      var Wu = hh(function(n3) {
        var t3 = [];
        return n3.charCodeAt(0) === 46 && t3.push(""), n3.replace(ro, function(e3, r5, s3, o3) {
          t3.push(s3 ? o3.replace(ho, "$1") : r5 || e3);
        }), t3;
      });
      function Wn(n3) {
        if (typeof n3 == "string" || pn2(n3))
          return n3;
        var t3 = n3 + "";
        return t3 == "0" && 1 / n3 == -ht3 ? "-0" : t3;
      }
      function wt2(n3) {
        if (n3 != null) {
          try {
            return be.call(n3);
          } catch {
          }
          try {
            return n3 + "";
          } catch {
          }
        }
        return "";
      }
      function vh(n3, t3) {
        return mn2(qa, function(e3) {
          var r5 = "_." + e3[0];
          t3 & e3[1] && !Ee2(n3, r5) && n3.push(r5);
        }), n3.sort();
      }
      function Fu(n3) {
        if (n3 instanceof H3)
          return n3.clone();
        var t3 = new Pn(n3.__wrapped__, n3.__chain__);
        return t3.__actions__ = un2(n3.__actions__), t3.__index__ = n3.__index__, t3.__values__ = n3.__values__, t3;
      }
      function _h(n3, t3, e3) {
        (e3 ? rn2(n3, t3, e3) : t3 === i4) ? t3 = 1 : t3 = Q5(R3(t3), 0);
        var r5 = n3 == null ? 0 : n3.length;
        if (!r5 || t3 < 1)
          return [];
        for (var s3 = 0, o3 = 0, f5 = p6(Ue3(r5 / t3)); s3 < r5; )
          f5[o3++] = Cn(n3, s3, s3 += t3);
        return f5;
      }
      function mh(n3) {
        for (var t3 = -1, e3 = n3 == null ? 0 : n3.length, r5 = 0, s3 = []; ++t3 < e3; ) {
          var o3 = n3[t3];
          o3 && (s3[r5++] = o3);
        }
        return s3;
      }
      function wh() {
        var n3 = arguments.length;
        if (!n3)
          return [];
        for (var t3 = p6(n3 - 1), e3 = arguments[0], r5 = n3; r5--; )
          t3[r5 - 1] = arguments[r5];
        return nt3(O7(e3) ? un2(e3) : [e3], j7(t3, 1));
      }
      var Ph = L4(function(n3, t3) {
        return Z3(n3) ? ue3(n3, j7(t3, 1, Z3, true)) : [];
      }), Ah = L4(function(n3, t3) {
        var e3 = In(t3);
        return Z3(e3) && (e3 = i4), Z3(n3) ? ue3(n3, j7(t3, 1, Z3, true), x5(e3, 2)) : [];
      }), Ch = L4(function(n3, t3) {
        var e3 = In(t3);
        return Z3(e3) && (e3 = i4), Z3(n3) ? ue3(n3, j7(t3, 1, Z3, true), i4, e3) : [];
      });
      function Ih(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        return r5 ? (t3 = e3 || t3 === i4 ? 1 : R3(t3), Cn(n3, t3 < 0 ? 0 : t3, r5)) : [];
      }
      function xh(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        return r5 ? (t3 = e3 || t3 === i4 ? 1 : R3(t3), t3 = r5 - t3, Cn(n3, 0, t3 < 0 ? 0 : t3)) : [];
      }
      function Eh(n3, t3) {
        return n3 && n3.length ? Ze3(n3, x5(t3, 3), true, true) : [];
      }
      function yh(n3, t3) {
        return n3 && n3.length ? Ze3(n3, x5(t3, 3), true) : [];
      }
      function Sh(n3, t3, e3, r5) {
        var s3 = n3 == null ? 0 : n3.length;
        return s3 ? (e3 && typeof e3 != "number" && rn2(n3, t3, e3) && (e3 = 0, r5 = s3), wc(n3, t3, e3, r5)) : [];
      }
      function Mu(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        if (!r5)
          return -1;
        var s3 = e3 == null ? 0 : R3(e3);
        return s3 < 0 && (s3 = Q5(r5 + s3, 0)), ye3(n3, x5(t3, 3), s3);
      }
      function qu(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        if (!r5)
          return -1;
        var s3 = r5 - 1;
        return e3 !== i4 && (s3 = R3(e3), s3 = e3 < 0 ? Q5(r5 + s3, 0) : nn2(s3, r5 - 1)), ye3(n3, x5(t3, 3), s3, true);
      }
      function Bu(n3) {
        var t3 = n3 == null ? 0 : n3.length;
        return t3 ? j7(n3, 1) : [];
      }
      function Oh(n3) {
        var t3 = n3 == null ? 0 : n3.length;
        return t3 ? j7(n3, ht3) : [];
      }
      function Rh(n3, t3) {
        var e3 = n3 == null ? 0 : n3.length;
        return e3 ? (t3 = t3 === i4 ? 1 : R3(t3), j7(n3, t3)) : [];
      }
      function bh(n3) {
        for (var t3 = -1, e3 = n3 == null ? 0 : n3.length, r5 = {}; ++t3 < e3; ) {
          var s3 = n3[t3];
          r5[s3[0]] = s3[1];
        }
        return r5;
      }
      function Gu(n3) {
        return n3 && n3.length ? n3[0] : i4;
      }
      function Th(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        if (!r5)
          return -1;
        var s3 = e3 == null ? 0 : R3(e3);
        return s3 < 0 && (s3 = Q5(r5 + s3, 0)), Tt2(n3, t3, s3);
      }
      function Lh(n3) {
        var t3 = n3 == null ? 0 : n3.length;
        return t3 ? Cn(n3, 0, -1) : [];
      }
      var Dh = L4(function(n3) {
        var t3 = G3(n3, ai);
        return t3.length && t3[0] === n3[0] ? Vr(t3) : [];
      }), Hh = L4(function(n3) {
        var t3 = In(n3), e3 = G3(n3, ai);
        return t3 === In(e3) ? t3 = i4 : e3.pop(), e3.length && e3[0] === n3[0] ? Vr(e3, x5(t3, 2)) : [];
      }), Nh = L4(function(n3) {
        var t3 = In(n3), e3 = G3(n3, ai);
        return t3 = typeof t3 == "function" ? t3 : i4, t3 && e3.pop(), e3.length && e3[0] === n3[0] ? Vr(e3, i4, t3) : [];
      });
      function $h(n3, t3) {
        return n3 == null ? "" : Lf.call(n3, t3);
      }
      function In(n3) {
        var t3 = n3 == null ? 0 : n3.length;
        return t3 ? n3[t3 - 1] : i4;
      }
      function Uh(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        if (!r5)
          return -1;
        var s3 = r5;
        return e3 !== i4 && (s3 = R3(e3), s3 = s3 < 0 ? Q5(r5 + s3, 0) : nn2(s3, r5 - 1)), t3 === t3 ? vf(n3, t3, s3) : ye3(n3, Is2, s3, true);
      }
      function Wh(n3, t3) {
        return n3 && n3.length ? nu(n3, R3(t3)) : i4;
      }
      var Fh = L4(zu);
      function zu(n3, t3) {
        return n3 && n3.length && t3 && t3.length ? ti(n3, t3) : n3;
      }
      function Mh(n3, t3, e3) {
        return n3 && n3.length && t3 && t3.length ? ti(n3, t3, x5(e3, 2)) : n3;
      }
      function qh(n3, t3, e3) {
        return n3 && n3.length && t3 && t3.length ? ti(n3, t3, i4, e3) : n3;
      }
      var Bh = Yn(function(n3, t3) {
        var e3 = n3 == null ? 0 : n3.length, r5 = Zr(n3, t3);
        return ru(n3, G3(t3, function(s3) {
          return Zn(s3, e3) ? +s3 : s3;
        }).sort(pu)), r5;
      });
      function Gh(n3, t3) {
        var e3 = [];
        if (!(n3 && n3.length))
          return e3;
        var r5 = -1, s3 = [], o3 = n3.length;
        for (t3 = x5(t3, 3); ++r5 < o3; ) {
          var f5 = n3[r5];
          t3(f5, r5, n3) && (e3.push(f5), s3.push(r5));
        }
        return ru(n3, s3), e3;
      }
      function Ai2(n3) {
        return n3 == null ? n3 : $f.call(n3);
      }
      function zh(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        return r5 ? (e3 && typeof e3 != "number" && rn2(n3, t3, e3) ? (t3 = 0, e3 = r5) : (t3 = t3 == null ? 0 : R3(t3), e3 = e3 === i4 ? r5 : R3(e3)), Cn(n3, t3, e3)) : [];
      }
      function Kh(n3, t3) {
        return Ye3(n3, t3);
      }
      function Yh(n3, t3, e3) {
        return ii(n3, t3, x5(e3, 2));
      }
      function Zh(n3, t3) {
        var e3 = n3 == null ? 0 : n3.length;
        if (e3) {
          var r5 = Ye3(n3, t3);
          if (r5 < e3 && bn2(n3[r5], t3))
            return r5;
        }
        return -1;
      }
      function Jh(n3, t3) {
        return Ye3(n3, t3, true);
      }
      function Xh(n3, t3, e3) {
        return ii(n3, t3, x5(e3, 2), true);
      }
      function Qh(n3, t3) {
        var e3 = n3 == null ? 0 : n3.length;
        if (e3) {
          var r5 = Ye3(n3, t3, true) - 1;
          if (bn2(n3[r5], t3))
            return r5;
        }
        return -1;
      }
      function Vh(n3) {
        return n3 && n3.length ? su(n3) : [];
      }
      function kh(n3, t3) {
        return n3 && n3.length ? su(n3, x5(t3, 2)) : [];
      }
      function jh(n3) {
        var t3 = n3 == null ? 0 : n3.length;
        return t3 ? Cn(n3, 1, t3) : [];
      }
      function nl(n3, t3, e3) {
        return n3 && n3.length ? (t3 = e3 || t3 === i4 ? 1 : R3(t3), Cn(n3, 0, t3 < 0 ? 0 : t3)) : [];
      }
      function tl(n3, t3, e3) {
        var r5 = n3 == null ? 0 : n3.length;
        return r5 ? (t3 = e3 || t3 === i4 ? 1 : R3(t3), t3 = r5 - t3, Cn(n3, t3 < 0 ? 0 : t3, r5)) : [];
      }
      function el(n3, t3) {
        return n3 && n3.length ? Ze3(n3, x5(t3, 3), false, true) : [];
      }
      function rl(n3, t3) {
        return n3 && n3.length ? Ze3(n3, x5(t3, 3)) : [];
      }
      var il = L4(function(n3) {
        return it3(j7(n3, 1, Z3, true));
      }), sl = L4(function(n3) {
        var t3 = In(n3);
        return Z3(t3) && (t3 = i4), it3(j7(n3, 1, Z3, true), x5(t3, 2));
      }), ul = L4(function(n3) {
        var t3 = In(n3);
        return t3 = typeof t3 == "function" ? t3 : i4, it3(j7(n3, 1, Z3, true), i4, t3);
      });
      function al(n3) {
        return n3 && n3.length ? it3(n3) : [];
      }
      function ol(n3, t3) {
        return n3 && n3.length ? it3(n3, x5(t3, 2)) : [];
      }
      function fl(n3, t3) {
        return t3 = typeof t3 == "function" ? t3 : i4, n3 && n3.length ? it3(n3, i4, t3) : [];
      }
      function Ci(n3) {
        if (!(n3 && n3.length))
          return [];
        var t3 = 0;
        return n3 = jn2(n3, function(e3) {
          if (Z3(e3))
            return t3 = Q5(e3.length, t3), true;
        }), Fr(t3, function(e3) {
          return G3(n3, $r(e3));
        });
      }
      function Ku(n3, t3) {
        if (!(n3 && n3.length))
          return [];
        var e3 = Ci(n3);
        return t3 == null ? e3 : G3(e3, function(r5) {
          return cn2(t3, i4, r5);
        });
      }
      var cl = L4(function(n3, t3) {
        return Z3(n3) ? ue3(n3, t3) : [];
      }), hl = L4(function(n3) {
        return ui(jn2(n3, Z3));
      }), ll = L4(function(n3) {
        var t3 = In(n3);
        return Z3(t3) && (t3 = i4), ui(jn2(n3, Z3), x5(t3, 2));
      }), pl = L4(function(n3) {
        var t3 = In(n3);
        return t3 = typeof t3 == "function" ? t3 : i4, ui(jn2(n3, Z3), i4, t3);
      }), dl = L4(Ci);
      function gl(n3, t3) {
        return fu(n3 || [], t3 || [], se);
      }
      function vl(n3, t3) {
        return fu(n3 || [], t3 || [], fe2);
      }
      var _l = L4(function(n3) {
        var t3 = n3.length, e3 = t3 > 1 ? n3[t3 - 1] : i4;
        return e3 = typeof e3 == "function" ? (n3.pop(), e3) : i4, Ku(n3, e3);
      });
      function Yu(n3) {
        var t3 = a4(n3);
        return t3.__chain__ = true, t3;
      }
      function ml(n3, t3) {
        return t3(n3), n3;
      }
      function er3(n3, t3) {
        return t3(n3);
      }
      var wl = Yn(function(n3) {
        var t3 = n3.length, e3 = t3 ? n3[0] : 0, r5 = this.__wrapped__, s3 = function(o3) {
          return Zr(o3, n3);
        };
        return t3 > 1 || this.__actions__.length || !(r5 instanceof H3) || !Zn(e3) ? this.thru(s3) : (r5 = r5.slice(e3, +e3 + (t3 ? 1 : 0)), r5.__actions__.push({ func: er3, args: [s3], thisArg: i4 }), new Pn(r5, this.__chain__).thru(function(o3) {
          return t3 && !o3.length && o3.push(i4), o3;
        }));
      });
      function Pl() {
        return Yu(this);
      }
      function Al() {
        return new Pn(this.value(), this.__chain__);
      }
      function Cl() {
        this.__values__ === i4 && (this.__values__ = ua(this.value()));
        var n3 = this.__index__ >= this.__values__.length, t3 = n3 ? i4 : this.__values__[this.__index__++];
        return { done: n3, value: t3 };
      }
      function Il() {
        return this;
      }
      function xl(n3) {
        for (var t3, e3 = this; e3 instanceof qe3; ) {
          var r5 = Fu(e3);
          r5.__index__ = 0, r5.__values__ = i4, t3 ? s3.__wrapped__ = r5 : t3 = r5;
          var s3 = r5;
          e3 = e3.__wrapped__;
        }
        return s3.__wrapped__ = n3, t3;
      }
      function El() {
        var n3 = this.__wrapped__;
        if (n3 instanceof H3) {
          var t3 = n3;
          return this.__actions__.length && (t3 = new H3(this)), t3 = t3.reverse(), t3.__actions__.push({ func: er3, args: [Ai2], thisArg: i4 }), new Pn(t3, this.__chain__);
        }
        return this.thru(Ai2);
      }
      function yl() {
        return ou(this.__wrapped__, this.__actions__);
      }
      var Sl = Je4(function(n3, t3, e3) {
        F6.call(n3, e3) ? ++n3[e3] : zn2(n3, e3, 1);
      });
      function Ol(n3, t3, e3) {
        var r5 = O7(n3) ? As2 : mc;
        return e3 && rn2(n3, t3, e3) && (t3 = i4), r5(n3, x5(t3, 3));
      }
      function Rl(n3, t3) {
        var e3 = O7(n3) ? jn2 : Ks2;
        return e3(n3, x5(t3, 3));
      }
      var bl = wu(Mu), Tl = wu(qu);
      function Ll(n3, t3) {
        return j7(rr2(n3, t3), 1);
      }
      function Dl(n3, t3) {
        return j7(rr2(n3, t3), ht3);
      }
      function Hl(n3, t3, e3) {
        return e3 = e3 === i4 ? 1 : R3(e3), j7(rr2(n3, t3), e3);
      }
      function Zu(n3, t3) {
        var e3 = O7(n3) ? mn2 : rt2;
        return e3(n3, x5(t3, 3));
      }
      function Ju(n3, t3) {
        var e3 = O7(n3) ? ko : zs2;
        return e3(n3, x5(t3, 3));
      }
      var Nl = Je4(function(n3, t3, e3) {
        F6.call(n3, e3) ? n3[e3].push(t3) : zn2(n3, e3, [t3]);
      });
      function $l(n3, t3, e3, r5) {
        n3 = an2(n3) ? n3 : Gt3(n3), e3 = e3 && !r5 ? R3(e3) : 0;
        var s3 = n3.length;
        return e3 < 0 && (e3 = Q5(s3 + e3, 0)), or3(n3) ? e3 <= s3 && n3.indexOf(t3, e3) > -1 : !!s3 && Tt2(n3, t3, e3) > -1;
      }
      var Ul = L4(function(n3, t3, e3) {
        var r5 = -1, s3 = typeof t3 == "function", o3 = an2(n3) ? p6(n3.length) : [];
        return rt2(n3, function(f5) {
          o3[++r5] = s3 ? cn2(t3, f5, e3) : ae3(f5, t3, e3);
        }), o3;
      }), Wl = Je4(function(n3, t3, e3) {
        zn2(n3, e3, t3);
      });
      function rr2(n3, t3) {
        var e3 = O7(n3) ? G3 : Vs2;
        return e3(n3, x5(t3, 3));
      }
      function Fl(n3, t3, e3, r5) {
        return n3 == null ? [] : (O7(t3) || (t3 = t3 == null ? [] : [t3]), e3 = r5 ? i4 : e3, O7(e3) || (e3 = e3 == null ? [] : [e3]), tu(n3, t3, e3));
      }
      var Ml = Je4(function(n3, t3, e3) {
        n3[e3 ? 0 : 1].push(t3);
      }, function() {
        return [[], []];
      });
      function ql(n3, t3, e3) {
        var r5 = O7(n3) ? Hr : Es2, s3 = arguments.length < 3;
        return r5(n3, x5(t3, 4), e3, s3, rt2);
      }
      function Bl(n3, t3, e3) {
        var r5 = O7(n3) ? jo : Es2, s3 = arguments.length < 3;
        return r5(n3, x5(t3, 4), e3, s3, zs2);
      }
      function Gl(n3, t3) {
        var e3 = O7(n3) ? jn2 : Ks2;
        return e3(n3, ur2(x5(t3, 3)));
      }
      function zl(n3) {
        var t3 = O7(n3) ? Ms2 : $c;
        return t3(n3);
      }
      function Kl(n3, t3, e3) {
        (e3 ? rn2(n3, t3, e3) : t3 === i4) ? t3 = 1 : t3 = R3(t3);
        var r5 = O7(n3) ? pc : Uc;
        return r5(n3, t3);
      }
      function Yl(n3) {
        var t3 = O7(n3) ? dc : Fc;
        return t3(n3);
      }
      function Zl(n3) {
        if (n3 == null)
          return 0;
        if (an2(n3))
          return or3(n3) ? Dt3(n3) : n3.length;
        var t3 = tn2(n3);
        return t3 == yn2 || t3 == Sn2 ? n3.size : jr(n3).length;
      }
      function Jl(n3, t3, e3) {
        var r5 = O7(n3) ? Nr : Mc;
        return e3 && rn2(n3, t3, e3) && (t3 = i4), r5(n3, x5(t3, 3));
      }
      var Xl = L4(function(n3, t3) {
        if (n3 == null)
          return [];
        var e3 = t3.length;
        return e3 > 1 && rn2(n3, t3[0], t3[1]) ? t3 = [] : e3 > 2 && rn2(t3[0], t3[1], t3[2]) && (t3 = [t3[0]]), tu(n3, j7(t3, 1), []);
      }), ir2 = Rf || function() {
        return k5.Date.now();
      };
      function Ql(n3, t3) {
        if (typeof t3 != "function")
          throw new wn2($4);
        return n3 = R3(n3), function() {
          if (--n3 < 1)
            return t3.apply(this, arguments);
        };
      }
      function Xu(n3, t3, e3) {
        return t3 = e3 ? i4 : t3, t3 = n3 && t3 == null ? n3.length : t3, Kn2(n3, Mn2, i4, i4, i4, i4, t3);
      }
      function Qu(n3, t3) {
        var e3;
        if (typeof t3 != "function")
          throw new wn2($4);
        return n3 = R3(n3), function() {
          return --n3 > 0 && (e3 = t3.apply(this, arguments)), n3 <= 1 && (t3 = i4), e3;
        };
      }
      var Ii = L4(function(n3, t3, e3) {
        var r5 = vn;
        if (e3.length) {
          var s3 = tt2(e3, qt3(Ii));
          r5 |= Hn2;
        }
        return Kn2(n3, r5, t3, e3, s3);
      }), Vu = L4(function(n3, t3, e3) {
        var r5 = vn | ct3;
        if (e3.length) {
          var s3 = tt2(e3, qt3(Vu));
          r5 |= Hn2;
        }
        return Kn2(t3, r5, n3, e3, s3);
      });
      function ku(n3, t3, e3) {
        t3 = e3 ? i4 : t3;
        var r5 = Kn2(n3, Dn2, i4, i4, i4, i4, i4, t3);
        return r5.placeholder = ku.placeholder, r5;
      }
      function ju(n3, t3, e3) {
        t3 = e3 ? i4 : t3;
        var r5 = Kn2(n3, yt3, i4, i4, i4, i4, i4, t3);
        return r5.placeholder = ju.placeholder, r5;
      }
      function na(n3, t3, e3) {
        var r5, s3, o3, f5, c5, l4, v5 = 0, _6 = false, m5 = false, P4 = true;
        if (typeof n3 != "function")
          throw new wn2($4);
        t3 = xn2(t3) || 0, K4(e3) && (_6 = !!e3.leading, m5 = "maxWait" in e3, o3 = m5 ? Q5(xn2(e3.maxWait) || 0, t3) : o3, P4 = "trailing" in e3 ? !!e3.trailing : P4);
        function I3(J3) {
          var Tn = r5, Qn = s3;
          return r5 = s3 = i4, v5 = J3, f5 = n3.apply(Qn, Tn), f5;
        }
        function E6(J3) {
          return v5 = J3, c5 = le4(D6, t3), _6 ? I3(J3) : f5;
        }
        function b6(J3) {
          var Tn = J3 - l4, Qn = J3 - v5, wa = t3 - Tn;
          return m5 ? nn2(wa, o3 - Qn) : wa;
        }
        function y7(J3) {
          var Tn = J3 - l4, Qn = J3 - v5;
          return l4 === i4 || Tn >= t3 || Tn < 0 || m5 && Qn >= o3;
        }
        function D6() {
          var J3 = ir2();
          if (y7(J3))
            return N15(J3);
          c5 = le4(D6, b6(J3));
        }
        function N15(J3) {
          return c5 = i4, P4 && r5 ? I3(J3) : (r5 = s3 = i4, f5);
        }
        function dn2() {
          c5 !== i4 && cu(c5), v5 = 0, r5 = l4 = s3 = c5 = i4;
        }
        function sn2() {
          return c5 === i4 ? f5 : N15(ir2());
        }
        function gn() {
          var J3 = ir2(), Tn = y7(J3);
          if (r5 = arguments, s3 = this, l4 = J3, Tn) {
            if (c5 === i4)
              return E6(l4);
            if (m5)
              return cu(c5), c5 = le4(D6, t3), I3(l4);
          }
          return c5 === i4 && (c5 = le4(D6, t3)), f5;
        }
        return gn.cancel = dn2, gn.flush = sn2, gn;
      }
      var Vl = L4(function(n3, t3) {
        return Gs2(n3, 1, t3);
      }), kl = L4(function(n3, t3, e3) {
        return Gs2(n3, xn2(t3) || 0, e3);
      });
      function jl(n3) {
        return Kn2(n3, dr);
      }
      function sr2(n3, t3) {
        if (typeof n3 != "function" || t3 != null && typeof t3 != "function")
          throw new wn2($4);
        var e3 = function() {
          var r5 = arguments, s3 = t3 ? t3.apply(this, r5) : r5[0], o3 = e3.cache;
          if (o3.has(s3))
            return o3.get(s3);
          var f5 = n3.apply(this, r5);
          return e3.cache = o3.set(s3, f5) || o3, f5;
        };
        return e3.cache = new (sr2.Cache || Gn)(), e3;
      }
      sr2.Cache = Gn;
      function ur2(n3) {
        if (typeof n3 != "function")
          throw new wn2($4);
        return function() {
          var t3 = arguments;
          switch (t3.length) {
            case 0:
              return !n3.call(this);
            case 1:
              return !n3.call(this, t3[0]);
            case 2:
              return !n3.call(this, t3[0], t3[1]);
            case 3:
              return !n3.call(this, t3[0], t3[1], t3[2]);
          }
          return !n3.apply(this, t3);
        };
      }
      function np(n3) {
        return Qu(2, n3);
      }
      var tp = qc(function(n3, t3) {
        t3 = t3.length == 1 && O7(t3[0]) ? G3(t3[0], hn(x5())) : G3(j7(t3, 1), hn(x5()));
        var e3 = t3.length;
        return L4(function(r5) {
          for (var s3 = -1, o3 = nn2(r5.length, e3); ++s3 < o3; )
            r5[s3] = t3[s3].call(this, r5[s3]);
          return cn2(n3, this, r5);
        });
      }), xi = L4(function(n3, t3) {
        var e3 = tt2(t3, qt3(xi));
        return Kn2(n3, Hn2, i4, t3, e3);
      }), ta = L4(function(n3, t3) {
        var e3 = tt2(t3, qt3(ta));
        return Kn2(n3, St2, i4, t3, e3);
      }), ep = Yn(function(n3, t3) {
        return Kn2(n3, Kt3, i4, i4, i4, t3);
      });
      function rp(n3, t3) {
        if (typeof n3 != "function")
          throw new wn2($4);
        return t3 = t3 === i4 ? t3 : R3(t3), L4(n3, t3);
      }
      function ip(n3, t3) {
        if (typeof n3 != "function")
          throw new wn2($4);
        return t3 = t3 == null ? 0 : Q5(R3(t3), 0), L4(function(e3) {
          var r5 = e3[t3], s3 = ut3(e3, 0, t3);
          return r5 && nt3(s3, r5), cn2(n3, this, s3);
        });
      }
      function sp(n3, t3, e3) {
        var r5 = true, s3 = true;
        if (typeof n3 != "function")
          throw new wn2($4);
        return K4(e3) && (r5 = "leading" in e3 ? !!e3.leading : r5, s3 = "trailing" in e3 ? !!e3.trailing : s3), na(n3, t3, { leading: r5, maxWait: t3, trailing: s3 });
      }
      function up(n3) {
        return Xu(n3, 1);
      }
      function ap(n3, t3) {
        return xi(oi(t3), n3);
      }
      function op() {
        if (!arguments.length)
          return [];
        var n3 = arguments[0];
        return O7(n3) ? n3 : [n3];
      }
      function fp(n3) {
        return An(n3, xt3);
      }
      function cp(n3, t3) {
        return t3 = typeof t3 == "function" ? t3 : i4, An(n3, xt3, t3);
      }
      function hp(n3) {
        return An(n3, Ln2 | xt3);
      }
      function lp(n3, t3) {
        return t3 = typeof t3 == "function" ? t3 : i4, An(n3, Ln2 | xt3, t3);
      }
      function pp(n3, t3) {
        return t3 == null || Bs2(n3, t3, V5(t3));
      }
      function bn2(n3, t3) {
        return n3 === t3 || n3 !== n3 && t3 !== t3;
      }
      var dp = ke3(Qr), gp = ke3(function(n3, t3) {
        return n3 >= t3;
      }), Pt2 = Js2(function() {
        return arguments;
      }()) ? Js2 : function(n3) {
        return Y(n3) && F6.call(n3, "callee") && !Hs2.call(n3, "callee");
      }, O7 = p6.isArray, vp = gs2 ? hn(gs2) : xc;
      function an2(n3) {
        return n3 != null && ar2(n3.length) && !Jn2(n3);
      }
      function Z3(n3) {
        return Y(n3) && an2(n3);
      }
      function _p(n3) {
        return n3 === true || n3 === false || Y(n3) && en2(n3) == Yt2;
      }
      var at3 = Tf || Ni2, mp = vs2 ? hn(vs2) : Ec;
      function wp(n3) {
        return Y(n3) && n3.nodeType === 1 && !pe3(n3);
      }
      function Pp(n3) {
        if (n3 == null)
          return true;
        if (an2(n3) && (O7(n3) || typeof n3 == "string" || typeof n3.splice == "function" || at3(n3) || Bt3(n3) || Pt2(n3)))
          return !n3.length;
        var t3 = tn2(n3);
        if (t3 == yn2 || t3 == Sn2)
          return !n3.size;
        if (he4(n3))
          return !jr(n3).length;
        for (var e3 in n3)
          if (F6.call(n3, e3))
            return false;
        return true;
      }
      function Ap(n3, t3) {
        return oe4(n3, t3);
      }
      function Cp(n3, t3, e3) {
        e3 = typeof e3 == "function" ? e3 : i4;
        var r5 = e3 ? e3(n3, t3) : i4;
        return r5 === i4 ? oe4(n3, t3, i4, e3) : !!r5;
      }
      function Ei(n3) {
        if (!Y(n3))
          return false;
        var t3 = en2(n3);
        return t3 == we || t3 == Ga || typeof n3.message == "string" && typeof n3.name == "string" && !pe3(n3);
      }
      function Ip(n3) {
        return typeof n3 == "number" && $s2(n3);
      }
      function Jn2(n3) {
        if (!K4(n3))
          return false;
        var t3 = en2(n3);
        return t3 == Pe2 || t3 == Gi2 || t3 == Ba || t3 == Ka;
      }
      function ea(n3) {
        return typeof n3 == "number" && n3 == R3(n3);
      }
      function ar2(n3) {
        return typeof n3 == "number" && n3 > -1 && n3 % 1 == 0 && n3 <= kn2;
      }
      function K4(n3) {
        var t3 = typeof n3;
        return n3 != null && (t3 == "object" || t3 == "function");
      }
      function Y(n3) {
        return n3 != null && typeof n3 == "object";
      }
      var ra = _s2 ? hn(_s2) : Sc;
      function xp(n3, t3) {
        return n3 === t3 || kr(n3, t3, gi(t3));
      }
      function Ep(n3, t3, e3) {
        return e3 = typeof e3 == "function" ? e3 : i4, kr(n3, t3, gi(t3), e3);
      }
      function yp(n3) {
        return ia(n3) && n3 != +n3;
      }
      function Sp(n3) {
        if (ch(n3))
          throw new S5(T4);
        return Xs2(n3);
      }
      function Op(n3) {
        return n3 === null;
      }
      function Rp(n3) {
        return n3 == null;
      }
      function ia(n3) {
        return typeof n3 == "number" || Y(n3) && en2(n3) == Jt2;
      }
      function pe3(n3) {
        if (!Y(n3) || en2(n3) != qn2)
          return false;
        var t3 = He3(n3);
        if (t3 === null)
          return true;
        var e3 = F6.call(t3, "constructor") && t3.constructor;
        return typeof e3 == "function" && e3 instanceof e3 && be.call(e3) == Ef;
      }
      var yi = ms2 ? hn(ms2) : Oc;
      function bp(n3) {
        return ea(n3) && n3 >= -kn2 && n3 <= kn2;
      }
      var sa = ws2 ? hn(ws2) : Rc;
      function or3(n3) {
        return typeof n3 == "string" || !O7(n3) && Y(n3) && en2(n3) == Qt2;
      }
      function pn2(n3) {
        return typeof n3 == "symbol" || Y(n3) && en2(n3) == Ae2;
      }
      var Bt3 = Ps2 ? hn(Ps2) : bc;
      function Tp(n3) {
        return n3 === i4;
      }
      function Lp(n3) {
        return Y(n3) && tn2(n3) == Vt3;
      }
      function Dp(n3) {
        return Y(n3) && en2(n3) == Za;
      }
      var Hp = ke3(ni), Np = ke3(function(n3, t3) {
        return n3 <= t3;
      });
      function ua(n3) {
        if (!n3)
          return [];
        if (an2(n3))
          return or3(n3) ? On2(n3) : un2(n3);
        if (ne2 && n3[ne2])
          return pf(n3[ne2]());
        var t3 = tn2(n3), e3 = t3 == yn2 ? qr : t3 == Sn2 ? Se2 : Gt3;
        return e3(n3);
      }
      function Xn(n3) {
        if (!n3)
          return n3 === 0 ? n3 : 0;
        if (n3 = xn2(n3), n3 === ht3 || n3 === -ht3) {
          var t3 = n3 < 0 ? -1 : 1;
          return t3 * Wa;
        }
        return n3 === n3 ? n3 : 0;
      }
      function R3(n3) {
        var t3 = Xn(n3), e3 = t3 % 1;
        return t3 === t3 ? e3 ? t3 - e3 : t3 : 0;
      }
      function aa(n3) {
        return n3 ? vt3(R3(n3), 0, Nn) : 0;
      }
      function xn2(n3) {
        if (typeof n3 == "number")
          return n3;
        if (pn2(n3))
          return _e4;
        if (K4(n3)) {
          var t3 = typeof n3.valueOf == "function" ? n3.valueOf() : n3;
          n3 = K4(t3) ? t3 + "" : t3;
        }
        if (typeof n3 != "string")
          return n3 === 0 ? n3 : +n3;
        n3 = ys2(n3);
        var e3 = go.test(n3);
        return e3 || _o.test(n3) ? Xo(n3.slice(2), e3 ? 2 : 8) : po.test(n3) ? _e4 : +n3;
      }
      function oa(n3) {
        return Un(n3, on2(n3));
      }
      function $p(n3) {
        return n3 ? vt3(R3(n3), -kn2, kn2) : n3 === 0 ? n3 : 0;
      }
      function W4(n3) {
        return n3 == null ? "" : ln2(n3);
      }
      var Up = Ft3(function(n3, t3) {
        if (he4(t3) || an2(t3)) {
          Un(t3, V5(t3), n3);
          return;
        }
        for (var e3 in t3)
          F6.call(t3, e3) && se(n3, e3, t3[e3]);
      }), fa = Ft3(function(n3, t3) {
        Un(t3, on2(t3), n3);
      }), fr2 = Ft3(function(n3, t3, e3, r5) {
        Un(t3, on2(t3), n3, r5);
      }), Wp = Ft3(function(n3, t3, e3, r5) {
        Un(t3, V5(t3), n3, r5);
      }), Fp = Yn(Zr);
      function Mp(n3, t3) {
        var e3 = Wt2(n3);
        return t3 == null ? e3 : qs2(e3, t3);
      }
      var qp = L4(function(n3, t3) {
        n3 = M5(n3);
        var e3 = -1, r5 = t3.length, s3 = r5 > 2 ? t3[2] : i4;
        for (s3 && rn2(t3[0], t3[1], s3) && (r5 = 1); ++e3 < r5; )
          for (var o3 = t3[e3], f5 = on2(o3), c5 = -1, l4 = f5.length; ++c5 < l4; ) {
            var v5 = f5[c5], _6 = n3[v5];
            (_6 === i4 || bn2(_6, Nt3[v5]) && !F6.call(n3, v5)) && (n3[v5] = o3[v5]);
          }
        return n3;
      }), Bp = L4(function(n3) {
        return n3.push(i4, yu), cn2(ca, i4, n3);
      });
      function Gp(n3, t3) {
        return Cs2(n3, x5(t3, 3), $n2);
      }
      function zp(n3, t3) {
        return Cs2(n3, x5(t3, 3), Xr);
      }
      function Kp(n3, t3) {
        return n3 == null ? n3 : Jr(n3, x5(t3, 3), on2);
      }
      function Yp(n3, t3) {
        return n3 == null ? n3 : Ys2(n3, x5(t3, 3), on2);
      }
      function Zp(n3, t3) {
        return n3 && $n2(n3, x5(t3, 3));
      }
      function Jp(n3, t3) {
        return n3 && Xr(n3, x5(t3, 3));
      }
      function Xp(n3) {
        return n3 == null ? [] : ze3(n3, V5(n3));
      }
      function Qp(n3) {
        return n3 == null ? [] : ze3(n3, on2(n3));
      }
      function Si(n3, t3, e3) {
        var r5 = n3 == null ? i4 : _t3(n3, t3);
        return r5 === i4 ? e3 : r5;
      }
      function Vp(n3, t3) {
        return n3 != null && Ru(n3, t3, Pc);
      }
      function Oi(n3, t3) {
        return n3 != null && Ru(n3, t3, Ac);
      }
      var kp = Au(function(n3, t3, e3) {
        t3 != null && typeof t3.toString != "function" && (t3 = Te2.call(t3)), n3[t3] = e3;
      }, bi(fn2)), jp = Au(function(n3, t3, e3) {
        t3 != null && typeof t3.toString != "function" && (t3 = Te2.call(t3)), F6.call(n3, t3) ? n3[t3].push(e3) : n3[t3] = [e3];
      }, x5), nd = L4(ae3);
      function V5(n3) {
        return an2(n3) ? Fs2(n3) : jr(n3);
      }
      function on2(n3) {
        return an2(n3) ? Fs2(n3, true) : Tc(n3);
      }
      function td(n3, t3) {
        var e3 = {};
        return t3 = x5(t3, 3), $n2(n3, function(r5, s3, o3) {
          zn2(e3, t3(r5, s3, o3), r5);
        }), e3;
      }
      function ed(n3, t3) {
        var e3 = {};
        return t3 = x5(t3, 3), $n2(n3, function(r5, s3, o3) {
          zn2(e3, s3, t3(r5, s3, o3));
        }), e3;
      }
      var rd = Ft3(function(n3, t3, e3) {
        Ke2(n3, t3, e3);
      }), ca = Ft3(function(n3, t3, e3, r5) {
        Ke2(n3, t3, e3, r5);
      }), id2 = Yn(function(n3, t3) {
        var e3 = {};
        if (n3 == null)
          return e3;
        var r5 = false;
        t3 = G3(t3, function(o3) {
          return o3 = st3(o3, n3), r5 || (r5 = o3.length > 1), o3;
        }), Un(n3, pi(n3), e3), r5 && (e3 = An(e3, Ln2 | Fn2 | xt3, kc));
        for (var s3 = t3.length; s3--; )
          si(e3, t3[s3]);
        return e3;
      });
      function sd(n3, t3) {
        return ha(n3, ur2(x5(t3)));
      }
      var ud = Yn(function(n3, t3) {
        return n3 == null ? {} : Dc(n3, t3);
      });
      function ha(n3, t3) {
        if (n3 == null)
          return {};
        var e3 = G3(pi(n3), function(r5) {
          return [r5];
        });
        return t3 = x5(t3), eu(n3, e3, function(r5, s3) {
          return t3(r5, s3[0]);
        });
      }
      function ad(n3, t3, e3) {
        t3 = st3(t3, n3);
        var r5 = -1, s3 = t3.length;
        for (s3 || (s3 = 1, n3 = i4); ++r5 < s3; ) {
          var o3 = n3 == null ? i4 : n3[Wn(t3[r5])];
          o3 === i4 && (r5 = s3, o3 = e3), n3 = Jn2(o3) ? o3.call(n3) : o3;
        }
        return n3;
      }
      function od(n3, t3, e3) {
        return n3 == null ? n3 : fe2(n3, t3, e3);
      }
      function fd(n3, t3, e3, r5) {
        return r5 = typeof r5 == "function" ? r5 : i4, n3 == null ? n3 : fe2(n3, t3, e3, r5);
      }
      var la = xu(V5), pa = xu(on2);
      function cd(n3, t3, e3) {
        var r5 = O7(n3), s3 = r5 || at3(n3) || Bt3(n3);
        if (t3 = x5(t3, 4), e3 == null) {
          var o3 = n3 && n3.constructor;
          s3 ? e3 = r5 ? new o3() : [] : K4(n3) ? e3 = Jn2(o3) ? Wt2(He3(n3)) : {} : e3 = {};
        }
        return (s3 ? mn2 : $n2)(n3, function(f5, c5, l4) {
          return t3(e3, f5, c5, l4);
        }), e3;
      }
      function hd(n3, t3) {
        return n3 == null ? true : si(n3, t3);
      }
      function ld(n3, t3, e3) {
        return n3 == null ? n3 : au(n3, t3, oi(e3));
      }
      function pd(n3, t3, e3, r5) {
        return r5 = typeof r5 == "function" ? r5 : i4, n3 == null ? n3 : au(n3, t3, oi(e3), r5);
      }
      function Gt3(n3) {
        return n3 == null ? [] : Mr(n3, V5(n3));
      }
      function dd(n3) {
        return n3 == null ? [] : Mr(n3, on2(n3));
      }
      function gd(n3, t3, e3) {
        return e3 === i4 && (e3 = t3, t3 = i4), e3 !== i4 && (e3 = xn2(e3), e3 = e3 === e3 ? e3 : 0), t3 !== i4 && (t3 = xn2(t3), t3 = t3 === t3 ? t3 : 0), vt3(xn2(n3), t3, e3);
      }
      function vd(n3, t3, e3) {
        return t3 = Xn(t3), e3 === i4 ? (e3 = t3, t3 = 0) : e3 = Xn(e3), n3 = xn2(n3), Cc(n3, t3, e3);
      }
      function _d(n3, t3, e3) {
        if (e3 && typeof e3 != "boolean" && rn2(n3, t3, e3) && (t3 = e3 = i4), e3 === i4 && (typeof t3 == "boolean" ? (e3 = t3, t3 = i4) : typeof n3 == "boolean" && (e3 = n3, n3 = i4)), n3 === i4 && t3 === i4 ? (n3 = 0, t3 = 1) : (n3 = Xn(n3), t3 === i4 ? (t3 = n3, n3 = 0) : t3 = Xn(t3)), n3 > t3) {
          var r5 = n3;
          n3 = t3, t3 = r5;
        }
        if (e3 || n3 % 1 || t3 % 1) {
          var s3 = Us2();
          return nn2(n3 + s3 * (t3 - n3 + Jo("1e-" + ((s3 + "").length - 1))), t3);
        }
        return ei(n3, t3);
      }
      var md = Mt3(function(n3, t3, e3) {
        return t3 = t3.toLowerCase(), n3 + (e3 ? da(t3) : t3);
      });
      function da(n3) {
        return Ri(W4(n3).toLowerCase());
      }
      function ga(n3) {
        return n3 = W4(n3), n3 && n3.replace(wo, of2).replace(Wo, "");
      }
      function wd(n3, t3, e3) {
        n3 = W4(n3), t3 = ln2(t3);
        var r5 = n3.length;
        e3 = e3 === i4 ? r5 : vt3(R3(e3), 0, r5);
        var s3 = e3;
        return e3 -= t3.length, e3 >= 0 && n3.slice(e3, s3) == t3;
      }
      function Pd(n3) {
        return n3 = W4(n3), n3 && ka.test(n3) ? n3.replace(Yi2, ff) : n3;
      }
      function Ad(n3) {
        return n3 = W4(n3), n3 && io.test(n3) ? n3.replace(xr2, "\\$&") : n3;
      }
      var Cd = Mt3(function(n3, t3, e3) {
        return n3 + (e3 ? "-" : "") + t3.toLowerCase();
      }), Id = Mt3(function(n3, t3, e3) {
        return n3 + (e3 ? " " : "") + t3.toLowerCase();
      }), xd = mu("toLowerCase");
      function Ed(n3, t3, e3) {
        n3 = W4(n3), t3 = R3(t3);
        var r5 = t3 ? Dt3(n3) : 0;
        if (!t3 || r5 >= t3)
          return n3;
        var s3 = (t3 - r5) / 2;
        return Ve3(We3(s3), e3) + n3 + Ve3(Ue3(s3), e3);
      }
      function yd(n3, t3, e3) {
        n3 = W4(n3), t3 = R3(t3);
        var r5 = t3 ? Dt3(n3) : 0;
        return t3 && r5 < t3 ? n3 + Ve3(t3 - r5, e3) : n3;
      }
      function Sd(n3, t3, e3) {
        n3 = W4(n3), t3 = R3(t3);
        var r5 = t3 ? Dt3(n3) : 0;
        return t3 && r5 < t3 ? Ve3(t3 - r5, e3) + n3 : n3;
      }
      function Od(n3, t3, e3) {
        return e3 || t3 == null ? t3 = 0 : t3 && (t3 = +t3), Nf(W4(n3).replace(Er2, ""), t3 || 0);
      }
      function Rd(n3, t3, e3) {
        return (e3 ? rn2(n3, t3, e3) : t3 === i4) ? t3 = 1 : t3 = R3(t3), ri(W4(n3), t3);
      }
      function bd() {
        var n3 = arguments, t3 = W4(n3[0]);
        return n3.length < 3 ? t3 : t3.replace(n3[1], n3[2]);
      }
      var Td = Mt3(function(n3, t3, e3) {
        return n3 + (e3 ? "_" : "") + t3.toLowerCase();
      });
      function Ld(n3, t3, e3) {
        return e3 && typeof e3 != "number" && rn2(n3, t3, e3) && (t3 = e3 = i4), e3 = e3 === i4 ? Nn : e3 >>> 0, e3 ? (n3 = W4(n3), n3 && (typeof t3 == "string" || t3 != null && !yi(t3)) && (t3 = ln2(t3), !t3 && Lt3(n3)) ? ut3(On2(n3), 0, e3) : n3.split(t3, e3)) : [];
      }
      var Dd = Mt3(function(n3, t3, e3) {
        return n3 + (e3 ? " " : "") + Ri(t3);
      });
      function Hd(n3, t3, e3) {
        return n3 = W4(n3), e3 = e3 == null ? 0 : vt3(R3(e3), 0, n3.length), t3 = ln2(t3), n3.slice(e3, e3 + t3.length) == t3;
      }
      function Nd(n3, t3, e3) {
        var r5 = a4.templateSettings;
        e3 && rn2(n3, t3, e3) && (t3 = i4), n3 = W4(n3), t3 = fr2({}, t3, r5, Eu);
        var s3 = fr2({}, t3.imports, r5.imports, Eu), o3 = V5(s3), f5 = Mr(s3, o3), c5, l4, v5 = 0, _6 = t3.interpolate || Ce3, m5 = "__p += '", P4 = Br((t3.escape || Ce3).source + "|" + _6.source + "|" + (_6 === Zi2 ? lo : Ce3).source + "|" + (t3.evaluate || Ce3).source + "|$", "g"), I3 = "//# sourceURL=" + (F6.call(t3, "sourceURL") ? (t3.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Go + "]") + `
`;
        n3.replace(P4, function(y7, D6, N15, dn2, sn2, gn) {
          return N15 || (N15 = dn2), m5 += n3.slice(v5, gn).replace(Po, cf), D6 && (c5 = true, m5 += `' +
__e(` + D6 + `) +
'`), sn2 && (l4 = true, m5 += `';
` + sn2 + `;
__p += '`), N15 && (m5 += `' +
((__t = (` + N15 + `)) == null ? '' : __t) +
'`), v5 = gn + y7.length, y7;
        }), m5 += `';
`;
        var E6 = F6.call(t3, "variable") && t3.variable;
        if (!E6)
          m5 = `with (obj) {
` + m5 + `
}
`;
        else if (co.test(E6))
          throw new S5(En2);
        m5 = (l4 ? m5.replace(Ja, "") : m5).replace(Xa, "$1").replace(Qa, "$1;"), m5 = "function(" + (E6 || "obj") + `) {
` + (E6 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c5 ? ", __e = _.escape" : "") + (l4 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m5 + `return __p
}`;
        var b6 = _a2(function() {
          return U5(o3, I3 + "return " + m5).apply(i4, f5);
        });
        if (b6.source = m5, Ei(b6))
          throw b6;
        return b6;
      }
      function $d(n3) {
        return W4(n3).toLowerCase();
      }
      function Ud(n3) {
        return W4(n3).toUpperCase();
      }
      function Wd(n3, t3, e3) {
        if (n3 = W4(n3), n3 && (e3 || t3 === i4))
          return ys2(n3);
        if (!n3 || !(t3 = ln2(t3)))
          return n3;
        var r5 = On2(n3), s3 = On2(t3), o3 = Ss2(r5, s3), f5 = Os2(r5, s3) + 1;
        return ut3(r5, o3, f5).join("");
      }
      function Fd(n3, t3, e3) {
        if (n3 = W4(n3), n3 && (e3 || t3 === i4))
          return n3.slice(0, bs2(n3) + 1);
        if (!n3 || !(t3 = ln2(t3)))
          return n3;
        var r5 = On2(n3), s3 = Os2(r5, On2(t3)) + 1;
        return ut3(r5, 0, s3).join("");
      }
      function Md(n3, t3, e3) {
        if (n3 = W4(n3), n3 && (e3 || t3 === i4))
          return n3.replace(Er2, "");
        if (!n3 || !(t3 = ln2(t3)))
          return n3;
        var r5 = On2(n3), s3 = Ss2(r5, On2(t3));
        return ut3(r5, s3).join("");
      }
      function qd(n3, t3) {
        var e3 = La, r5 = Da;
        if (K4(t3)) {
          var s3 = "separator" in t3 ? t3.separator : s3;
          e3 = "length" in t3 ? R3(t3.length) : e3, r5 = "omission" in t3 ? ln2(t3.omission) : r5;
        }
        n3 = W4(n3);
        var o3 = n3.length;
        if (Lt3(n3)) {
          var f5 = On2(n3);
          o3 = f5.length;
        }
        if (e3 >= o3)
          return n3;
        var c5 = e3 - Dt3(r5);
        if (c5 < 1)
          return r5;
        var l4 = f5 ? ut3(f5, 0, c5).join("") : n3.slice(0, c5);
        if (s3 === i4)
          return l4 + r5;
        if (f5 && (c5 += l4.length - c5), yi(s3)) {
          if (n3.slice(c5).search(s3)) {
            var v5, _6 = l4;
            for (s3.global || (s3 = Br(s3.source, W4(Ji2.exec(s3)) + "g")), s3.lastIndex = 0; v5 = s3.exec(_6); )
              var m5 = v5.index;
            l4 = l4.slice(0, m5 === i4 ? c5 : m5);
          }
        } else if (n3.indexOf(ln2(s3), c5) != c5) {
          var P4 = l4.lastIndexOf(s3);
          P4 > -1 && (l4 = l4.slice(0, P4));
        }
        return l4 + r5;
      }
      function Bd(n3) {
        return n3 = W4(n3), n3 && Va.test(n3) ? n3.replace(Ki2, _f) : n3;
      }
      var Gd = Mt3(function(n3, t3, e3) {
        return n3 + (e3 ? " " : "") + t3.toUpperCase();
      }), Ri = mu("toUpperCase");
      function va(n3, t3, e3) {
        return n3 = W4(n3), t3 = e3 ? i4 : t3, t3 === i4 ? lf(n3) ? Pf(n3) : ef(n3) : n3.match(t3) || [];
      }
      var _a2 = L4(function(n3, t3) {
        try {
          return cn2(n3, i4, t3);
        } catch (e3) {
          return Ei(e3) ? e3 : new S5(e3);
        }
      }), zd = Yn(function(n3, t3) {
        return mn2(t3, function(e3) {
          e3 = Wn(e3), zn2(n3, e3, Ii(n3[e3], n3));
        }), n3;
      });
      function Kd(n3) {
        var t3 = n3 == null ? 0 : n3.length, e3 = x5();
        return n3 = t3 ? G3(n3, function(r5) {
          if (typeof r5[1] != "function")
            throw new wn2($4);
          return [e3(r5[0]), r5[1]];
        }) : [], L4(function(r5) {
          for (var s3 = -1; ++s3 < t3; ) {
            var o3 = n3[s3];
            if (cn2(o3[0], this, r5))
              return cn2(o3[1], this, r5);
          }
        });
      }
      function Yd(n3) {
        return _c(An(n3, Ln2));
      }
      function bi(n3) {
        return function() {
          return n3;
        };
      }
      function Zd(n3, t3) {
        return n3 == null || n3 !== n3 ? t3 : n3;
      }
      var Jd = Pu(), Xd = Pu(true);
      function fn2(n3) {
        return n3;
      }
      function Ti(n3) {
        return Qs2(typeof n3 == "function" ? n3 : An(n3, Ln2));
      }
      function Qd(n3) {
        return ks2(An(n3, Ln2));
      }
      function Vd(n3, t3) {
        return js2(n3, An(t3, Ln2));
      }
      var kd = L4(function(n3, t3) {
        return function(e3) {
          return ae3(e3, n3, t3);
        };
      }), jd = L4(function(n3, t3) {
        return function(e3) {
          return ae3(n3, e3, t3);
        };
      });
      function Li(n3, t3, e3) {
        var r5 = V5(t3), s3 = ze3(t3, r5);
        e3 == null && !(K4(t3) && (s3.length || !r5.length)) && (e3 = t3, t3 = n3, n3 = this, s3 = ze3(t3, V5(t3)));
        var o3 = !(K4(e3) && "chain" in e3) || !!e3.chain, f5 = Jn2(n3);
        return mn2(s3, function(c5) {
          var l4 = t3[c5];
          n3[c5] = l4, f5 && (n3.prototype[c5] = function() {
            var v5 = this.__chain__;
            if (o3 || v5) {
              var _6 = n3(this.__wrapped__), m5 = _6.__actions__ = un2(this.__actions__);
              return m5.push({ func: l4, args: arguments, thisArg: n3 }), _6.__chain__ = v5, _6;
            }
            return l4.apply(n3, nt3([this.value()], arguments));
          });
        }), n3;
      }
      function ng() {
        return k5._ === this && (k5._ = yf), this;
      }
      function Di() {
      }
      function tg(n3) {
        return n3 = R3(n3), L4(function(t3) {
          return nu(t3, n3);
        });
      }
      var eg = ci(G3), rg = ci(As2), ig = ci(Nr);
      function ma(n3) {
        return _i(n3) ? $r(Wn(n3)) : Hc(n3);
      }
      function sg(n3) {
        return function(t3) {
          return n3 == null ? i4 : _t3(n3, t3);
        };
      }
      var ug = Cu(), ag = Cu(true);
      function Hi2() {
        return [];
      }
      function Ni2() {
        return false;
      }
      function og() {
        return {};
      }
      function fg() {
        return "";
      }
      function cg() {
        return true;
      }
      function hg(n3, t3) {
        if (n3 = R3(n3), n3 < 1 || n3 > kn2)
          return [];
        var e3 = Nn, r5 = nn2(n3, Nn);
        t3 = x5(t3), n3 -= Nn;
        for (var s3 = Fr(r5, t3); ++e3 < n3; )
          t3(e3);
        return s3;
      }
      function lg(n3) {
        return O7(n3) ? G3(n3, Wn) : pn2(n3) ? [n3] : un2(Wu(W4(n3)));
      }
      function pg(n3) {
        var t3 = ++xf;
        return W4(n3) + t3;
      }
      var dg = Qe3(function(n3, t3) {
        return n3 + t3;
      }, 0), gg = hi("ceil"), vg = Qe3(function(n3, t3) {
        return n3 / t3;
      }, 1), _g = hi("floor");
      function mg(n3) {
        return n3 && n3.length ? Ge3(n3, fn2, Qr) : i4;
      }
      function wg(n3, t3) {
        return n3 && n3.length ? Ge3(n3, x5(t3, 2), Qr) : i4;
      }
      function Pg(n3) {
        return xs2(n3, fn2);
      }
      function Ag(n3, t3) {
        return xs2(n3, x5(t3, 2));
      }
      function Cg(n3) {
        return n3 && n3.length ? Ge3(n3, fn2, ni) : i4;
      }
      function Ig(n3, t3) {
        return n3 && n3.length ? Ge3(n3, x5(t3, 2), ni) : i4;
      }
      var xg = Qe3(function(n3, t3) {
        return n3 * t3;
      }, 1), Eg = hi("round"), yg = Qe3(function(n3, t3) {
        return n3 - t3;
      }, 0);
      function Sg(n3) {
        return n3 && n3.length ? Wr(n3, fn2) : 0;
      }
      function Og(n3, t3) {
        return n3 && n3.length ? Wr(n3, x5(t3, 2)) : 0;
      }
      return a4.after = Ql, a4.ary = Xu, a4.assign = Up, a4.assignIn = fa, a4.assignInWith = fr2, a4.assignWith = Wp, a4.at = Fp, a4.before = Qu, a4.bind = Ii, a4.bindAll = zd, a4.bindKey = Vu, a4.castArray = op, a4.chain = Yu, a4.chunk = _h, a4.compact = mh, a4.concat = wh, a4.cond = Kd, a4.conforms = Yd, a4.constant = bi, a4.countBy = Sl, a4.create = Mp, a4.curry = ku, a4.curryRight = ju, a4.debounce = na, a4.defaults = qp, a4.defaultsDeep = Bp, a4.defer = Vl, a4.delay = kl, a4.difference = Ph, a4.differenceBy = Ah, a4.differenceWith = Ch, a4.drop = Ih, a4.dropRight = xh, a4.dropRightWhile = Eh, a4.dropWhile = yh, a4.fill = Sh, a4.filter = Rl, a4.flatMap = Ll, a4.flatMapDeep = Dl, a4.flatMapDepth = Hl, a4.flatten = Bu, a4.flattenDeep = Oh, a4.flattenDepth = Rh, a4.flip = jl, a4.flow = Jd, a4.flowRight = Xd, a4.fromPairs = bh, a4.functions = Xp, a4.functionsIn = Qp, a4.groupBy = Nl, a4.initial = Lh, a4.intersection = Dh, a4.intersectionBy = Hh, a4.intersectionWith = Nh, a4.invert = kp, a4.invertBy = jp, a4.invokeMap = Ul, a4.iteratee = Ti, a4.keyBy = Wl, a4.keys = V5, a4.keysIn = on2, a4.map = rr2, a4.mapKeys = td, a4.mapValues = ed, a4.matches = Qd, a4.matchesProperty = Vd, a4.memoize = sr2, a4.merge = rd, a4.mergeWith = ca, a4.method = kd, a4.methodOf = jd, a4.mixin = Li, a4.negate = ur2, a4.nthArg = tg, a4.omit = id2, a4.omitBy = sd, a4.once = np, a4.orderBy = Fl, a4.over = eg, a4.overArgs = tp, a4.overEvery = rg, a4.overSome = ig, a4.partial = xi, a4.partialRight = ta, a4.partition = Ml, a4.pick = ud, a4.pickBy = ha, a4.property = ma, a4.propertyOf = sg, a4.pull = Fh, a4.pullAll = zu, a4.pullAllBy = Mh, a4.pullAllWith = qh, a4.pullAt = Bh, a4.range = ug, a4.rangeRight = ag, a4.rearg = ep, a4.reject = Gl, a4.remove = Gh, a4.rest = rp, a4.reverse = Ai2, a4.sampleSize = Kl, a4.set = od, a4.setWith = fd, a4.shuffle = Yl, a4.slice = zh, a4.sortBy = Xl, a4.sortedUniq = Vh, a4.sortedUniqBy = kh, a4.split = Ld, a4.spread = ip, a4.tail = jh, a4.take = nl, a4.takeRight = tl, a4.takeRightWhile = el, a4.takeWhile = rl, a4.tap = ml, a4.throttle = sp, a4.thru = er3, a4.toArray = ua, a4.toPairs = la, a4.toPairsIn = pa, a4.toPath = lg, a4.toPlainObject = oa, a4.transform = cd, a4.unary = up, a4.union = il, a4.unionBy = sl, a4.unionWith = ul, a4.uniq = al, a4.uniqBy = ol, a4.uniqWith = fl, a4.unset = hd, a4.unzip = Ci, a4.unzipWith = Ku, a4.update = ld, a4.updateWith = pd, a4.values = Gt3, a4.valuesIn = dd, a4.without = cl, a4.words = va, a4.wrap = ap, a4.xor = hl, a4.xorBy = ll, a4.xorWith = pl, a4.zip = dl, a4.zipObject = gl, a4.zipObjectDeep = vl, a4.zipWith = _l, a4.entries = la, a4.entriesIn = pa, a4.extend = fa, a4.extendWith = fr2, Li(a4, a4), a4.add = dg, a4.attempt = _a2, a4.camelCase = md, a4.capitalize = da, a4.ceil = gg, a4.clamp = gd, a4.clone = fp, a4.cloneDeep = hp, a4.cloneDeepWith = lp, a4.cloneWith = cp, a4.conformsTo = pp, a4.deburr = ga, a4.defaultTo = Zd, a4.divide = vg, a4.endsWith = wd, a4.eq = bn2, a4.escape = Pd, a4.escapeRegExp = Ad, a4.every = Ol, a4.find = bl, a4.findIndex = Mu, a4.findKey = Gp, a4.findLast = Tl, a4.findLastIndex = qu, a4.findLastKey = zp, a4.floor = _g, a4.forEach = Zu, a4.forEachRight = Ju, a4.forIn = Kp, a4.forInRight = Yp, a4.forOwn = Zp, a4.forOwnRight = Jp, a4.get = Si, a4.gt = dp, a4.gte = gp, a4.has = Vp, a4.hasIn = Oi, a4.head = Gu, a4.identity = fn2, a4.includes = $l, a4.indexOf = Th, a4.inRange = vd, a4.invoke = nd, a4.isArguments = Pt2, a4.isArray = O7, a4.isArrayBuffer = vp, a4.isArrayLike = an2, a4.isArrayLikeObject = Z3, a4.isBoolean = _p, a4.isBuffer = at3, a4.isDate = mp, a4.isElement = wp, a4.isEmpty = Pp, a4.isEqual = Ap, a4.isEqualWith = Cp, a4.isError = Ei, a4.isFinite = Ip, a4.isFunction = Jn2, a4.isInteger = ea, a4.isLength = ar2, a4.isMap = ra, a4.isMatch = xp, a4.isMatchWith = Ep, a4.isNaN = yp, a4.isNative = Sp, a4.isNil = Rp, a4.isNull = Op, a4.isNumber = ia, a4.isObject = K4, a4.isObjectLike = Y, a4.isPlainObject = pe3, a4.isRegExp = yi, a4.isSafeInteger = bp, a4.isSet = sa, a4.isString = or3, a4.isSymbol = pn2, a4.isTypedArray = Bt3, a4.isUndefined = Tp, a4.isWeakMap = Lp, a4.isWeakSet = Dp, a4.join = $h, a4.kebabCase = Cd, a4.last = In, a4.lastIndexOf = Uh, a4.lowerCase = Id, a4.lowerFirst = xd, a4.lt = Hp, a4.lte = Np, a4.max = mg, a4.maxBy = wg, a4.mean = Pg, a4.meanBy = Ag, a4.min = Cg, a4.minBy = Ig, a4.stubArray = Hi2, a4.stubFalse = Ni2, a4.stubObject = og, a4.stubString = fg, a4.stubTrue = cg, a4.multiply = xg, a4.nth = Wh, a4.noConflict = ng, a4.noop = Di, a4.now = ir2, a4.pad = Ed, a4.padEnd = yd, a4.padStart = Sd, a4.parseInt = Od, a4.random = _d, a4.reduce = ql, a4.reduceRight = Bl, a4.repeat = Rd, a4.replace = bd, a4.result = ad, a4.round = Eg, a4.runInContext = h6, a4.sample = zl, a4.size = Zl, a4.snakeCase = Td, a4.some = Jl, a4.sortedIndex = Kh, a4.sortedIndexBy = Yh, a4.sortedIndexOf = Zh, a4.sortedLastIndex = Jh, a4.sortedLastIndexBy = Xh, a4.sortedLastIndexOf = Qh, a4.startCase = Dd, a4.startsWith = Hd, a4.subtract = yg, a4.sum = Sg, a4.sumBy = Og, a4.template = Nd, a4.times = hg, a4.toFinite = Xn, a4.toInteger = R3, a4.toLength = aa, a4.toLower = $d, a4.toNumber = xn2, a4.toSafeInteger = $p, a4.toString = W4, a4.toUpper = Ud, a4.trim = Wd, a4.trimEnd = Fd, a4.trimStart = Md, a4.truncate = qd, a4.unescape = Bd, a4.uniqueId = pg, a4.upperCase = Gd, a4.upperFirst = Ri, a4.each = Zu, a4.eachRight = Ju, a4.first = Gu, Li(a4, function() {
        var n3 = {};
        return $n2(a4, function(t3, e3) {
          F6.call(a4.prototype, e3) || (n3[e3] = t3);
        }), n3;
      }(), { chain: false }), a4.VERSION = d4, mn2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n3) {
        a4[n3].placeholder = a4;
      }), mn2(["drop", "take"], function(n3, t3) {
        H3.prototype[n3] = function(e3) {
          e3 = e3 === i4 ? 1 : Q5(R3(e3), 0);
          var r5 = this.__filtered__ && !t3 ? new H3(this) : this.clone();
          return r5.__filtered__ ? r5.__takeCount__ = nn2(e3, r5.__takeCount__) : r5.__views__.push({ size: nn2(e3, Nn), type: n3 + (r5.__dir__ < 0 ? "Right" : "") }), r5;
        }, H3.prototype[n3 + "Right"] = function(e3) {
          return this.reverse()[n3](e3).reverse();
        };
      }), mn2(["filter", "map", "takeWhile"], function(n3, t3) {
        var e3 = t3 + 1, r5 = e3 == Bi2 || e3 == Ua;
        H3.prototype[n3] = function(s3) {
          var o3 = this.clone();
          return o3.__iteratees__.push({ iteratee: x5(s3, 3), type: e3 }), o3.__filtered__ = o3.__filtered__ || r5, o3;
        };
      }), mn2(["head", "last"], function(n3, t3) {
        var e3 = "take" + (t3 ? "Right" : "");
        H3.prototype[n3] = function() {
          return this[e3](1).value()[0];
        };
      }), mn2(["initial", "tail"], function(n3, t3) {
        var e3 = "drop" + (t3 ? "" : "Right");
        H3.prototype[n3] = function() {
          return this.__filtered__ ? new H3(this) : this[e3](1);
        };
      }), H3.prototype.compact = function() {
        return this.filter(fn2);
      }, H3.prototype.find = function(n3) {
        return this.filter(n3).head();
      }, H3.prototype.findLast = function(n3) {
        return this.reverse().find(n3);
      }, H3.prototype.invokeMap = L4(function(n3, t3) {
        return typeof n3 == "function" ? new H3(this) : this.map(function(e3) {
          return ae3(e3, n3, t3);
        });
      }), H3.prototype.reject = function(n3) {
        return this.filter(ur2(x5(n3)));
      }, H3.prototype.slice = function(n3, t3) {
        n3 = R3(n3);
        var e3 = this;
        return e3.__filtered__ && (n3 > 0 || t3 < 0) ? new H3(e3) : (n3 < 0 ? e3 = e3.takeRight(-n3) : n3 && (e3 = e3.drop(n3)), t3 !== i4 && (t3 = R3(t3), e3 = t3 < 0 ? e3.dropRight(-t3) : e3.take(t3 - n3)), e3);
      }, H3.prototype.takeRightWhile = function(n3) {
        return this.reverse().takeWhile(n3).reverse();
      }, H3.prototype.toArray = function() {
        return this.take(Nn);
      }, $n2(H3.prototype, function(n3, t3) {
        var e3 = /^(?:filter|find|map|reject)|While$/.test(t3), r5 = /^(?:head|last)$/.test(t3), s3 = a4[r5 ? "take" + (t3 == "last" ? "Right" : "") : t3], o3 = r5 || /^find/.test(t3);
        s3 && (a4.prototype[t3] = function() {
          var f5 = this.__wrapped__, c5 = r5 ? [1] : arguments, l4 = f5 instanceof H3, v5 = c5[0], _6 = l4 || O7(f5), m5 = function(D6) {
            var N15 = s3.apply(a4, nt3([D6], c5));
            return r5 && P4 ? N15[0] : N15;
          };
          _6 && e3 && typeof v5 == "function" && v5.length != 1 && (l4 = _6 = false);
          var P4 = this.__chain__, I3 = !!this.__actions__.length, E6 = o3 && !P4, b6 = l4 && !I3;
          if (!o3 && _6) {
            f5 = b6 ? f5 : new H3(this);
            var y7 = n3.apply(f5, c5);
            return y7.__actions__.push({ func: er3, args: [m5], thisArg: i4 }), new Pn(y7, P4);
          }
          return E6 && b6 ? n3.apply(this, c5) : (y7 = this.thru(m5), E6 ? r5 ? y7.value()[0] : y7.value() : y7);
        });
      }), mn2(["pop", "push", "shift", "sort", "splice", "unshift"], function(n3) {
        var t3 = Oe[n3], e3 = /^(?:push|sort|unshift)$/.test(n3) ? "tap" : "thru", r5 = /^(?:pop|shift)$/.test(n3);
        a4.prototype[n3] = function() {
          var s3 = arguments;
          if (r5 && !this.__chain__) {
            var o3 = this.value();
            return t3.apply(O7(o3) ? o3 : [], s3);
          }
          return this[e3](function(f5) {
            return t3.apply(O7(f5) ? f5 : [], s3);
          });
        };
      }), $n2(H3.prototype, function(n3, t3) {
        var e3 = a4[t3];
        if (e3) {
          var r5 = e3.name + "";
          F6.call(Ut2, r5) || (Ut2[r5] = []), Ut2[r5].push({ name: t3, func: e3 });
        }
      }), Ut2[Xe3(i4, ct3).name] = [{ name: "wrapper", func: i4 }], H3.prototype.clone = Bf, H3.prototype.reverse = Gf, H3.prototype.value = zf, a4.prototype.at = wl, a4.prototype.chain = Pl, a4.prototype.commit = Al, a4.prototype.next = Cl, a4.prototype.plant = xl, a4.prototype.reverse = El, a4.prototype.toJSON = a4.prototype.valueOf = a4.prototype.value = yl, a4.prototype.first = a4.prototype.head, ne2 && (a4.prototype[ne2] = Il), a4;
    }, Ht2 = Af();
    lt3 ? ((lt3.exports = Ht2)._ = Ht2, Tr2._ = Ht2) : k5._ = Ht2;
  }).call(ge2);
})(Ui, Ui.exports);
var qg = Object.defineProperty;
var Bg = Object.defineProperties;
var Gg = Object.getOwnPropertyDescriptors;
var Ea = Object.getOwnPropertySymbols;
var zg = Object.prototype.hasOwnProperty;
var Kg = Object.prototype.propertyIsEnumerable;
var ya = (C2, u5, i4) => u5 in C2 ? qg(C2, u5, { enumerable: true, configurable: true, writable: true, value: i4 }) : C2[u5] = i4;
var cr2 = (C2, u5) => {
  for (var i4 in u5 || (u5 = {}))
    zg.call(u5, i4) && ya(C2, i4, u5[i4]);
  if (Ea)
    for (var i4 of Ea(u5))
      Kg.call(u5, i4) && ya(C2, i4, u5[i4]);
  return C2;
};
var Yg = (C2, u5) => Bg(C2, Gg(u5));
function ft3(C2, u5, i4) {
  var d4;
  const w5 = ve(C2);
  return ((d4 = u5.rpcMap) == null ? void 0 : d4[w5.reference]) || `${Mg}?chainId=${w5.namespace}:${w5.reference}&projectId=${i4}`;
}
function Ct3(C2) {
  return C2.includes(":") ? C2.split(":")[1] : C2;
}
function Sa(C2) {
  return C2.map((u5) => `${u5.split(":")[0]}:${u5.split(":")[1]}`);
}
function Zg(C2, u5) {
  const i4 = Object.keys(u5.namespaces).filter((w5) => w5.includes(C2));
  if (!i4.length)
    return [];
  const d4 = [];
  return i4.forEach((w5) => {
    const T4 = u5.namespaces[w5].accounts;
    d4.push(...T4);
  }), d4;
}
function Jg(C2 = {}, u5 = {}) {
  const i4 = Oa(C2), d4 = Oa(u5);
  return Ui.exports.merge(i4, d4);
}
function Oa(C2) {
  var u5, i4, d4, w5;
  const T4 = {};
  if (!B(C2))
    return T4;
  for (const [$4, En2] of Object.entries(C2)) {
    const zt3 = oe($4) ? [$4] : En2.chains, pr = En2.methods || [], It2 = En2.events || [], Ln2 = En2.rpcMap || {}, Fn2 = Xe($4);
    T4[Fn2] = Yg(cr2(cr2({}, T4[Fn2]), En2), { chains: S(zt3, (u5 = T4[Fn2]) == null ? void 0 : u5.chains), methods: S(pr, (i4 = T4[Fn2]) == null ? void 0 : i4.methods), events: S(It2, (d4 = T4[Fn2]) == null ? void 0 : d4.events), rpcMap: cr2(cr2({}, Ln2), (w5 = T4[Fn2]) == null ? void 0 : w5.rpcMap) });
  }
  return T4;
}
function Xg(C2) {
  return C2.includes(":") ? C2.split(":")[2] : C2;
}
function Qg(C2) {
  const u5 = {};
  for (const [i4, d4] of Object.entries(C2)) {
    const w5 = d4.methods || [], T4 = d4.events || [], $4 = d4.accounts || [], En2 = oe(i4) ? [i4] : d4.chains ? d4.chains : Sa(d4.accounts);
    u5[i4] = { chains: En2, methods: w5, events: T4, accounts: $4 };
  }
  return u5;
}
function Wi2(C2) {
  return typeof C2 == "number" ? C2 : C2.includes("0x") ? parseInt(C2, 16) : C2.includes(":") ? Number(C2.split(":")[1]) : Number(C2);
}
var Ra = {};
var z2 = (C2) => Ra[C2];
var Fi = (C2, u5) => {
  Ra[C2] = u5;
};
var Vg = class {
  constructor(u5) {
    this.name = "polkadot", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(u5, i4), this.chainId = u5, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u5}`);
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      const w5 = Ct3(i4);
      u5[w5] = this.createHttpProvider(w5, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(u5, this.namespace, this.client.core.projectId);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var kg = class {
  constructor(u5) {
    this.name = "eip155", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(u5) {
    switch (u5.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(u5);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
    }
    return this.namespace.methods.includes(u5.request.method) ? await this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(parseInt(u5), i4), this.chainId = parseInt(u5), this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u5}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId.toString();
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(`${this.name}:${u5}`, this.namespace, this.client.core.projectId);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new HttpConnection(d4, z2("disableProviderPing")));
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      const w5 = parseInt(Ct3(i4));
      u5[w5] = this.createHttpProvider(w5, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? [...new Set(u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const u5 = this.chainId, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  async handleSwitchChain(u5) {
    var i4, d4;
    let w5 = u5.request.params ? (i4 = u5.request.params[0]) == null ? void 0 : i4.chainId : "0x0";
    w5 = w5.startsWith("0x") ? w5 : `0x${w5}`;
    const T4 = parseInt(w5, 16);
    if (this.isChainApproved(T4))
      this.setDefaultChain(`${T4}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
      await this.client.request({ topic: u5.topic, request: { method: u5.request.method, params: [{ chainId: w5 }] }, chainId: (d4 = this.namespace.chains) == null ? void 0 : d4[0] }), this.setDefaultChain(`${T4}`);
    else
      throw new Error(`Failed to switch to chain 'eip155:${T4}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(u5) {
    return this.namespace.chains.includes(`${this.name}:${u5}`);
  }
};
var jg = class {
  constructor(u5) {
    this.name = "solana", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(u5, i4), this.chainId = u5, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u5}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? [...new Set(u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      const w5 = Ct3(i4);
      u5[w5] = this.createHttpProvider(w5, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(u5, this.namespace, this.client.core.projectId);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var nv = class {
  constructor(u5) {
    this.name = "cosmos", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(u5, i4), this.chainId = u5, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? [...new Set(u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      const w5 = Ct3(i4);
      u5[w5] = this.createHttpProvider(w5, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(u5, this.namespace, this.client.core.projectId);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var tv = class {
  constructor(u5) {
    this.name = "cip34", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(u5, i4), this.chainId = u5, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? [...new Set(u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      const d4 = this.getCardanoRPCUrl(i4), w5 = Ct3(i4);
      u5[w5] = this.createHttpProvider(w5, d4);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  getCardanoRPCUrl(u5) {
    const i4 = this.namespace.rpcMap;
    if (i4)
      return i4[u5];
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || this.getCardanoRPCUrl(u5);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var ev = class {
  constructor(u5) {
    this.name = "elrond", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(u5, i4), this.chainId = u5, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u5}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? [...new Set(u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      const w5 = Ct3(i4);
      u5[w5] = this.createHttpProvider(w5, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(u5, this.namespace, this.client.core.projectId);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var rv = class {
  constructor(u5) {
    this.name = "multiversx", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    this.httpProviders[u5] || this.setHttpProvider(u5, i4), this.chainId = u5, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u5}`);
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? [...new Set(u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      const w5 = Ct3(i4);
      u5[w5] = this.createHttpProvider(w5, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(u5, this.namespace, this.client.core.projectId);
    if (!d4)
      throw new Error(`No RPC url provided for chainId: ${u5}`);
    return new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var iv = class {
  constructor(u5) {
    this.name = "near", this.namespace = u5.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(u5) {
    this.namespace = Object.assign(this.namespace, u5);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId)
      return this.chainId;
    if (this.namespace.defaultChain)
      return this.namespace.defaultChain;
    const u5 = this.namespace.chains[0];
    if (!u5)
      throw new Error("ChainId not found");
    return u5.split(":")[1];
  }
  request(u5) {
    return this.namespace.methods.includes(u5.request.method) ? this.client.request(u5) : this.getHttpProvider().request(u5.request);
  }
  setDefaultChain(u5, i4) {
    if (this.chainId = u5, !this.httpProviders[u5]) {
      const d4 = i4 || ft3(`${this.name}:${u5}`, this.namespace);
      if (!d4)
        throw new Error(`No RPC url provided for chainId: ${u5}`);
      this.setHttpProvider(u5, d4);
    }
    this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const u5 = this.namespace.accounts;
    return u5 ? u5.filter((i4) => i4.split(":")[1] === this.chainId.toString()).map((i4) => i4.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const u5 = {};
    return this.namespace.chains.forEach((i4) => {
      var d4;
      u5[i4] = this.createHttpProvider(i4, (d4 = this.namespace.rpcMap) == null ? void 0 : d4[i4]);
    }), u5;
  }
  getHttpProvider() {
    const u5 = `${this.name}:${this.chainId}`, i4 = this.httpProviders[u5];
    if (typeof i4 > "u")
      throw new Error(`JSON-RPC provider for ${u5} not found`);
    return i4;
  }
  setHttpProvider(u5, i4) {
    const d4 = this.createHttpProvider(u5, i4);
    d4 && (this.httpProviders[u5] = d4);
  }
  createHttpProvider(u5, i4) {
    const d4 = i4 || ft3(u5, this.namespace);
    return typeof d4 > "u" ? void 0 : new JsonRpcProvider(new esm_default2(d4, z2("disableProviderPing")));
  }
};
var sv = Object.defineProperty;
var uv = Object.defineProperties;
var av = Object.getOwnPropertyDescriptors;
var ba = Object.getOwnPropertySymbols;
var ov = Object.prototype.hasOwnProperty;
var fv = Object.prototype.propertyIsEnumerable;
var Ta = (C2, u5, i4) => u5 in C2 ? sv(C2, u5, { enumerable: true, configurable: true, writable: true, value: i4 }) : C2[u5] = i4;
var hr2 = (C2, u5) => {
  for (var i4 in u5 || (u5 = {}))
    ov.call(u5, i4) && Ta(C2, i4, u5[i4]);
  if (ba)
    for (var i4 of ba(u5))
      fv.call(u5, i4) && Ta(C2, i4, u5[i4]);
  return C2;
};
var Mi = (C2, u5) => uv(C2, av(u5));
var lr = class _lr {
  constructor(u5) {
    this.events = new import_events8.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = u5, this.logger = typeof (u5 == null ? void 0 : u5.logger) < "u" && typeof (u5 == null ? void 0 : u5.logger) != "string" ? u5.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: (u5 == null ? void 0 : u5.logger) || Ia })), this.disableProviderPing = (u5 == null ? void 0 : u5.disableProviderPing) || false;
  }
  static async init(u5) {
    const i4 = new _lr(u5);
    return await i4.initialize(), i4;
  }
  async request(u5, i4) {
    const [d4, w5] = this.validateChain(i4);
    if (!this.session)
      throw new Error("Please call connect() before request()");
    return await this.getProvider(d4).request({ request: hr2({}, u5), chainId: `${d4}:${w5}`, topic: this.session.topic });
  }
  sendAsync(u5, i4, d4) {
    this.request(u5, d4).then((w5) => i4(null, w5)).catch((w5) => i4(w5, void 0));
  }
  async enable() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var u5;
    if (!this.session)
      throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (u5 = this.session) == null ? void 0 : u5.topic, reason: U("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(u5) {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (this.setNamespaces(u5), await this.cleanupPendingPairings(), !u5.skipPairing)
      return await this.pair(u5.pairingTopic);
  }
  on(u5, i4) {
    this.events.on(u5, i4);
  }
  once(u5, i4) {
    this.events.once(u5, i4);
  }
  removeListener(u5, i4) {
    this.events.removeListener(u5, i4);
  }
  off(u5, i4) {
    this.events.off(u5, i4);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(u5) {
    this.shouldAbortPairingAttempt = false;
    let i4 = 0;
    do {
      if (this.shouldAbortPairingAttempt)
        throw new Error("Pairing aborted");
      if (i4 >= this.maxPairingAttempts)
        throw new Error("Max auto pairing attempts reached");
      const { uri: d4, approval: w5 } = await this.client.connect({ pairingTopic: u5, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      d4 && (this.uri = d4, this.events.emit("display_uri", d4)), await w5().then((T4) => {
        this.session = T4, this.namespaces || (this.namespaces = Qg(T4.namespaces), this.persist("namespaces", this.namespaces));
      }).catch((T4) => {
        if (T4.message !== oe3)
          throw T4;
        i4++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(u5, i4) {
    try {
      if (!this.session)
        return;
      const [d4, w5] = this.validateChain(u5);
      this.getProvider(d4).setDefaultChain(w5, i4);
    } catch (d4) {
      if (!/Please call connect/.test(d4.message))
        throw d4;
    }
  }
  async cleanupPendingPairings(u5 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const i4 = this.client.pairing.getAll();
    if (D(i4)) {
      for (const d4 of i4)
        u5.deletePairings ? this.client.core.expirer.set(d4.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(d4.topic);
      this.logger.info(`Inactive pairings cleared: ${i4.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const u5 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[u5]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Q3.init({ logger: this.providerOpts.logger || Ia, relayUrl: this.providerOpts.relayUrl || Ug, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client)
      throw new Error("Sign Client not initialized");
    if (!this.session)
      throw new Error("Session not initialized. Please call connect() before enable()");
    const u5 = [...new Set(Object.keys(this.session.namespaces).map((i4) => Xe(i4)))];
    Fi("client", this.client), Fi("events", this.events), Fi("disableProviderPing", this.disableProviderPing), u5.forEach((i4) => {
      if (!this.session)
        return;
      const d4 = Zg(i4, this.session), w5 = Sa(d4), T4 = Jg(this.namespaces, this.optionalNamespaces), $4 = Mi(hr2({}, T4[i4]), { accounts: d4, chains: w5 });
      switch (i4) {
        case "eip155":
          this.rpcProviders[i4] = new kg({ namespace: $4 });
          break;
        case "solana":
          this.rpcProviders[i4] = new jg({ namespace: $4 });
          break;
        case "cosmos":
          this.rpcProviders[i4] = new nv({ namespace: $4 });
          break;
        case "polkadot":
          this.rpcProviders[i4] = new Vg({ namespace: $4 });
          break;
        case "cip34":
          this.rpcProviders[i4] = new tv({ namespace: $4 });
          break;
        case "elrond":
          this.rpcProviders[i4] = new ev({ namespace: $4 });
          break;
        case "multiversx":
          this.rpcProviders[i4] = new rv({ namespace: $4 });
          break;
        case "near":
          this.rpcProviders[i4] = new iv({ namespace: $4 });
          break;
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u")
      throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (u5) => {
      this.events.emit("session_ping", u5);
    }), this.client.on("session_event", (u5) => {
      const { params: i4 } = u5, { event: d4 } = i4;
      if (d4.name === "accountsChanged") {
        const w5 = d4.data;
        w5 && D(w5) && this.events.emit("accountsChanged", w5.map(Xg));
      } else if (d4.name === "chainChanged") {
        const w5 = i4.chainId, T4 = i4.event.data, $4 = Xe(w5), En2 = Wi2(w5) !== Wi2(T4) ? `${$4}:${Wi2(T4)}` : w5;
        this.onChainChanged(En2);
      } else
        this.events.emit(d4.name, d4.data);
      this.events.emit("session_event", u5);
    }), this.client.on("session_update", ({ topic: u5, params: i4 }) => {
      var d4;
      const { namespaces: w5 } = i4, T4 = (d4 = this.client) == null ? void 0 : d4.session.get(u5);
      this.session = Mi(hr2({}, T4), { namespaces: w5 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: u5, params: i4 });
    }), this.client.on("session_delete", async (u5) => {
      await this.cleanup(), this.events.emit("session_delete", u5), this.events.emit("disconnect", Mi(hr2({}, U("USER_DISCONNECTED")), { data: u5.topic }));
    }), this.on(Vn2.DEFAULT_CHAIN_CHANGED, (u5) => {
      this.onChainChanged(u5, true);
    });
  }
  getProvider(u5) {
    if (!this.rpcProviders[u5])
      throw new Error(`Provider not found: ${u5}`);
    return this.rpcProviders[u5];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((u5) => {
      var i4;
      this.getProvider(u5).updateNamespace((i4 = this.session) == null ? void 0 : i4.namespaces[u5]);
    });
  }
  setNamespaces(u5) {
    const { namespaces: i4, optionalNamespaces: d4, sessionProperties: w5 } = u5;
    i4 && Object.keys(i4).length && (this.namespaces = i4), d4 && Object.keys(d4).length && (this.optionalNamespaces = d4), this.sessionProperties = w5, this.persist("namespaces", i4), this.persist("optionalNamespaces", d4);
  }
  validateChain(u5) {
    const [i4, d4] = (u5 == null ? void 0 : u5.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length)
      return [i4, d4];
    if (i4 && !Object.keys(this.namespaces || {}).map(($4) => Xe($4)).includes(i4))
      throw new Error(`Namespace '${i4}' is not configured. Please call connect() first with namespace config.`);
    if (i4 && d4)
      return [i4, d4];
    const w5 = Xe(Object.keys(this.namespaces)[0]), T4 = this.rpcProviders[w5].getDefaultChain();
    return [w5, T4];
  }
  async requestAccounts() {
    const [u5] = this.validateChain();
    return await this.getProvider(u5).requestAccounts();
  }
  onChainChanged(u5, i4 = false) {
    var d4;
    if (!this.namespaces)
      return;
    const [w5, T4] = this.validateChain(u5);
    i4 || this.getProvider(w5).setDefaultChain(T4), ((d4 = this.namespaces[w5]) != null ? d4 : this.namespaces[`${w5}:${T4}`]).defaultChain = T4, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", T4);
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(u5, i4) {
    this.client.core.storage.setItem(`${xa}/${u5}`, i4);
  }
  async getFromStore(u5) {
    return await this.client.core.storage.getItem(`${xa}/${u5}`);
  }
};
var cv = lr;

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var P = "wc";
var S3 = "ethereum_provider";
var $2 = `${P}@2:${S3}:`;
var j4 = "https://rpc.walletconnect.com/v1/";
var u2 = ["eth_sendTransaction", "personal_sign"];
var E4 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
var m2 = ["chainChanged", "accountsChanged"];
var _3 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var N12 = Object.defineProperty;
var q2 = Object.defineProperties;
var D4 = Object.getOwnPropertyDescriptors;
var y4 = Object.getOwnPropertySymbols;
var U4 = Object.prototype.hasOwnProperty;
var Q4 = Object.prototype.propertyIsEnumerable;
var O5 = (a4, t3, s3) => t3 in a4 ? N12(a4, t3, { enumerable: true, configurable: true, writable: true, value: s3 }) : a4[t3] = s3;
var p3 = (a4, t3) => {
  for (var s3 in t3 || (t3 = {}))
    U4.call(t3, s3) && O5(a4, s3, t3[s3]);
  if (y4)
    for (var s3 of y4(t3))
      Q4.call(t3, s3) && O5(a4, s3, t3[s3]);
  return a4;
};
var M3 = (a4, t3) => q2(a4, D4(t3));
function g4(a4) {
  return Number(a4[0].split(":")[1]);
}
function f2(a4) {
  return `0x${a4.toString(16)}`;
}
function L2(a4) {
  const { chains: t3, optionalChains: s3, methods: i4, optionalMethods: n3, events: e3, optionalEvents: h6, rpcMap: c5 } = a4;
  if (!D(t3))
    throw new Error("Invalid chains");
  const o3 = { chains: t3, methods: i4 || u2, events: e3 || m2, rpcMap: p3({}, t3.length ? { [g4(t3)]: c5[g4(t3)] } : {}) }, r5 = e3 == null ? void 0 : e3.filter((l4) => !m2.includes(l4)), d4 = i4 == null ? void 0 : i4.filter((l4) => !u2.includes(l4));
  if (!s3 && !h6 && !n3 && !(r5 != null && r5.length) && !(d4 != null && d4.length))
    return { required: t3.length ? o3 : void 0 };
  const C2 = (r5 == null ? void 0 : r5.length) && (d4 == null ? void 0 : d4.length) || !s3, I3 = { chains: [...new Set(C2 ? o3.chains.concat(s3 || []) : s3)], methods: [...new Set(o3.methods.concat(n3 != null && n3.length ? n3 : E4))], events: [...new Set(o3.events.concat(h6 != null && h6.length ? h6 : _3))], rpcMap: c5 };
  return { required: t3.length ? o3 : void 0, optional: s3.length ? I3 : void 0 };
}
var v2 = class _v {
  constructor() {
    this.events = new import_events9.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = $2, this.on = (t3, s3) => (this.events.on(t3, s3), this), this.once = (t3, s3) => (this.events.once(t3, s3), this), this.removeListener = (t3, s3) => (this.events.removeListener(t3, s3), this), this.off = (t3, s3) => (this.events.off(t3, s3), this), this.parseAccount = (t3) => this.isCompatibleChainId(t3) ? this.parseAccountId(t3).address : t3, this.signer = {}, this.rpc = {};
  }
  static async init(t3) {
    const s3 = new _v();
    return await s3.initialize(t3), s3;
  }
  async request(t3) {
    return await this.signer.request(t3, this.formatChainId(this.chainId));
  }
  sendAsync(t3, s3) {
    this.signer.sendAsync(t3, s3, this.formatChainId(this.chainId));
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t3) {
    if (!this.signer.client)
      throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t3);
    const { required: s3, optional: i4 } = L2(this.rpc);
    try {
      const n3 = await new Promise(async (h6, c5) => {
        var o3;
        this.rpc.showQrModal && ((o3 = this.modal) == null || o3.subscribeModal((r5) => {
          !r5.open && !this.signer.session && (this.signer.abortPairingAttempt(), c5(new Error("Connection request reset. Please try again.")));
        })), await this.signer.connect(M3(p3({ namespaces: p3({}, s3 && { [this.namespace]: s3 }) }, i4 && { optionalNamespaces: { [this.namespace]: i4 } }), { pairingTopic: t3 == null ? void 0 : t3.pairingTopic })).then((r5) => {
          h6(r5);
        }).catch((r5) => {
          c5(new Error(r5.message));
        });
      });
      if (!n3)
        return;
      const e3 = Rn(n3.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : e3), this.setAccounts(e3), this.events.emit("connect", { chainId: f2(this.chainId) });
    } catch (n3) {
      throw this.signer.logger.error(n3), n3;
    } finally {
      this.modal && this.modal.closeModal();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t3) => {
      const { params: s3 } = t3, { event: i4 } = s3;
      i4.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i4.data), this.events.emit("accountsChanged", this.accounts)) : i4.name === "chainChanged" ? this.setChainId(this.formatChainId(i4.data)) : this.events.emit(i4.name, i4.data), this.events.emit("session_event", t3);
    }), this.signer.on("chainChanged", (t3) => {
      const s3 = parseInt(t3);
      this.chainId = s3, this.events.emit("chainChanged", f2(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t3) => {
      this.events.emit("session_update", t3);
    }), this.signer.on("session_delete", (t3) => {
      this.reset(), this.events.emit("session_delete", t3), this.events.emit("disconnect", M3(p3({}, U("USER_DISCONNECTED")), { data: t3.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t3) => {
      var s3, i4;
      this.rpc.showQrModal && ((s3 = this.modal) == null || s3.closeModal(), (i4 = this.modal) == null || i4.openModal({ uri: t3 })), this.events.emit("display_uri", t3);
    });
  }
  switchEthereumChain(t3) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t3.toString(16) }] });
  }
  isCompatibleChainId(t3) {
    return typeof t3 == "string" ? t3.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t3) {
    return `${this.namespace}:${t3}`;
  }
  parseChainId(t3) {
    return Number(t3.split(":")[1]);
  }
  setChainIds(t3) {
    const s3 = t3.filter((i4) => this.isCompatibleChainId(i4)).map((i4) => this.parseChainId(i4));
    s3.length && (this.chainId = s3[0], this.events.emit("chainChanged", f2(this.chainId)), this.persist());
  }
  setChainId(t3) {
    if (this.isCompatibleChainId(t3)) {
      const s3 = this.parseChainId(t3);
      this.chainId = s3, this.switchEthereumChain(s3);
    }
  }
  parseAccountId(t3) {
    const [s3, i4, n3] = t3.split(":");
    return { chainId: `${s3}:${i4}`, address: n3 };
  }
  setAccounts(t3) {
    this.accounts = t3.filter((s3) => this.parseChainId(this.parseAccountId(s3).chainId) === this.chainId).map((s3) => this.parseAccountId(s3).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t3) {
    var s3, i4;
    const n3 = (s3 = t3 == null ? void 0 : t3.chains) != null ? s3 : [], e3 = (i4 = t3 == null ? void 0 : t3.optionalChains) != null ? i4 : [], h6 = n3.concat(e3);
    if (!h6.length)
      throw new Error("No chains specified in either `chains` or `optionalChains`");
    const c5 = n3.length ? (t3 == null ? void 0 : t3.methods) || u2 : [], o3 = n3.length ? (t3 == null ? void 0 : t3.events) || m2 : [], r5 = (t3 == null ? void 0 : t3.optionalMethods) || [], d4 = (t3 == null ? void 0 : t3.optionalEvents) || [], C2 = (t3 == null ? void 0 : t3.rpcMap) || this.buildRpcMap(h6, t3.projectId), I3 = (t3 == null ? void 0 : t3.qrModalOptions) || void 0;
    return { chains: n3 == null ? void 0 : n3.map((l4) => this.formatChainId(l4)), optionalChains: e3.map((l4) => this.formatChainId(l4)), methods: c5, events: o3, optionalMethods: r5, optionalEvents: d4, rpcMap: C2, showQrModal: !!(t3 != null && t3.showQrModal), qrModalOptions: I3, projectId: t3.projectId, metadata: t3.metadata };
  }
  buildRpcMap(t3, s3) {
    const i4 = {};
    return t3.forEach((n3) => {
      i4[n3] = this.getRpcUrl(n3, s3);
    }), i4;
  }
  async initialize(t3) {
    if (this.rpc = this.getRpcConfig(t3), this.chainId = this.rpc.chains.length ? g4(this.rpc.chains) : g4(this.rpc.optionalChains), this.signer = await cv.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t3.disableProviderPing, relayUrl: t3.relayUrl, storageOptions: t3.storageOptions }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let s3;
      try {
        const { WalletConnectModal: i4 } = await import("./ethereum-provider-ON42UBUD.js");
        s3 = i4;
      } catch {
        throw new Error("To use QR modal, please install @walletconnect/modal package");
      }
      if (s3)
        try {
          this.modal = new s3(p3({ walletConnectVersion: 2, projectId: this.rpc.projectId, standaloneChains: this.rpc.chains }, this.rpc.qrModalOptions));
        } catch (i4) {
          throw this.signer.logger.error(i4), new Error("Could not generate WalletConnectModal Instance");
        }
    }
  }
  loadConnectOpts(t3) {
    if (!t3)
      return;
    const { chains: s3, optionalChains: i4, rpcMap: n3 } = t3;
    s3 && D(s3) && (this.rpc.chains = s3.map((e3) => this.formatChainId(e3)), s3.forEach((e3) => {
      this.rpc.rpcMap[e3] = (n3 == null ? void 0 : n3[e3]) || this.getRpcUrl(e3);
    })), i4 && D(i4) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i4 == null ? void 0 : i4.map((e3) => this.formatChainId(e3)), i4.forEach((e3) => {
      this.rpc.rpcMap[e3] = (n3 == null ? void 0 : n3[e3]) || this.getRpcUrl(e3);
    }));
  }
  getRpcUrl(t3, s3) {
    var i4;
    return ((i4 = this.rpc.rpcMap) == null ? void 0 : i4[t3]) || `${j4}?chainId=eip155:${t3}&projectId=${s3 || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (!this.session)
      return;
    const t3 = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s3 = this.session.namespaces[`${this.namespace}:${t3}`] ? this.session.namespaces[`${this.namespace}:${t3}`] : this.session.namespaces[this.namespace];
    this.setChainIds(t3 ? [this.formatChainId(t3)] : s3 == null ? void 0 : s3.accounts), this.setAccounts(s3 == null ? void 0 : s3.accounts);
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t3) {
    return typeof t3 == "string" || t3 instanceof String ? [this.parseAccount(t3)] : t3.map((s3) => this.parseAccount(s3));
  }
};

// node_modules/ethers/lib.esm/ethers.js
var ethers_exports = {};
__export(ethers_exports, {
  BaseContract: () => BaseContract,
  BigNumber: () => BigNumber,
  Contract: () => Contract,
  ContractFactory: () => ContractFactory,
  FixedNumber: () => FixedNumber,
  Signer: () => Signer,
  VoidSigner: () => VoidSigner,
  Wallet: () => Wallet,
  Wordlist: () => Wordlist,
  constants: () => lib_exports2,
  errors: () => ErrorCode,
  getDefaultProvider: () => getDefaultProvider,
  logger: () => logger46,
  providers: () => lib_exports4,
  utils: () => utils_exports,
  version: () => version27,
  wordlists: () => wordlists
});

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var import_bn = __toESM(require_bn());

// node_modules/@ethersproject/logger/lib.esm/_version.js
var version2 = "logger/5.7.0";

// node_modules/@ethersproject/logger/lib.esm/index.js
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
var _logLevel = LogLevels["default"];
var _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
var HEX = "0123456789abcdef";
var Logger = class _Logger {
  constructor(version28) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version28,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(_Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(_Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(_Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = _Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value = params[key2];
      try {
        if (value instanceof Uint8Array) {
          let hex = "";
          for (let i4 = 0; i4 < value.length; i4++) {
            hex += HEX[value[i4] >> 4];
            hex += HEX[value[i4] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value));
        }
      } catch (error2) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";
    switch (code2) {
      case ErrorCode.NUMERIC_FAULT: {
        url = "NUMERIC_FAULT";
        const fault = message;
        switch (fault) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            url += "-" + fault;
            break;
          case "negative-power":
          case "negative-width":
            url += "-unsupported";
            break;
          case "unbound-bitwise-result":
            url += "-unbound-result";
            break;
        }
        break;
      }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code2;
        break;
    }
    if (url) {
      message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error = new Error(message);
    error.reason = reason;
    error.code = code2;
    Object.keys(params).forEach(function(key2) {
      error[key2] = params[key2];
    });
    return error;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value) {
    return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value);
  }
  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 9007199254740991) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value
      });
    }
    if (value % 1) {
      this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new _Logger(version2);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      _Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version28) {
    return new _Logger(version28);
  }
};
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

// node_modules/@ethersproject/bytes/lib.esm/_version.js
var version3 = "bytes/5.7.0";

// node_modules/@ethersproject/bytes/lib.esm/index.js
var logger = new Logger(version3);
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (let i4 = 0; i4 < value.length; i4++) {
    const v5 = value[i4];
    if (!isInteger(v5) || v5 < 0 || v5 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    let hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    const result = [];
    for (let i4 = 0; i4 < hex.length; i4 += 2) {
      result.push(parseInt(hex.substring(i4, i4 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat2(items) {
  const objects = items.map((item) => arrayify(item));
  const length2 = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length2);
  objects.reduce((offset, object2) => {
    result.set(object2, offset);
    return offset + object2.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value, length2) {
  value = arrayify(value);
  if (value.length > length2) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length2);
  result.set(value, length2 - value.length);
  return addSlice(result);
}
function isHexString(value, length2) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length2 && value.length !== 2 + 2 * length2) {
    return false;
  }
  return true;
}
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";
    while (value) {
      hex = HexCharacters[value & 15] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    let result = "0x";
    for (let i4 = 0; i4 < value.length; i4++) {
      let v5 = value[i4];
      result += HexCharacters[(v5 & 240) >> 4] + HexCharacters[v5 & 15];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data3) {
  if (typeof data3 !== "string") {
    data3 = hexlify(data3);
  } else if (!isHexString(data3) || data3.length % 2) {
    return null;
  }
  return (data3.length - 2) / 2;
}
function hexDataSlice(data3, offset, endOffset) {
  if (typeof data3 !== "string") {
    data3 = hexlify(data3);
  } else if (!isHexString(data3) || data3.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data3);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data3.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data3.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed2 = hexStripZeros(hexlify(value, { hexPad: "left" }));
  if (trimmed2 === "0x") {
    return "0x0";
  }
  return trimmed2;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  let offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length2) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length2 + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length2 + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature2)) {
    let bytes = arrayify(signature2);
    if (bytes.length === 64) {
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 127;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature2);
    }
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes[32] |= 128;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs3 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs3);
      const recoveryParam = vs3[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs3[0] &= 127;
      const s3 = hexlify(vs3);
      if (result.s == null) {
        result.s = s3;
      } else if (result.s !== s3) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs2 = arrayify(result.s);
    if (vs2[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs2[0] |= 128;
    }
    const _vs = hexlify(vs2);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat2([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}

// node_modules/@ethersproject/bignumber/lib.esm/_version.js
var version4 = "bignumber/5.7.0";

// node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
var BN = import_bn.default.BN;
var logger2 = new Logger(version4);
var _constructorGuard = {};
var MAX_SAFE = 9007199254740991;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes(value));
}
var _warnedToStringRadix = false;
var BigNumber = class _BigNumber {
  constructor(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }
  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }
  abs() {
    if (this._hex[0] === "-") {
      return _BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o3 = _BigNumber.from(other);
    if (o3.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  }
  pow(other) {
    const value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  }
  and(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  }
  or(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  }
  xor(other) {
    const value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  }
  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  }
  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  }
  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e3) {
    }
    return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value) {
    if (value instanceof _BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new _BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new _BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger2.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return _BigNumber.from(String(value));
    }
    const anyValue = value;
    if (typeof anyValue === "bigint") {
      return _BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return _BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return _BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
            return _BigNumber.from(hex);
          }
        }
      }
    }
    return logger2.throwArgumentError("invalid BigNumber value", "value", value);
  }
  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }
};
function toHex(value) {
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  if (value[0] === "-") {
    value = value.substring(1);
    if (value[0] === "-") {
      logger2.throwArgumentError("invalid hex", "value", value);
    }
    value = toHex(value);
    if (value === "0x00") {
      return value;
    }
    return "-" + value;
  }
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (value === "0x") {
    return "0x00";
  }
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  const hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  const params = { fault, operation };
  if (value != null) {
    params.value = value;
  }
  return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}

// node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
var logger3 = new Logger(version4);
var _constructorGuard2 = {};
var Zero = BigNumber.from(0);
var NegativeOne = BigNumber.from(-1);
function throwFault2(message, fault, operation, value) {
  const params = { fault, operation };
  if (value !== void 0) {
    params.value = value;
  }
  return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e3) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value = BigNumber.from(value);
  const negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  let fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger3.throwArgumentError("invalid decimal value", "value", value);
  }
  const negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger3.throwArgumentError("missing value", "value", value);
  }
  const comps = value.split(".");
  if (comps.length > 2) {
    logger3.throwArgumentError("too many decimal points", "value", value);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
var FixedFormat = class _FixedFormat {
  constructor(constructorGuard, signed2, width, decimals) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed2;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value) {
    if (value instanceof _FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }
    let signed2 = true;
    let width = 128;
    let decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
      } else if (value === "ufixed") {
        signed2 = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger3.throwArgumentError("invalid fixed format", "format", value);
        }
        signed2 = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key2, type2, defaultValue) => {
        if (value[key2] == null) {
          return defaultValue;
        }
        if (typeof value[key2] !== type2) {
          logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type2 + ")", "format." + key2, value[key2]);
        }
        return value[key2];
      };
      signed2 = check("signed", "boolean", signed2);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new _FixedFormat(_constructorGuard2, signed2, width, decimals);
  }
};
var FixedNumber = class _FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard2) {
      logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a4 = parseFixed(this._value, this.format.decimals);
    const b6 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a4.add(b6), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a4 = parseFixed(this._value, this.format.decimals);
    const b6 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a4.sub(b6), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a4 = parseFixed(this._value, this.format.decimals);
    const b6 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a4.mul(b6).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a4 = parseFixed(this._value, this.format.decimals);
    const b6 = parseFixed(other._value, other.format.decimals);
    return _FixedNumber.fromValue(a4.mul(this.format._multiplier).div(b6), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = _FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = _FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  // @TODO: Support other rounding algorithms
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = _FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger3.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format) {
    return _FixedNumber.fromString(this._value, format);
  }
  static fromValue(value, decimals, format) {
    if (format == null && decimals != null && !isBigNumberish(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return _FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }
  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault2("unsigned value cannot be negative", "overflow", "value", value);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }
    const fixedFormat = FixedFormat.from(format);
    if (arrayify(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric = BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new _FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
  }
  static from(value, format) {
    if (typeof value === "string") {
      return _FixedNumber.fromString(value, format);
    }
    if (isBytes(value)) {
      return _FixedNumber.fromBytes(value, format);
    }
    try {
      return _FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
  }
  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }
};
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

// node_modules/@ethersproject/properties/lib.esm/_version.js
var version5 = "properties/5.7.0";

// node_modules/@ethersproject/properties/lib.esm/index.js
var __awaiter2 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger4 = new Logger(version5);
function defineReadOnly(object2, name2, value) {
  Object.defineProperty(object2, name2, {
    enumerable: true,
    value,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i4 = 0; i4 < 32; i4++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object2) {
  return __awaiter2(this, void 0, void 0, function* () {
    const promises = Object.keys(object2).map((key2) => {
      const value = object2[key2];
      return Promise.resolve(value).then((v5) => ({ key: key2, value: v5 }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object2, properties) {
  if (!object2 || typeof object2 !== "object") {
    logger4.throwArgumentError("invalid object", "object", object2);
  }
  Object.keys(object2).forEach((key2) => {
    if (!properties[key2]) {
      logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object2);
    }
  });
}
function shallowCopy(object2) {
  const result = {};
  for (const key2 in object2) {
    result[key2] = object2[key2];
  }
  return result;
}
var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object2) {
  if (object2 === void 0 || object2 === null || opaque[typeof object2]) {
    return true;
  }
  if (Array.isArray(object2) || typeof object2 === "object") {
    if (!Object.isFrozen(object2)) {
      return false;
    }
    const keys2 = Object.keys(object2);
    for (let i4 = 0; i4 < keys2.length; i4++) {
      let value = null;
      try {
        value = object2[keys2[i4]];
      } catch (error) {
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function _deepCopy(object2) {
  if (_isFrozen(object2)) {
    return object2;
  }
  if (Array.isArray(object2)) {
    return Object.freeze(object2.map((item) => deepCopy(item)));
  }
  if (typeof object2 === "object") {
    const result = {};
    for (const key2 in object2) {
      const value = object2[key2];
      if (value === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value));
    }
    return result;
  }
  return logger4.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function deepCopy(object2) {
  return _deepCopy(object2);
}
var Description = class {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
};

// node_modules/@ethersproject/abi/lib.esm/_version.js
var version6 = "abi/5.7.0";

// node_modules/@ethersproject/abi/lib.esm/fragments.js
var logger5 = new Logger(version6);
var _constructorGuard3 = {};
var ModifiersBytes = { calldata: true, memory: true, storage: true };
var ModifiersNest = { calldata: true, memory: true };
function checkModifier(type2, name2) {
  if (type2 === "bytes" || type2 === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type2 === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type2.indexOf("[") >= 0 || type2 === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger5.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i4) {
    logger5.throwArgumentError(`unexpected character at position ${i4}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i4 = 0; i4 < param.length; i4++) {
    let c5 = param[i4];
    switch (c5) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i4);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i4);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i4);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i4);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i4);
              }
              if (node.indexed) {
                throwError2(i4);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i4);
        }
        node.type += c5;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i4);
        }
        node.type += c5;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c5;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c5;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c5;
        } else {
          throwError2(i4);
        }
    }
  }
  if (node.parent) {
    logger5.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object2, params) {
  for (let key2 in params) {
    defineReadOnly(object2, key2, params[key2]);
  }
}
var FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = class _ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: _ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return _ParamType.fromString(value, allowIndexed);
    }
    return _ParamType.fromObject(value);
  }
  static fromObject(value) {
    if (_ParamType.isParamType(value)) {
      return value;
    }
    return new _ParamType(_constructorGuard3, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(_ParamType.fromObject) : null
    });
  }
  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return _ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  }
  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }
};
function parseParams(value, allowIndex) {
  return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
var Fragment = class _Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard3) {
      logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value) {
    if (_Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return _Fragment.fromString(value);
    }
    return _Fragment.fromObject(value);
  }
  static fromObject(value) {
    if (_Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        return null;
    }
    return logger5.throwArgumentError("invalid fragment object", "value", value);
  }
  static fromString(value) {
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger5.throwArgumentError("unsupported fragment", "value", value);
  }
  static isFragment(value) {
    return !!(value && value._isFragment);
  }
};
var EventFragment = class _EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return _EventFragment.fromString(value);
    }
    return _EventFragment.fromObject(value);
  }
  static fromObject(value) {
    if (_EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger5.throwArgumentError("invalid event object", "value", value);
    }
    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new _EventFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let match = value.match(regexParen);
    if (!match) {
      logger5.throwArgumentError("invalid event string", "value", value);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger5.warn("unknown modifier: " + modifier);
      }
    });
    return _EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }
};
function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger5.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger5.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
var ConstructorFragment = class _ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    if (format === FormatTypes.sighash) {
      logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return _ConstructorFragment.fromString(value);
    }
    return _ConstructorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (_ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger5.throwArgumentError("invalid constructor object", "value", value);
    }
    let state3 = verifyState(value);
    if (state3.constant) {
      logger5.throwArgumentError("constructor cannot be constant", "value", value);
    }
    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state3.payable,
      stateMutability: state3.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new _ConstructorFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let params = { type: "constructor" };
    value = parseGas(value, params);
    let parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger5.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return _ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }
};
var FunctionFragment = class _FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return _FunctionFragment.fromString(value);
    }
    return _FunctionFragment.fromObject(value);
  }
  static fromObject(value) {
    if (_FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger5.throwArgumentError("invalid function object", "value", value);
    }
    let state3 = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state3.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state3.payable,
      stateMutability: state3.stateMutability,
      gas: value.gas ? BigNumber.from(value.gas) : null
    };
    return new _FunctionFragment(_constructorGuard3, params);
  }
  static fromString(value) {
    let params = { type: "function" };
    value = parseGas(value, params);
    let comps = value.split(" returns ");
    if (comps.length > 2) {
      logger5.throwArgumentError("invalid function string", "value", value);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger5.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger5.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return _FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }
};
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
var ErrorFragment = class _ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }
    if (!FormatTypes[format]) {
      logger5.throwArgumentError("invalid format type", "format", format);
    }
    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
      });
    }
    let result = "";
    if (format !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value) {
    if (typeof value === "string") {
      return _ErrorFragment.fromString(value);
    }
    return _ErrorFragment.fromObject(value);
  }
  static fromObject(value) {
    if (_ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger5.throwArgumentError("invalid error object", "value", value);
    }
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new _ErrorFragment(_constructorGuard3, params));
  }
  static fromString(value) {
    let params = { type: "error" };
    let parens = value.match(regexParen);
    if (!parens) {
      logger5.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(_ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }
};
function verifyType(type2) {
  if (type2.match(/^uint($|[^1-9])/)) {
    type2 = "uint256" + type2.substring(4);
  } else if (type2.match(/^int($|[^1-9])/)) {
    type2 = "int256" + type2.substring(3);
  }
  return type2;
}
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }
  return value;
}
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value.length; offset++) {
    let c5 = value[offset];
    if (c5 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c5;
      if (c5 === "(") {
        depth++;
      } else if (c5 === ")") {
        depth--;
        if (depth === -1) {
          logger5.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}

// node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
var logger6 = new Logger(version6);
function checkResultErrors(result) {
  const errors = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key2 in object2) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object2[key2]);
      } catch (error) {
        errors.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
var Coder = class {
  constructor(name2, type2, localName, dynamic2) {
    this.name = name2;
    this.type = type2;
    this.localName = localName;
    this.dynamic = dynamic2;
  }
  _throwError(message, value) {
    logger6.throwArgumentError(message, this.localName, value);
  }
};
var Writer = class {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data3) {
    this._data.push(data3);
    this._dataLength += data3.length;
    return data3.length;
  }
  appendWriter(writer) {
    return this._writeData(concat2(writer._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(value) {
    let bytes = arrayify(value);
    const paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = concat2([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  }
  _getValue(value) {
    let bytes = arrayify(BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = concat2([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(value) {
    return this._writeData(this._getValue(value));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value) => {
      this._data[offset] = this._getValue(value);
    };
  }
};
var Reader = class _Reader {
  constructor(data3, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data3));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(name2, value) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  }
  coerce(name2, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value);
    }
    return _Reader.coerce(name2, value);
  }
  _peekBytes(offset, length2, loose) {
    let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
        alignedLength = length2;
      } else {
        logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new _Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length2, loose) {
    let bytes = this._peekBytes(0, length2, !!loose);
    this._offset += bytes.length;
    return bytes.slice(0, length2);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
};

// node_modules/@ethersproject/keccak256/lib.esm/index.js
var import_js_sha3 = __toESM(require_sha3());
function keccak256(data3) {
  return "0x" + import_js_sha3.default.keccak_256(arrayify(data3));
}

// node_modules/@ethersproject/rlp/lib.esm/index.js
var lib_exports = {};
__export(lib_exports, {
  decode: () => decode6,
  encode: () => encode5
});

// node_modules/@ethersproject/rlp/lib.esm/_version.js
var version7 = "rlp/5.7.0";

// node_modules/@ethersproject/rlp/lib.esm/index.js
var logger7 = new Logger(version7);
function arrayifyInteger(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data3, offset, length2) {
  let result = 0;
  for (let i4 = 0; i4 < length2; i4++) {
    result = result * 256 + data3[offset + i4];
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length3 = arrayifyInteger(payload.length);
    length3.unshift(247 + length3.length);
    return length3.concat(payload);
  }
  if (!isBytesLike(object2)) {
    logger7.throwArgumentError("RLP object must be BytesLike", "object", object2);
  }
  const data3 = Array.prototype.slice.call(arrayify(object2));
  if (data3.length === 1 && data3[0] <= 127) {
    return data3;
  } else if (data3.length <= 55) {
    data3.unshift(128 + data3.length);
    return data3;
  }
  const length2 = arrayifyInteger(data3.length);
  length2.unshift(183 + length2.length);
  return length2.concat(data3);
}
function encode5(object2) {
  return hexlify(_encode(object2));
}
function _decodeChildren(data3, offset, childOffset, length2) {
  const result = [];
  while (childOffset < offset + 1 + length2) {
    const decoded = _decode(data3, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length2) {
      logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length2, result };
}
function _decode(data3, offset) {
  if (data3.length === 0) {
    logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data3[offset] >= 248) {
    const lengthLength = data3[offset] - 247;
    if (offset + 1 + lengthLength > data3.length) {
      logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data3, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data3.length) {
      logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data3, offset, offset + 1 + lengthLength, lengthLength + length2);
  } else if (data3[offset] >= 192) {
    const length2 = data3[offset] - 192;
    if (offset + 1 + length2 > data3.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data3, offset, offset + 1, length2);
  } else if (data3[offset] >= 184) {
    const lengthLength = data3[offset] - 183;
    if (offset + 1 + lengthLength > data3.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length2 = unarrayifyInteger(data3, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length2 > data3.length) {
      logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data3.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
    return { consumed: 1 + lengthLength + length2, result };
  } else if (data3[offset] >= 128) {
    const length2 = data3[offset] - 128;
    if (offset + 1 + length2 > data3.length) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data3.slice(offset + 1, offset + 1 + length2));
    return { consumed: 1 + length2, result };
  }
  return { consumed: 1, result: hexlify(data3[offset]) };
}
function decode6(data3) {
  const bytes = arrayify(data3);
  const decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger7.throwArgumentError("invalid rlp data", "data", data3);
  }
  return decoded.result;
}

// node_modules/@ethersproject/address/lib.esm/_version.js
var version8 = "address/5.7.0";

// node_modules/@ethersproject/address/lib.esm/index.js
var logger8 = new Logger(version8);
function getChecksumAddress(address) {
  if (!isHexString(address, 20)) {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i4 = 0; i4 < 40; i4++) {
    expanded[i4] = chars[i4].charCodeAt(0);
  }
  const hashed = arrayify(keccak256(expanded));
  for (let i4 = 0; i4 < 40; i4 += 2) {
    if (hashed[i4 >> 1] >> 4 >= 8) {
      chars[i4] = chars[i4].toUpperCase();
    }
    if ((hashed[i4 >> 1] & 15) >= 8) {
      chars[i4 + 1] = chars[i4 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function log10(x5) {
  if (Math.log10) {
    return Math.log10(x5);
  }
  return Math.log(x5) / Math.LN10;
}
var ibanLookup = {};
for (let i4 = 0; i4 < 10; i4++) {
  ibanLookup[String(i4)] = String(i4);
}
for (let i4 = 0; i4 < 26; i4++) {
  ibanLookup[String.fromCharCode(65 + i4)] = String(10 + i4);
}
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c5) => {
    return ibanLookup[c5];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger8.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger8.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger8.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {
  }
  return false;
}
function getIcapAddress(address) {
  let base362 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base362.length < 30) {
    base362 = "0" + base362;
  }
  return "XE" + ibanChecksum("XE00" + base362) + base362;
}
function getContractAddress(transaction) {
  let from4 = null;
  try {
    from4 = getAddress(transaction.from);
  } catch (error) {
    logger8.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256(encode5([from4, nonce])), 12));
}
function getCreate2Address(from4, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256(concat2(["0xff", getAddress(from4), salt, initCodeHash])), 12));
}

// node_modules/@ethersproject/abi/lib.esm/coders/address.js
var AddressCoder = class extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value) {
    try {
      value = getAddress(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
var AnonymousCoder = class extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/array.js
var logger9 = new Logger(version6);
function pack(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger9.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger9.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func2) => {
    func2(staticWriter.length);
  });
  let length2 = writer.appendWriter(staticWriter);
  length2 += writer.appendWriter(dynamicWriter);
  return length2;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != void 0) {
      values.push(value);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name2] = value;
    }
  });
  for (let i4 = 0; i4 < values.length; i4++) {
    const value = values[i4];
    if (value instanceof Error) {
      Object.defineProperty(values, i4, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }
  return Object.freeze(values);
}
var ArrayCoder = class extends Coder {
  constructor(coder, length2, localName) {
    const type2 = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
    const dynamic2 = length2 === -1 || coder.dynamic;
    super("array", type2, localName, dynamic2);
    this.coder = coder;
    this.length = length2;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i4 = 0; i4 < this.length; i4++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value.length;
      writer.writeValue(value.length);
    }
    logger9.checkArgumentCount(value.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i4 = 0; i4 < value.length; i4++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader.readValue().toNumber();
      if (count2 * 32 > reader._data.length) {
        logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count2
        });
      }
    }
    let coders = [];
    for (let i4 = 0; i4 < count2; i4++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
var BooleanCoder = class extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
var DynamicBytesCoder = class extends Coder {
  constructor(type2, localName) {
    super(type2, type2, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = arrayify(value);
    let length2 = writer.writeValue(value.length);
    length2 += writer.writeBytes(value);
    return length2;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
};
var BytesCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
var FixedBytesCoder = class extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value) {
    let data3 = arrayify(value);
    if (data3.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data3);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/null.js
var NullCoder = class extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
};

// node_modules/@ethersproject/constants/lib.esm/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  AddressZero: () => AddressZero,
  EtherSymbol: () => EtherSymbol,
  HashZero: () => HashZero,
  MaxInt256: () => MaxInt256,
  MaxUint256: () => MaxUint256,
  MinInt256: () => MinInt256,
  NegativeOne: () => NegativeOne2,
  One: () => One,
  Two: () => Two,
  WeiPerEther: () => WeiPerEther,
  Zero: () => Zero2
});

// node_modules/@ethersproject/constants/lib.esm/addresses.js
var AddressZero = "0x0000000000000000000000000000000000000000";

// node_modules/@ethersproject/constants/lib.esm/bignumbers.js
var NegativeOne2 = BigNumber.from(-1);
var Zero2 = BigNumber.from(0);
var One = BigNumber.from(1);
var Two = BigNumber.from(2);
var WeiPerEther = BigNumber.from("1000000000000000000");
var MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
var MaxInt256 = BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

// node_modules/@ethersproject/constants/lib.esm/hashes.js
var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

// node_modules/@ethersproject/constants/lib.esm/strings.js
var EtherSymbol = "Ξ";

// node_modules/@ethersproject/abi/lib.esm/coders/number.js
var NumberCoder = class extends Coder {
  constructor(size2, signed2, localName) {
    const name2 = (signed2 ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed2;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value) {
    let v5 = BigNumber.from(value);
    let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v5.gt(bounds) || v5.lt(bounds.add(One).mul(NegativeOne2))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v5.lt(Zero2) || v5.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v5 = v5.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v5 = v5.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v5);
  }
  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  }
};

// node_modules/@ethersproject/strings/lib.esm/_version.js
var version9 = "strings/5.7.0";

// node_modules/@ethersproject/strings/lib.esm/utf8.js
var logger10 = new Logger(version9);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i4 = 0;
    for (let o3 = offset + 1; o3 < bytes.length; o3++) {
      if (bytes[o3] >> 6 !== 2) {
        break;
      }
      i4++;
    }
    return i4;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes = arrayify(bytes);
  const result = [];
  let i4 = 0;
  while (i4 < bytes.length) {
    const c5 = bytes[i4++];
    if (c5 >> 7 === 0) {
      result.push(c5);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c5 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c5 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c5 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c5 & 192) === 128) {
        i4 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i4 - 1, bytes, result);
      } else {
        i4 += onError(Utf8ErrorReason.BAD_PREFIX, i4 - 1, bytes, result);
      }
      continue;
    }
    if (i4 - 1 + extraLength >= bytes.length) {
      i4 += onError(Utf8ErrorReason.OVERRUN, i4 - 1, bytes, result);
      continue;
    }
    let res = c5 & (1 << 8 - extraLength - 1) - 1;
    for (let j7 = 0; j7 < extraLength; j7++) {
      let nextChar = bytes[i4];
      if ((nextChar & 192) != 128) {
        i4 += onError(Utf8ErrorReason.MISSING_CONTINUE, i4, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 63;
      i4++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i4 += onError(Utf8ErrorReason.OUT_OF_RANGE, i4 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i4 += onError(Utf8ErrorReason.UTF16_SURROGATE, i4 - 1 - extraLength, bytes, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i4 += onError(Utf8ErrorReason.OVERLONG, i4 - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger10.checkNormalize();
    str = str.normalize(form);
  }
  let result = [];
  for (let i4 = 0; i4 < str.length; i4++) {
    const c5 = str.charCodeAt(i4);
    if (c5 < 128) {
      result.push(c5);
    } else if (c5 < 2048) {
      result.push(c5 >> 6 | 192);
      result.push(c5 & 63 | 128);
    } else if ((c5 & 64512) == 55296) {
      i4++;
      const c22 = str.charCodeAt(i4);
      if (i4 >= str.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c5 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c5 >> 12 | 224);
      result.push(c5 >> 6 & 63 | 128);
      result.push(c5 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

// node_modules/@ethersproject/strings/lib.esm/bytes32.js
function formatBytes32String(text) {
  const bytes = toUtf8Bytes(text);
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat2([bytes, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data3 = arrayify(bytes);
  if (data3.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data3[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length2 = 31;
  while (data3[length2 - 1] === 0) {
    length2--;
  }
  return toUtf8String(data3.slice(0, length2));
}

// node_modules/@ethersproject/strings/lib.esm/idna.js
function bytes2(data3) {
  if (data3.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i4 = 0; i4 < data3.length; i4 += 4) {
    result.push(parseInt(data3.substring(i4, i4 + 4), 16));
  }
  return result;
}
function createTable(data3, func2) {
  if (!func2) {
    func2 = function(value) {
      return [parseInt(value, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data3.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func2(comps[1]);
  });
  return result;
}
function createRangeTable(data3) {
  let hi = 0;
  return data3.split(",").map((v5) => {
    let comps = v5.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value, ranges) {
  let lo = 0;
  for (let i4 = 0; i4 < ranges.length; i4++) {
    let range2 = ranges[i4];
    lo += range2.l;
    if (value >= lo && value <= lo + range2.h && (value - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v5) => parseInt(v5, 16));
var Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach((value2) => {
      accum.push(value2);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  let codes = toUtf8CodePoints(value);
  codes = flatten(codes.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
  codes.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name2;
}

// node_modules/@ethersproject/abi/lib.esm/coders/string.js
var StringCoder = class extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value) {
    return super.encode(writer, toUtf8Bytes(value));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
};

// node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
var TupleCoder = class extends Coder {
  constructor(coders, localName) {
    let dynamic2 = false;
    const types = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic2 = true;
      }
      types.push(coder.type);
    });
    const type2 = "tuple(" + types.join(",") + ")";
    super("tuple", type2, localName, dynamic2);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, value) {
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
};

// node_modules/@ethersproject/abi/lib.esm/abi-coder.js
var logger11 = new Logger(version6);
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = class {
  constructor(coerceFunc) {
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size2 = parseInt(match[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size2 = parseInt(match[1]);
      if (size2 === 0 || size2 > 32) {
        logger11.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger11.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data3, allowLoose) {
    return new Reader(data3, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types) {
    const coders = types.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types, values) {
    if (types.length !== values.length) {
      logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types.length, values: values.length },
        value: { types, values }
      });
    }
    const coders = types.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types, data3, loose) {
    const coders = types.map((type2) => this._getCoder(ParamType.from(type2)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data3), loose));
  }
};
var defaultAbiCoder = new AbiCoder();

// node_modules/@ethersproject/hash/lib.esm/id.js
function id(text) {
  return keccak256(toUtf8Bytes(text));
}

// node_modules/@ethersproject/hash/lib.esm/_version.js
var version10 = "hash/5.7.0";

// node_modules/@ethersproject/base64/lib.esm/index.js
var lib_exports3 = {};
__export(lib_exports3, {
  decode: () => decode7,
  encode: () => encode6
});

// node_modules/@ethersproject/base64/lib.esm/base64.js
function decode7(textData) {
  textData = atob(textData);
  const data3 = [];
  for (let i4 = 0; i4 < textData.length; i4++) {
    data3.push(textData.charCodeAt(i4));
  }
  return arrayify(data3);
}
function encode6(data3) {
  data3 = arrayify(data3);
  let textData = "";
  for (let i4 = 0; i4 < data3.length; i4++) {
    textData += String.fromCharCode(data3[i4]);
  }
  return btoa(textData);
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
function flat(array2, depth) {
  if (depth == null) {
    depth = 1;
  }
  const result = [];
  const forEach = result.forEach;
  const flatDeep = function(arr, depth2) {
    forEach.call(arr, function(val) {
      if (depth2 > 0 && Array.isArray(val)) {
        flatDeep(val, depth2 - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array2, depth);
  return result;
}
function fromEntries(array2) {
  const result = {};
  for (let i4 = 0; i4 < array2.length; i4++) {
    const value = array2[i4];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i4 = 1; i4 < symbol_count; i4++) {
    acc.push(total += u16());
  }
  let skip2 = u16();
  let pos_payload = pos;
  pos += skip2;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N15 = 31;
  const FULL = Math.pow(2, N15);
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i4 = 0; i4 < N15; i4++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range2 = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range2);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a4 = low + Math.floor(range2 * acc[start] / total);
    let b6 = low + Math.floor(range2 * acc[start + 1] / total) - 1;
    while (((a4 ^ b6) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a4 = a4 << 1 & MASK;
      b6 = b6 << 1 & MASK | 1;
    }
    while (a4 & ~b6 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a4 = a4 << 1 ^ HALF;
      b6 = (b6 ^ HALF) << 1 | HALF | 1;
    }
    low = a4;
    range2 = 1 + b6 - a4;
  }
  let offset = symbol_count - 4;
  return symbols.map((x5) => {
    switch (x5 - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x5 - 1;
    }
  });
}
function read_payload(v5) {
  let pos = 0;
  return () => v5[pos++];
}
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
function signed(i4) {
  return i4 & 1 ? ~i4 >> 1 : i4 >> 1;
}
function read_counts(n3, next) {
  let v5 = Array(n3);
  for (let i4 = 0; i4 < n3; i4++)
    v5[i4] = 1 + next();
  return v5;
}
function read_ascending(n3, next) {
  let v5 = Array(n3);
  for (let i4 = 0, x5 = -1; i4 < n3; i4++)
    v5[i4] = x5 += 1 + next();
  return v5;
}
function read_deltas(n3, next) {
  let v5 = Array(n3);
  for (let i4 = 0, x5 = 0; i4 < n3; i4++)
    v5[i4] = x5 += signed(next());
  return v5;
}
function read_member_array(next, lookup) {
  let v5 = read_ascending(next(), next);
  let n3 = next();
  let vX = read_ascending(n3, next);
  let vN = read_counts(n3, next);
  for (let i4 = 0; i4 < n3; i4++) {
    for (let j7 = 0; j7 < vN[i4]; j7++) {
      v5.push(vX[i4] + j7);
    }
  }
  return lookup ? v5.map((x5) => lookup[x5]) : v5;
}
function read_mapped_map(next) {
  let ret = [];
  while (true) {
    let w5 = next();
    if (w5 == 0)
      break;
    ret.push(read_linear_table(w5, next));
  }
  while (true) {
    let w5 = next() - 1;
    if (w5 < 0)
      break;
    ret.push(read_replacement_table(w5, next));
  }
  return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
  let v5 = [];
  while (true) {
    let i4 = next();
    if (i4 == 0)
      break;
    v5.push(i4);
  }
  return v5;
}
function read_transposed(n3, w5, next) {
  let m5 = Array(n3).fill(void 0).map(() => []);
  for (let i4 = 0; i4 < w5; i4++) {
    read_deltas(n3, next).forEach((x5, j7) => m5[j7].push(x5));
  }
  return m5;
}
function read_linear_table(w5, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_zero_terminated_array(next);
  let m5 = read_transposed(vN.length, 1 + w5, next);
  return flat(m5.map((v5, i4) => {
    const x5 = v5[0], ys2 = v5.slice(1);
    return Array(vN[i4]).fill(void 0).map((_6, j7) => {
      let j_dy = j7 * dy;
      return [x5 + j7 * dx, ys2.map((y7) => y7 + j_dy)];
    });
  }));
}
function read_replacement_table(w5, next) {
  let n3 = 1 + next();
  let m5 = read_transposed(n3, 1 + w5, next);
  return m5.map((v5) => [v5[0], v5.slice(1)]);
}
function read_emoji_trie(next) {
  let sorted = read_member_array(next).sort((a4, b6) => a4 - b6);
  return read2();
  function read2() {
    let branches = [];
    while (true) {
      let keys2 = read_member_array(next, sorted);
      if (keys2.length == 0)
        break;
      branches.push({ set: new Set(keys2), node: read2() });
    }
    branches.sort((a4, b6) => b6.set.size - a4.set.size);
    let temp = next();
    let valid = temp % 3;
    temp = temp / 3 | 0;
    let fe0f = !!(temp & 1);
    temp >>= 1;
    let save = temp == 1;
    let check = temp == 2;
    return { branches, valid, fe0f, save, check };
  }
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
function getData() {
  return read_compressed_payload(decode7("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}

// node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
var r = getData();
var VALID = new Set(read_member_array(r));
var IGNORED = new Set(read_member_array(r));
var MAPPED = read_mapped_map(r);
var EMOJI_ROOT = read_emoji_trie(r);
var HYPHEN = 45;
var UNDERSCORE = 95;
function explode_cp(name2) {
  return toUtf8CodePoints(name2);
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != 65039);
}
function ens_normalize_post_check(name2) {
  for (let label of name2.split(".")) {
    let cps = explode_cp(label);
    try {
      for (let i4 = cps.lastIndexOf(UNDERSCORE) - 1; i4 >= 0; i4--) {
        if (cps[i4] !== UNDERSCORE) {
          throw new Error(`underscore only allowed at start`);
        }
      }
      if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error(`invalid label extension`);
      }
    } catch (err) {
      throw new Error(`Invalid label "${label}": ${err.message}`);
    }
  }
  return name2;
}
function ens_normalize(name2) {
  return ens_normalize_post_check(normalize(name2, filter_fe0f));
}
function normalize(name2, emoji_filter) {
  let input = explode_cp(name2).reverse();
  let output = [];
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push(...emoji_filter(emoji));
      continue;
    }
    let cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    let cps = MAPPED[cp];
    if (cps) {
      output.push(...cps);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s3) {
  return s3.normalize("NFC");
}
function consume_emoji_reversed(cps, eaten) {
  var _a2;
  let node = EMOJI_ROOT;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = (_a2 = node.branches.find((x5) => x5.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
    if (!node)
      break;
    if (node.save) {
      saved = cp;
    } else if (node.check) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(65039);
      if (pos > 0 && cps[pos - 1] == 65039)
        pos--;
    }
    if (node.valid) {
      emoji = stack.slice();
      if (node.valid == 2)
        emoji.splice(1, 1);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// node_modules/@ethersproject/hash/lib.esm/namehash.js
var logger12 = new Logger(version10);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name2) {
  const bytes = toUtf8Bytes(ens_normalize(name2));
  const comps = [];
  if (name2.length === 0) {
    return comps;
  }
  let last2 = 0;
  for (let i4 = 0; i4 < bytes.length; i4++) {
    const d4 = bytes[i4];
    if (d4 === 46) {
      comps.push(checkComponent(bytes.slice(last2, i4)));
      last2 = i4 + 1;
    }
  }
  if (last2 >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last2)));
  return comps;
}
function isValidName(name2) {
  try {
    return ensNameSplit(name2).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger12.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let result = Zeros;
  const comps = ensNameSplit(name2);
  while (comps.length) {
    result = keccak256(concat2([result, keccak256(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name2) {
  return hexlify(concat2(ensNameSplit(name2).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}

// node_modules/@ethersproject/hash/lib.esm/message.js
var messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256(concat2([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}

// node_modules/@ethersproject/hash/lib.esm/typed-data.js
var __awaiter3 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger13 = new Logger(version10);
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne3 = BigNumber.from(-1);
var Zero3 = BigNumber.from(0);
var One2 = BigNumber.from(1);
var MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  const bytes = arrayify(value);
  const padOffset = bytes.length % 32;
  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
var hexTrue = hexZeroPad(One2.toHexString(), 32);
var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value) {
    if (typeof value !== "string") {
      logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    try {
      const bytes = arrayify(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes);
    } catch (error) {
    }
    return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};
function getBaseEncoder(type2) {
  {
    const match = type2.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed2 = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger13.throwArgumentError("invalid numeric width", "type", type2);
      }
      const boundsUpper = MaxUint2562.mask(signed2 ? width - 1 : width);
      const boundsLower = signed2 ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
      return function(value) {
        const v5 = BigNumber.from(value);
        if (v5.lt(boundsLower) || v5.gt(boundsUpper)) {
          logger13.throwArgumentError(`value out-of-bounds for ${type2}`, "value", value);
        }
        return hexZeroPad(v5.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type2.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger13.throwArgumentError("invalid bytes width", "type", type2);
      }
      return function(value) {
        const bytes = arrayify(value);
        if (bytes.length !== width) {
          logger13.throwArgumentError(`invalid length for ${type2}`, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type2) {
    case "address":
      return function(value) {
        return hexZeroPad(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak256(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type: type2 }) => type2 + " " + name3).join(",")})`;
}
var TypedDataEncoder = class _TypedDataEncoder {
  constructor(types) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types).forEach((type2) => {
      links[type2] = {};
      parents[type2] = [];
      subtypes[type2] = {};
    });
    for (const name2 in types) {
      const uniqueNames = {};
      types[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n3) => parents[n3].length === 0);
    if (primaryTypes.length === 0) {
      logger13.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t3) => JSON.stringify(t3)).join(", ")}`, "types", types);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type2, found) {
      if (found[type2]) {
        logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type2)}`, "types", types);
      }
      found[type2] = true;
      Object.keys(links[type2]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type2];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st3 = Object.keys(subtypes[name2]);
      st3.sort();
      this._types[name2] = encodeType(name2, types[name2]) + st3.map((t3) => encodeType(t3, types[t3])).join("");
    }
  }
  getEncoder(type2) {
    let encoder = this._encoderCache[type2];
    if (!encoder) {
      encoder = this._encoderCache[type2] = this._getEncoder(type2);
    }
    return encoder;
  }
  _getEncoder(type2) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return encoder;
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length2 = parseInt(match[3]);
      return (value) => {
        if (length2 >= 0 && value.length !== length2) {
          logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        let result = value.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256);
        }
        return keccak256(hexConcat(result));
      };
    }
    const fields = this.types[type2];
    if (fields) {
      const encodedType = id(this._types[type2]);
      return (value) => {
        const values = fields.map(({ name: name2, type: type3 }) => {
          const result = this.getEncoder(type3)(value[name2]);
          if (this._types[type3]) {
            return keccak256(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger13.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger13.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type2, value) {
    return this.getEncoder(type2)(value);
  }
  hashStruct(name2, value) {
    return keccak256(this.encodeData(name2, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type2, value, callback) {
    {
      const encoder = getBaseEncoder(type2);
      if (encoder) {
        return callback(type2, value);
      }
    }
    const match = type2.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length2 = parseInt(match[3]);
      if (length2 >= 0 && value.length !== length2) {
        logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map((v5) => this._visit(subtype, v5, callback));
    }
    const fields = this.types[type2];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type3 }) => {
        accum[name2] = this._visit(type3, value[name2], callback);
        return accum;
      }, {});
    }
    return logger13.throwArgumentError(`unknown type: ${type2}`, "type", type2);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types) {
    return new _TypedDataEncoder(types);
  }
  static getPrimaryType(types) {
    return _TypedDataEncoder.from(types).primaryType;
  }
  static hashStruct(name2, types, value) {
    return _TypedDataEncoder.from(types).hashStruct(name2, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name2 in domain) {
      const type2 = domainFieldTypes[name2];
      if (!type2) {
        logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain);
      }
      domainFields.push({ name: name2, type: type2 });
    }
    domainFields.sort((a4, b6) => {
      return domainFieldNames.indexOf(a4.name) - domainFieldNames.indexOf(b6.name);
    });
    return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types, value) {
    return hexConcat([
      "0x1901",
      _TypedDataEncoder.hashDomain(domain),
      _TypedDataEncoder.from(types).hash(value)
    ]);
  }
  static hash(domain, types, value) {
    return keccak256(_TypedDataEncoder.encode(domain, types, value));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(domain, types, value, resolveName2) {
    return __awaiter3(this, void 0, void 0, function* () {
      domain = shallowCopy(domain);
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = _TypedDataEncoder.from(types);
      encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName2(name2);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    });
  }
  static getPayload(domain, types, value) {
    _TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value2 = domain[name2];
      if (value2 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value2);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = _TypedDataEncoder.from(types);
    const typesWithDomain = shallowCopy(types);
    if (typesWithDomain.EIP712Domain) {
      logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type2, value2) => {
        if (type2.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value2));
        }
        if (type2.match(/^u?int/)) {
          return BigNumber.from(value2).toString();
        }
        switch (type2) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            if (typeof value2 !== "string") {
              logger13.throwArgumentError(`invalid string`, "value", value2);
            }
            return value2;
        }
        return logger13.throwArgumentError("unsupported type", "type", type2);
      })
    };
  }
};

// node_modules/@ethersproject/abi/lib.esm/interface.js
var logger14 = new Logger(version6);
var LogDescription = class extends Description {
};
var TransactionDescription = class extends Description {
};
var ErrorDescription = class extends Description {
};
var Indexed = class extends Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
};
var BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property2, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property2}`);
  wrap.error = error;
  return wrap;
}
var Interface = class {
  constructor(fragments) {
    let abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    defineReadOnly(this, "fragments", abi.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger14.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger14.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format) {
    if (!format) {
      format = FormatTypes.full;
    }
    if (format === FormatTypes.sighash) {
      logger14.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    const abi = this.fragments.map((fragment) => fragment.format(format));
    if (format === FormatTypes.json) {
      return JSON.stringify(abi.map((j7) => JSON.parse(j7)));
    }
    return abi;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f5) => f5.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger14.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger14.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger14.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f5) => f5.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger14.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger14.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(nameOrSignatureOrSighash) {
    if (isHexString(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name2];
        }
      }
      logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f5) => f5.split(
        "("
        /* fix:) */
      )[0] === name2);
      if (matching.length === 0) {
        logger14.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger14.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_6) {
          throw error;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data3) {
    return this._abiCoder.decode(params, data3);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data3) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes = arrayify(data3);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat2([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(functionFragment, data3) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes = arrayify(data3);
    if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat2([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(functionFragment, data3) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes = arrayify(data3);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
          if (errorName === "Error") {
            message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
          } else if (errorName === "Panic") {
            message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
          }
        } else {
          try {
            const error = this.getError(selector);
            errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
            errorName = error.name;
            errorSignature = error.format();
          } catch (error) {
          }
        }
        break;
      }
    }
    return logger14.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: hexlify(data3),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak256(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = BigNumber.from(value).toHexString();
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }
      return hexZeroPad(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger14.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak256(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(eventFragment, data3, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic2 = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic2.push(true);
        } else {
          indexed.push(param);
          dynamic2.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic2.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat2(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data3, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic2[index]) {
          result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      if (param.name && result[param.name] == null) {
        const value = result[index];
        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    });
    for (let i4 = 0; i4 < result.length; i4++) {
      const value = result[i4];
      if (value instanceof Error) {
        Object.defineProperty(result, i4, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i4}`, value);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }
  parseError(data3) {
    const hexData = hexlify(data3);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(value) {
    return !!(value && value._isInterface);
  }
};

// node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
var version11 = "abstract-provider/5.7.0";

// node_modules/@ethersproject/abstract-provider/lib.esm/index.js
var __awaiter4 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger15 = new Logger(version11);
var ForkEvent = class extends Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }
};
var Provider = class _Provider {
  constructor() {
    logger15.checkAbstract(new.target, _Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter4(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error) => {
          return null;
        })
      });
      let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        lastBaseFeePerGas = block.baseFeePerGas;
        maxPriorityFeePerGas = BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  // Alias for "on"
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  // Alias for "off"
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value) {
    return !!(value && value._isProvider);
  }
};

// node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
var version12 = "abstract-signer/5.7.0";

// node_modules/@ethersproject/abstract-signer/lib.esm/index.js
var __awaiter5 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger16 = new Logger(version12);
var allowedTransactionKeys = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
var forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
var Signer = class _Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger16.checkAbstract(new.target, _Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(blockTag) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(transaction) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(transaction, blockTag) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(transaction) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys.indexOf(key2) === -1) {
        logger16.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger16.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(transaction) {
    return __awaiter5(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter5(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error) => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }
          return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results) => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(operation) {
    if (!this.provider) {
      logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value) {
    return !!(value && value._isSigner);
  }
};
var VoidSigner = class _VoidSigner extends Signer {
  constructor(address, provider) {
    super();
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "provider", provider || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
    });
  }
  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(provider) {
    return new _VoidSigner(this.address, provider);
  }
};

// node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
var import_bn2 = __toESM(require_bn());
var import_hash2 = __toESM(require_hash2());
function createCommonjsModule(fn2, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path, base4) {
      return commonjsRequire(path, base4 === void 0 || base4 === null ? module.path : base4);
    }
  }, fn2(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert;
function assert(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert.equal = function assertEqual(l4, r5, msg) {
  if (l4 != r5)
    throw new Error(msg || "Assertion failed: " + l4 + " != " + r5);
};
var utils_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i4 = 0; i4 < msg.length; i4++)
        res[i4] = msg[i4] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i4 = 0; i4 < msg.length; i4 += 2)
        res.push(parseInt(msg[i4] + msg[i4 + 1], 16));
    } else {
      for (var i4 = 0; i4 < msg.length; i4++) {
        var c5 = msg.charCodeAt(i4);
        var hi = c5 >> 8;
        var lo = c5 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray2;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex2(msg) {
    var res = "";
    for (var i4 = 0; i4 < msg.length; i4++)
      res += zero2(msg[i4].toString(16));
    return res;
  }
  utils.toHex = toHex2;
  utils.encode = function encode8(arr, enc) {
    if (enc === "hex")
      return toHex2(arr);
    else
      return arr;
  };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode;
  function getNAF2(num, w5, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws2 = 1 << w5 + 1;
    var k5 = num.clone();
    for (var i4 = 0; i4 < naf.length; i4++) {
      var z5;
      var mod = k5.andln(ws2 - 1);
      if (k5.isOdd()) {
        if (mod > (ws2 >> 1) - 1)
          z5 = (ws2 >> 1) - mod;
        else
          z5 = mod;
        k5.isubn(z5);
      } else {
        z5 = 0;
      }
      naf[i4] = z5;
      k5.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF2;
  function getJSF2(k1, k22) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k22 = k22.clone();
    var d1 = 0;
    var d22 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k22.andln(3) + d22 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u22;
      if ((m24 & 1) === 0) {
        u22 = 0;
      } else {
        m8 = k22.andln(7) + d22 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u22 = -m24;
        else
          u22 = m24;
      }
      jsf[1].push(u22);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d22 === u22 + 1)
        d22 = 1 - d22;
      k1.iushrn(1);
      k22.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF2;
  function cachedProperty(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty2() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new import_bn2.default(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type2, conf) {
  this.type = type2;
  this.p = new import_bn2.default(conf.p, 16);
  this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
  this.zero = new import_bn2.default(0).toRed(this.red);
  this.one = new import_bn2.default(1).toRed(this.red);
  this.two = new import_bn2.default(2).toRed(this.red);
  this.n = conf.n && new import_bn2.default(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base3 = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p6, k5) {
  assert$1(p6.precomputed);
  var doubles = p6._getDoubles();
  var naf = getNAF(k5, 1, this._bitLength);
  var I3 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I3 /= 3;
  var repr = [];
  var j7;
  var nafW;
  for (j7 = 0; j7 < naf.length; j7 += doubles.step) {
    nafW = 0;
    for (var l4 = j7 + doubles.step - 1; l4 >= j7; l4--)
      nafW = (nafW << 1) + naf[l4];
    repr.push(nafW);
  }
  var a4 = this.jpoint(null, null, null);
  var b6 = this.jpoint(null, null, null);
  for (var i4 = I3; i4 > 0; i4--) {
    for (j7 = 0; j7 < repr.length; j7++) {
      nafW = repr[j7];
      if (nafW === i4)
        b6 = b6.mixedAdd(doubles.points[j7]);
      else if (nafW === -i4)
        b6 = b6.mixedAdd(doubles.points[j7].neg());
    }
    a4 = a4.add(b6);
  }
  return a4.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p6, k5) {
  var w5 = 4;
  var nafPoints = p6._getNAFPoints(w5);
  w5 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k5, w5, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i4 = naf.length - 1; i4 >= 0; i4--) {
    for (var l4 = 0; i4 >= 0 && naf[i4] === 0; i4--)
      l4++;
    if (i4 >= 0)
      l4++;
    acc = acc.dblp(l4);
    if (i4 < 0)
      break;
    var z5 = naf[i4];
    assert$1(z5 !== 0);
    if (p6.type === "affine") {
      if (z5 > 0)
        acc = acc.mixedAdd(wnd[z5 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z5 - 1 >> 1].neg());
    } else {
      if (z5 > 0)
        acc = acc.add(wnd[z5 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z5 - 1 >> 1].neg());
    }
  }
  return p6.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max3 = 0;
  var i4;
  var j7;
  var p6;
  for (i4 = 0; i4 < len; i4++) {
    p6 = points[i4];
    var nafPoints = p6._getNAFPoints(defW);
    wndWidth[i4] = nafPoints.wnd;
    wnd[i4] = nafPoints.points;
  }
  for (i4 = len - 1; i4 >= 1; i4 -= 2) {
    var a4 = i4 - 1;
    var b6 = i4;
    if (wndWidth[a4] !== 1 || wndWidth[b6] !== 1) {
      naf[a4] = getNAF(coeffs[a4], wndWidth[a4], this._bitLength);
      naf[b6] = getNAF(coeffs[b6], wndWidth[b6], this._bitLength);
      max3 = Math.max(naf[a4].length, max3);
      max3 = Math.max(naf[b6].length, max3);
      continue;
    }
    var comb = [
      points[a4],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      points[b6]
      /* 7 */
    ];
    if (points[a4].y.cmp(points[b6].y) === 0) {
      comb[1] = points[a4].add(points[b6]);
      comb[2] = points[a4].toJ().mixedAdd(points[b6].neg());
    } else if (points[a4].y.cmp(points[b6].y.redNeg()) === 0) {
      comb[1] = points[a4].toJ().mixedAdd(points[b6]);
      comb[2] = points[a4].add(points[b6].neg());
    } else {
      comb[1] = points[a4].toJ().mixedAdd(points[b6]);
      comb[2] = points[a4].toJ().mixedAdd(points[b6].neg());
    }
    var index = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a4], coeffs[b6]);
    max3 = Math.max(jsf[0].length, max3);
    naf[a4] = new Array(max3);
    naf[b6] = new Array(max3);
    for (j7 = 0; j7 < max3; j7++) {
      var ja = jsf[0][j7] | 0;
      var jb = jsf[1][j7] | 0;
      naf[a4][j7] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b6][j7] = 0;
      wnd[a4] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i4 = max3; i4 >= 0; i4--) {
    var k5 = 0;
    while (i4 >= 0) {
      var zero = true;
      for (j7 = 0; j7 < len; j7++) {
        tmp[j7] = naf[j7][i4] | 0;
        if (tmp[j7] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k5++;
      i4--;
    }
    if (i4 >= 0)
      k5++;
    acc = acc.dblp(k5);
    if (i4 < 0)
      break;
    for (j7 = 0; j7 < len; j7++) {
      var z5 = tmp[j7];
      p6;
      if (z5 === 0)
        continue;
      else if (z5 > 0)
        p6 = wnd[j7][z5 - 1 >> 1];
      else if (z5 < 0)
        p6 = wnd[j7][-z5 - 1 >> 1].neg();
      if (p6.type === "affine")
        acc = acc.mixedAdd(p6);
      else
        acc = acc.add(p6);
    }
  }
  for (i4 = 0; i4 < len; i4++)
    wnd[i4] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve, type2) {
  this.curve = curve;
  this.type = type2;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength();
  if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 6)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 7)
      assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(
      bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len)
    );
    return res;
  } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode2(compact) {
  var len = this.curve.p.byteLength();
  var x5 = this.getX().toArray("be", len);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x5);
  return [4].concat(x5, this.getY().toArray("be", len));
};
BasePoint.prototype.encode = function encode7(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k5) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k5.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i4 = 0; i4 < power; i4 += step) {
    for (var j7 = 0; j7 < step; j7++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max3 = (1 << wnd) - 1;
  var dbl3 = max3 === 1 ? null : this.dbl();
  for (var i4 = 1; i4 < max3; i4++)
    res[i4] = res[i4 - 1].add(dbl3);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k5) {
  var r5 = this;
  for (var i4 = 0; i4 < k5; i4++)
    r5 = r5.dbl();
  return r5;
};
var inherits_browser = createCommonjsModule(function(module) {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
  base3.call(this, "short", conf);
  this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
  this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base3);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new import_bn2.default(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new import_bn2.default(vec.a, 16),
        b: new import_bn2.default(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : import_bn2.default.mont(num);
  var tinv = new import_bn2.default(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s3 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s3).fromRed();
  var l22 = ntinv.redSub(s3).fromRed();
  return [l1, l22];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u5 = lambda;
  var v5 = this.n.clone();
  var x1 = new import_bn2.default(1);
  var y1 = new import_bn2.default(0);
  var x22 = new import_bn2.default(0);
  var y22 = new import_bn2.default(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a22;
  var b22;
  var prevR;
  var i4 = 0;
  var r5;
  var x5;
  while (u5.cmpn(0) !== 0) {
    var q5 = v5.div(u5);
    r5 = v5.sub(q5.mul(u5));
    x5 = x22.sub(q5.mul(x1));
    var y7 = y22.sub(q5.mul(y1));
    if (!a1 && r5.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r5.neg();
      b1 = x5;
    } else if (a1 && ++i4 === 2) {
      break;
    }
    prevR = r5;
    v5 = u5;
    u5 = r5;
    x22 = x1;
    x1 = x5;
    y22 = y1;
    y1 = y7;
  }
  a22 = r5.neg();
  b22 = x5;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a22.sqr().add(b22.sqr());
  if (len2.cmp(len1) >= 0) {
    a22 = a0;
    b22 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a22.negative) {
    a22 = a22.neg();
    b22 = b22.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a22, b: b22 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k5) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v22 = basis[1];
  var c1 = v22.b.mul(k5).divRound(this.n);
  var c22 = v1.b.neg().mul(k5).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p22 = c22.mul(v22.a);
  var q1 = c1.mul(v1.b);
  var q22 = c22.mul(v22.b);
  var k1 = k5.sub(p1).sub(p22);
  var k22 = q1.add(q22).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX(x5, odd) {
  x5 = new import_bn2.default(x5, 16);
  if (!x5.red)
    x5 = x5.toRed(this.red);
  var y22 = x5.redSqr().redMul(x5).redIAdd(x5.redMul(this.a)).redIAdd(this.b);
  var y7 = y22.redSqrt();
  if (y7.redSqr().redSub(y22).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y7.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y7 = y7.redNeg();
  return this.point(x5, y7);
};
ShortCurve.prototype.validate = function validate3(point3) {
  if (point3.inf)
    return true;
  var x5 = point3.x;
  var y7 = point3.y;
  var ax = this.a.redMul(x5);
  var rhs = x5.redSqr().redMul(x5).redIAdd(ax).redIAdd(this.b);
  return y7.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i4 = 0; i4 < points.length; i4++) {
    var split = this._endoSplit(coeffs[i4]);
    var p6 = points[i4];
    var beta = p6._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p6 = p6.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i4 * 2] = p6;
    npoints[i4 * 2 + 1] = beta;
    ncoeffs[i4 * 2] = split.k1;
    ncoeffs[i4 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i4 * 2, jacobianResult);
  for (var j7 = 0; j7 < i4 * 2; j7++) {
    npoints[j7] = null;
    ncoeffs[j7] = null;
  }
  return res;
};
function Point(curve, x5, y7, isRed) {
  base3.BasePoint.call(this, curve, "affine");
  if (x5 === null && y7 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new import_bn2.default(x5, 16);
    this.y = new import_bn2.default(y7, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base3.BasePoint);
ShortCurve.prototype.point = function point2(x5, y7, isRed) {
  return new Point(this, x5, y7, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p6) {
      return curve.point(p6.x.redMul(curve.endo.beta), p6.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p6) {
  if (this.inf)
    return p6;
  if (p6.inf)
    return this;
  if (this.eq(p6))
    return this.dbl();
  if (this.neg().eq(p6))
    return this.curve.point(null, null);
  if (this.x.cmp(p6.x) === 0)
    return this.curve.point(null, null);
  var c5 = this.y.redSub(p6.y);
  if (c5.cmpn(0) !== 0)
    c5 = c5.redMul(this.x.redSub(p6.x).redInvm());
  var nx = c5.redSqr().redISub(this.x).redISub(p6.x);
  var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a4 = this.curve.a;
  var x22 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c5 = x22.redAdd(x22).redIAdd(x22).redIAdd(a4).redMul(dyinv);
  var nx = c5.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c5.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k5) {
  k5 = new import_bn2.default(k5, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k5))
    return this.curve._fixedNafMul(this, k5);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k5]);
  else
    return this.curve._wnafMul(this, k5);
};
Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
  var points = [this, p22];
  var coeffs = [k1, k22];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq2(p6) {
  return this === p6 || this.inf === p6.inf && (this.inf || this.x.cmp(p6.x) === 0 && this.y.cmp(p6.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p6) {
      return p6.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x5, y7, z5) {
  base3.BasePoint.call(this, curve, "jacobian");
  if (x5 === null && y7 === null && z5 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new import_bn2.default(0);
  } else {
    this.x = new import_bn2.default(x5, 16);
    this.y = new import_bn2.default(y7, 16);
    this.z = new import_bn2.default(z5, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base3.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x5, y7, z5) {
  return new JPoint(this, x5, y7, z5);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add2(p6) {
  if (this.isInfinity())
    return p6;
  if (p6.isInfinity())
    return this;
  var pz2 = p6.z.redSqr();
  var z22 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u22 = p6.x.redMul(z22);
  var s1 = this.y.redMul(pz2.redMul(p6.z));
  var s22 = p6.y.redMul(z22.redMul(this.z));
  var h6 = u1.redSub(u22);
  var r5 = s1.redSub(s22);
  if (h6.cmpn(0) === 0) {
    if (r5.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h6.redSqr();
  var h32 = h22.redMul(h6);
  var v5 = u1.redMul(h22);
  var nx = r5.redSqr().redIAdd(h32).redISub(v5).redISub(v5);
  var ny = r5.redMul(v5.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(p6.z).redMul(h6);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p6) {
  if (this.isInfinity())
    return p6.toJ();
  if (p6.isInfinity())
    return this;
  var z22 = this.z.redSqr();
  var u1 = this.x;
  var u22 = p6.x.redMul(z22);
  var s1 = this.y;
  var s22 = p6.y.redMul(z22).redMul(this.z);
  var h6 = u1.redSub(u22);
  var r5 = s1.redSub(s22);
  if (h6.cmpn(0) === 0) {
    if (r5.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h6.redSqr();
  var h32 = h22.redMul(h6);
  var v5 = u1.redMul(h22);
  var nx = r5.redSqr().redIAdd(h32).redISub(v5).redISub(v5);
  var ny = r5.redMul(v5.redISub(nx)).redISub(s1.redMul(h32));
  var nz = this.z.redMul(h6);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i4;
  if (this.curve.zeroA || this.curve.threeA) {
    var r5 = this;
    for (i4 = 0; i4 < pow; i4++)
      r5 = r5.dbl();
    return r5;
  }
  var a4 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i4 = 0; i4 < pow; i4++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c5.redSqr().redISub(t1.redAdd(t1));
    var t22 = t1.redISub(nx);
    var dny = c5.redMul(t22);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i4 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m5 = xx.redAdd(xx).redIAdd(xx);
    var t3 = m5.redSqr().redISub(s3).redISub(s3);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t3;
    ny = m5.redMul(s3.redISub(t3)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a4 = this.x.redSqr();
    var b6 = this.y.redSqr();
    var c5 = b6.redSqr();
    var d4 = this.x.redAdd(b6).redSqr().redISub(a4).redISub(c5);
    d4 = d4.redIAdd(d4);
    var e3 = a4.redAdd(a4).redIAdd(a4);
    var f5 = e3.redSqr();
    var c8 = c5.redIAdd(c5);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f5.redISub(d4).redISub(d4);
    ny = e3.redMul(d4.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s3 = s3.redIAdd(s3);
    var m5 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t3 = m5.redSqr().redISub(s3).redISub(s3);
    nx = t3;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m5.redMul(s3.redISub(t3)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a4 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c5 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a4.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c5.redSqr().redISub(t1.redAdd(t1));
  var t22 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c5.redMul(t22).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m5 = xx.redAdd(xx).redIAdd(xx);
  var mm = m5.redSqr();
  var e3 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e3 = e3.redIAdd(e3);
  e3 = e3.redAdd(e3).redIAdd(e3);
  e3 = e3.redISub(mm);
  var ee3 = e3.redSqr();
  var t3 = yyyy.redIAdd(yyyy);
  t3 = t3.redIAdd(t3);
  t3 = t3.redIAdd(t3);
  t3 = t3.redIAdd(t3);
  var u5 = m5.redIAdd(e3).redSqr().redISub(mm).redISub(ee3).redISub(t3);
  var yyu4 = yy.redMul(u5);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee3).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u5.redMul(t3.redISub(u5)).redISub(e3.redMul(ee3)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e3).redSqr().redISub(zz).redISub(ee3);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul2(k5, kbase) {
  k5 = new import_bn2.default(k5, kbase);
  return this.curve._wnafMul(this, k5);
};
JPoint.prototype.eq = function eq3(p6) {
  if (p6.type === "affine")
    return this.eq(p6.toJ());
  if (this === p6)
    return true;
  var z22 = this.z.redSqr();
  var pz2 = p6.z.redSqr();
  if (this.x.redMul(pz2).redISub(p6.x.redMul(z22)).cmpn(0) !== 0)
    return false;
  var z32 = z22.redMul(this.z);
  var pz3 = pz2.redMul(p6.z);
  return this.y.redMul(pz3).redISub(p6.y.redMul(z32)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x5) {
  var zs2 = this.z.redSqr();
  var rx = x5.toRed(this.curve.red).redMul(zs2);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x5.clone();
  var t3 = this.curve.redN.redMul(zs2);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t3);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curve = exports;
  curve.base = base3;
  curve.short = short_1;
  curve.mont = /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var curves = exports;
  var assert3 = utils_1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert3(this.g.validate(), "Invalid curve");
    assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name2, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: import_hash2.default.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: import_hash2.default.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: import_hash2.default.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e3) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: import_hash2.default.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i4 = 0; i4 < this.V.length; i4++) {
    this.K[i4] = 0;
    this.V[i4] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function hmac() {
  return new import_hash2.default.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add3;
    add3 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1.toArray(entropy, entropyEnc);
  add3 = utils_1.toArray(add3, addEnc);
  minimalisticAssert(
    entropy.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  );
  this._update(entropy.concat(add3 || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add3;
    add3 = enc;
    enc = null;
  }
  if (add3) {
    add3 = utils_1.toArray(add3, addEnc || "hex");
    this._update(add3);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add3);
  this._reseed++;
  return utils_1.encode(res, enc);
};
var assert$3 = utils_1$1.assert;
function KeyPair(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(ec2, {
    pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;
  return new KeyPair(ec2, {
    priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate4() {
  var pub = this.getPublic();
  if (pub.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new import_bn2.default(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), "public point not validated");
  }
  return pub.mul(this.priv).getX();
};
KeyPair.prototype.sign = function sign2(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify2(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair.prototype.inspect = function inspect3() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
  if (options instanceof Signature)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4(options.r && options.s, "Signature without r or s");
  this.r = new import_bn2.default(options.r, 16);
  this.s = new import_bn2.default(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p6) {
  var initial = buf[p6.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i4 = 0, off = p6.place; i4 < octetLen; i4++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p6.place = off;
  return val;
}
function rmPadding(buf) {
  var i4 = 0;
  var len = buf.length - 1;
  while (!buf[i4] && !(buf[i4 + 1] & 128) && i4 < len) {
    i4++;
  }
  if (i4 === 0) {
    return buf;
  }
  return buf.slice(i4);
}
Signature.prototype._importDER = function _importDER(data3, enc) {
  data3 = utils_1$1.toArray(data3, enc);
  var p6 = new Position();
  if (data3[p6.place++] !== 48) {
    return false;
  }
  var len = getLength(data3, p6);
  if (len === false) {
    return false;
  }
  if (len + p6.place !== data3.length) {
    return false;
  }
  if (data3[p6.place++] !== 2) {
    return false;
  }
  var rlen = getLength(data3, p6);
  if (rlen === false) {
    return false;
  }
  var r5 = data3.slice(p6.place, rlen + p6.place);
  p6.place += rlen;
  if (data3[p6.place++] !== 2) {
    return false;
  }
  var slen = getLength(data3, p6);
  if (slen === false) {
    return false;
  }
  if (data3.length !== slen + p6.place) {
    return false;
  }
  var s3 = data3.slice(p6.place, slen + p6.place);
  if (r5[0] === 0) {
    if (r5[1] & 128) {
      r5 = r5.slice(1);
    } else {
      return false;
    }
  }
  if (s3[0] === 0) {
    if (s3[1] & 128) {
      s3 = s3.slice(1);
    } else {
      return false;
    }
  }
  this.r = new import_bn2.default(r5);
  this.s = new import_bn2.default(s3);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 128) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 128);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 255);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r5 = this.r.toArray();
  var s3 = this.s.toArray();
  if (r5[0] & 128)
    r5 = [0].concat(r5);
  if (s3[0] & 128)
    s3 = [0].concat(s3);
  r5 = rmPadding(r5);
  s3 = rmPadding(s3);
  while (!s3[0] && !(s3[1] & 128)) {
    s3 = s3.slice(1);
  }
  var arr = [2];
  constructLength(arr, r5.length);
  arr = arr.concat(r5);
  arr.push(2);
  constructLength(arr, s3.length);
  var backHalf = arr.concat(s3);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};
var rand = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
);
var assert$5 = utils_1$1.assert;
function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);
  if (typeof options === "string") {
    assert$5(
      Object.prototype.hasOwnProperty.call(curves_1, options),
      "Unknown curve " + options
    );
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns22 = this.n.sub(new import_bn2.default(2));
  for (; ; ) {
    var priv = new import_bn2.default(drbg.generate(bytes));
    if (priv.cmp(ns22) > 0)
      continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC.prototype.sign = function sign3(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  var bytes = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes);
  var nonce = msg.toArray("be", bytes);
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new import_bn2.default(1));
  for (var iter = 0; ; iter++) {
    var k5 = options.k ? options.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
    k5 = this._truncateToN(k5, true);
    if (k5.cmpn(1) <= 0 || k5.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k5);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r5 = kpX.umod(this.n);
    if (r5.cmpn(0) === 0)
      continue;
    var s3 = k5.invm(this.n).mul(r5.mul(key2.getPrivate()).iadd(msg));
    s3 = s3.umod(this.n);
    if (s3.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r5) !== 0 ? 2 : 0);
    if (options.canonical && s3.cmp(this.nh) > 0) {
      s3 = this.n.sub(s3);
      recoveryParam ^= 1;
    }
    return new signature({ r: r5, s: s3, recoveryParam });
  }
};
EC.prototype.verify = function verify3(msg, signature$1, key2, enc) {
  msg = this._truncateToN(new import_bn2.default(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$1 = new signature(signature$1, "hex");
  var r5 = signature$1.r;
  var s3 = signature$1.s;
  if (r5.cmpn(1) < 0 || r5.cmp(this.n) >= 0)
    return false;
  if (s3.cmpn(1) < 0 || s3.cmp(this.n) >= 0)
    return false;
  var sinv = s3.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u22 = sinv.mul(r5).umod(this.n);
  var p6;
  if (!this.curve._maxwellTrick) {
    p6 = this.g.mulAdd(u1, key2.getPublic(), u22);
    if (p6.isInfinity())
      return false;
    return p6.getX().umod(this.n).cmp(r5) === 0;
  }
  p6 = this.g.jmulAdd(u1, key2.getPublic(), u22);
  if (p6.isInfinity())
    return false;
  return p6.eqXToP(r5);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j7, enc) {
  assert$5((3 & j7) === j7, "The recovery param is more than two bits");
  signature$1 = new signature(signature$1, enc);
  var n3 = this.n;
  var e3 = new import_bn2.default(msg);
  var r5 = signature$1.r;
  var s3 = signature$1.s;
  var isYOdd = j7 & 1;
  var isSecondKey = j7 >> 1;
  if (r5.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r5 = this.curve.pointFromX(r5.add(this.curve.n), isYOdd);
  else
    r5 = this.curve.pointFromX(r5, isYOdd);
  var rInv = signature$1.r.invm(n3);
  var s1 = n3.sub(e3).mul(rInv).umod(n3);
  var s22 = s3.mul(rInv).umod(n3);
  return this.g.mulAdd(s1, r5, s22);
};
EC.prototype.getKeyRecoveryParam = function(e3, signature$1, Q5, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;
  for (var i4 = 0; i4 < 4; i4++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e3, signature$1, i4);
    } catch (e4) {
      continue;
    }
    if (Qprime.eq(Q5))
      return i4;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
  "use strict";
  var elliptic = exports;
  elliptic.version = /*RicMoo:ethers*/
  { version: "6.5.4" }.version;
  elliptic.utils = utils_1$1;
  elliptic.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  };
  elliptic.curve = curve_1;
  elliptic.curves = curves_1;
  elliptic.ec = ec;
  elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;

// node_modules/@ethersproject/signing-key/lib.esm/_version.js
var version13 = "signing-key/5.7.0";

// node_modules/@ethersproject/signing-key/lib.esm/index.js
var logger17 = new Logger(version13);
var _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1("secp256k1");
  }
  return _curve;
}
var SigningKey = class {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    if (hexDataLength(this.privateKey) !== 32) {
      logger17.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest2) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest2);
    if (digestBytes.length !== 32) {
      logger17.throwArgumentError("bad digest length", "digest", digest2);
    }
    const signature2 = keyPair2.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }
};
function recoverPublicKey(digest2, signature2) {
  const sig = splitSignature(signature2);
  const rs2 = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest2), rs2, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes = arrayify(key2);
  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return hexlify(bytes);
    }
    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }
  return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

// node_modules/@ethersproject/transactions/lib.esm/_version.js
var version14 = "transactions/5.7.0";

// node_modules/@ethersproject/transactions/lib.esm/index.js
var logger18 = new Logger(version14);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
}
function handleNumber(value) {
  if (value === "0x") {
    return Zero2;
  }
  return BigNumber.from(value);
}
var transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
var allowedTransactionKeys2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest2, signature2) {
  return computeAddress(recoverPublicKey(arrayify(digest2), signature2));
}
function formatNumber(value, name2) {
  const result = stripZeros(BigNumber.from(value).toHexString());
  if (result.length > 32) {
    logger18.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if (hexDataLength(storageKey) !== 32) {
        logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set3, index) => {
      if (Array.isArray(set3)) {
        if (set3.length > 2) {
          logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set3);
        }
        return accessSetify(set3[0], set3[1]);
      }
      return accessSetify(set3.address, set3.storageKeys);
    });
  }
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a4, b6) => a4.address.localeCompare(b6.address));
  return result;
}
function formatAccessList(value) {
  return accessListify(value).map((set3) => [set3.address, set3.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode5(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode5(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value = arrayify(hexlify(value, options));
    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    }
    if (fieldInfo.maxLength) {
      value = stripZeros(value);
      if (value.length > fieldInfo.maxLength) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }
    raw.push(hexlify(value));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode5(raw);
  }
  const sig = splitSignature(signature2);
  let v5 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v5 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v5) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v5) {
    logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v5));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode5(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize3) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error) {
    logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest2 = keccak256(serialize3(tx));
    tx.from = recoverAddress(digest2, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error) {
  }
}
function _parseEip1559(payload) {
  const transaction = decode6(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode6(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode6(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest2 = keccak256(encode5(raw));
    try {
      tx.from = recoverAddress(digest2, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error) {
    }
    tx.hash = keccak256(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse2(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
    default:
      break;
  }
  return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

// node_modules/@ethersproject/contracts/lib.esm/_version.js
var version15 = "contracts/5.7.0";

// node_modules/@ethersproject/contracts/lib.esm/index.js
var __awaiter6 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger19 = new Logger(version15);
var allowedTransactionKeys3 = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
  return __awaiter6(this, void 0, void 0, function* () {
    const name2 = yield nameOrPromise;
    if (typeof name2 !== "string") {
      logger19.throwArgumentError("invalid address or ENS name", "name", name2);
    }
    try {
      return getAddress(name2);
    } catch (error) {
    }
    if (!resolver) {
      logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }
    const address = yield resolver.resolveName(name2);
    if (address == null) {
      logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
    }
    return address;
  });
}
function resolveAddresses(resolver, value, paramType) {
  return __awaiter6(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType2, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType2.name], paramType2);
      }));
    }
    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }
    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }
    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger19.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }
      return yield Promise.all(value.map((v5) => resolveAddresses(resolver, v5, paramType.arrayChildren)));
    }
    return value;
  });
}
function populateTransaction(contract, fragment, args) {
  return __awaiter6(this, void 0, void 0, function* () {
    let overrides = {};
    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = shallowCopy(args.pop());
    }
    logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
    if (contract.signer) {
      if (overrides.from) {
        overrides.from = resolveProperties({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then((check) => __awaiter6(this, void 0, void 0, function* () {
          if (getAddress(check.signer) !== check.override) {
            logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }
          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from);
    }
    const resolved = yield resolveProperties({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: resolveProperties(overrides) || {}
    });
    const data3 = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data3,
      to: resolved.address
    };
    const ro = resolved.overrides;
    if (ro.nonce != null) {
      tx.nonce = BigNumber.from(ro.nonce).toNumber();
    }
    if (ro.gasLimit != null) {
      tx.gasLimit = BigNumber.from(ro.gasLimit);
    }
    if (ro.gasPrice != null) {
      tx.gasPrice = BigNumber.from(ro.gasPrice);
    }
    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);
    }
    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);
    }
    if (ro.from != null) {
      tx.from = ro.from;
    }
    if (ro.type != null) {
      tx.type = ro.type;
    }
    if (ro.accessList != null) {
      tx.accessList = accessListify(ro.accessList);
    }
    if (tx.gasLimit == null && fragment.gas != null) {
      let intrinsic = 21e3;
      const bytes = arrayify(data3);
      for (let i4 = 0; i4 < bytes.length; i4++) {
        intrinsic += 4;
        if (bytes[i4]) {
          intrinsic += 64;
        }
      }
      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
    }
    if (ro.value) {
      const roValue = BigNumber.from(ro.value);
      if (!roValue.isZero() && !fragment.payable) {
        logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }
      tx.value = roValue;
    }
    if (ro.customData) {
      tx.customData = shallowCopy(ro.customData);
    }
    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    }
    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled;
    const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
    if (leftovers.length) {
      logger19.throwError(`cannot override ${leftovers.map((l4) => JSON.stringify(l4)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }
    return tx;
  });
}
function buildPopulate(contract, fragment) {
  return function(...args) {
    return populateTransaction(contract, fragment, args);
  };
}
function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }
      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}
function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);
  tx.wait = (confirmations) => {
    return wait(confirmations).then((receipt) => {
      receipt.events = receipt.logs.map((log) => {
        let event = deepCopy(log);
        let parsed = null;
        try {
          parsed = contract.interface.parseLog(log);
        } catch (e3) {
        }
        if (parsed) {
          event.args = parsed.args;
          event.decode = (data3, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data3, topics);
          };
          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        }
        event.removeListener = () => {
          return contract.provider;
        };
        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };
        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };
        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };
        return event;
      });
      return receipt;
    });
  };
}
function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      let blockTag = void 0;
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = shallowCopy(args.pop());
        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }
        delete overrides.blockTag;
        args.push(overrides);
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      }
      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);
      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);
        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }
        return value;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }
        throw error;
      }
    });
  };
}
function buildSend(contract, fragment) {
  return function(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      }
      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }
      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest);
      addContractWait(contract, tx);
      return tx;
    });
  };
}
function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }
  return buildSend(contract, fragment);
}
function getEventTag(filter2) {
  if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
    return "*";
  }
  return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }
    return topic;
  }).join(":") : "");
}
var RunningEvent = class {
  constructor(tag, filter2) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "filter", filter2);
    this._listeners = [];
  }
  addListener(listener, once) {
    this._listeners.push({ listener, once });
  }
  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter((item) => {
      if (done || item.listener !== listener) {
        return true;
      }
      done = true;
      return false;
    });
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((i4) => i4.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter((item) => {
      const argsCopy = args.slice();
      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0);
      return !item.once;
    });
    return listenerCount;
  }
  prepareEvent(event) {
  }
  // Returns the array that will be applied to an emit
  getEmit(event) {
    return [event];
  }
};
var ErrorRunningEvent = class extends RunningEvent {
  constructor() {
    super("error", null);
  }
};
var FragmentRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter2 = {
      address
    };
    let topic = contractInterface.getEventTopic(fragment);
    if (topics) {
      if (topic !== topics[0]) {
        logger19.throwArgumentError("topic mismatch", "topics", topics);
      }
      filter2.topics = topics.slice();
    } else {
      filter2.topics = [topic];
    }
    super(getEventTag(filter2), filter2);
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
    defineReadOnly(this, "fragment", fragment);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();
    event.decode = (data3, topics) => {
      return this.interface.decodeEventLog(this.fragment, data3, topics);
    };
    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }
  getEmit(event) {
    const errors = checkResultErrors(event.args);
    if (errors.length) {
      throw errors[0].error;
    }
    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }
};
var WildcardRunningEvent = class extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", { address });
    defineReadOnly(this, "address", address);
    defineReadOnly(this, "interface", contractInterface);
  }
  prepareEvent(event) {
    super.prepareEvent(event);
    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;
      event.decode = (data3, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data3, topics);
      };
      event.args = parsed.args;
    } catch (error) {
    }
  }
};
var BaseContract = class {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    if (signerOrProvider == null) {
      defineReadOnly(this, "provider", null);
      defineReadOnly(this, "signer", null);
    } else if (Signer.isSigner(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider.provider || null);
      defineReadOnly(this, "signer", signerOrProvider);
    } else if (Provider.isProvider(signerOrProvider)) {
      defineReadOnly(this, "provider", signerOrProvider);
      defineReadOnly(this, "signer", null);
    } else {
      logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }
    defineReadOnly(this, "callStatic", {});
    defineReadOnly(this, "estimateGas", {});
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "populateTransaction", {});
    defineReadOnly(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach((eventSignature) => {
        const event = this.interface.events[eventSignature];
        defineReadOnly(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });
        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }
        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach((name2) => {
        const filters = uniqueFilters[name2];
        if (filters.length === 1) {
          defineReadOnly(this.filters, name2, this.filters[filters[0]]);
        } else {
          logger19.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
        }
      });
    }
    defineReadOnly(this, "_runningEvents", {});
    defineReadOnly(this, "_wrappedEmits", {});
    if (addressOrName == null) {
      logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }
    defineReadOnly(this, "address", addressOrName);
    if (this.provider) {
      defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress(addressOrName)));
      } catch (error) {
        logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    }
    this.resolvedAddress.catch((e3) => {
    });
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach((signature2) => {
      const fragment = this.interface.functions[signature2];
      if (uniqueSignatures[signature2]) {
        logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
        return;
      }
      uniqueSignatures[signature2] = true;
      {
        const name2 = fragment.name;
        if (!uniqueNames[`%${name2}`]) {
          uniqueNames[`%${name2}`] = [];
        }
        uniqueNames[`%${name2}`].push(signature2);
      }
      if (this[signature2] == null) {
        defineReadOnly(this, signature2, buildDefault(this, fragment, true));
      }
      if (this.functions[signature2] == null) {
        defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
      }
      if (this.callStatic[signature2] == null) {
        defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
      }
      if (this.populateTransaction[signature2] == null) {
        defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
      }
      if (this.estimateGas[signature2] == null) {
        defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach((name2) => {
      const signatures = uniqueNames[name2];
      if (signatures.length > 1) {
        return;
      }
      name2 = name2.substring(1);
      const signature2 = signatures[0];
      try {
        if (this[name2] == null) {
          defineReadOnly(this, name2, this[signature2]);
        }
      } catch (e3) {
      }
      if (this.functions[name2] == null) {
        defineReadOnly(this.functions, name2, this.functions[signature2]);
      }
      if (this.callStatic[name2] == null) {
        defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
      }
      if (this.populateTransaction[name2] == null) {
        defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
      }
      if (this.estimateGas[name2] == null) {
        defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
      }
    });
  }
  static getContractAddress(transaction) {
    return getContractAddress(transaction);
  }
  static getInterface(contractInterface) {
    if (Interface.isInterface(contractInterface)) {
      return contractInterface;
    }
    return new Interface(contractInterface);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(blockTag) {
    if (!this._deployedPromise) {
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
          if (code2 === "0x") {
            logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }
          return this;
        });
      }
    }
    return this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(overrides) {
    if (!this.signer) {
      logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    }
    const tx = shallowCopy(overrides || {});
    ["from", "to"].forEach(function(key2) {
      if (tx[key2] == null) {
        return;
      }
      logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  }
  // Reconnect to a different signer or provider
  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
    }
    const contract = new this.constructor(this.address, this.interface, signerOrProvider);
    if (this.deployTransaction) {
      defineReadOnly(contract, "deployTransaction", this.deployTransaction);
    }
    return contract;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }
  static isIndexed(value) {
    return Indexed.isIndexed(value);
  }
  _normalizeRunningEvent(runningEvent) {
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }
    return runningEvent;
  }
  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      }
      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      }
      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      }
      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    }
    if (eventName.topics && eventName.topics.length > 0) {
      try {
        const topic = eventName.topics[0];
        if (typeof topic !== "string") {
          throw new Error("invalid topic");
        }
        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {
      }
      const filter2 = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
    }
    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }
  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag];
      const emit = this._wrappedEmits[runningEvent.tag];
      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(runningEvent, log, listener) {
    const event = deepCopy(log);
    event.removeListener = () => {
      if (!listener) {
        return;
      }
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
    };
    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };
    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };
    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    };
    runningEvent.prepareEvent(event);
    return event;
  }
  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
    }
    runningEvent.addListener(listener, once);
    this._runningEvents[runningEvent.tag] = runningEvent;
    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = (log) => {
        let event = this._wrapEvent(runningEvent, log, listener);
        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        }
        if (runningEvent.filter != null) {
          this.emit("event", event);
        }
        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };
      this._wrappedEmits[runningEvent.tag] = wrappedEmit;
      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }
  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);
    const filter2 = shallowCopy(runningEvent.filter);
    if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }
      filter2.blockHash = fromBlockOrBlockhash;
    } else {
      filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter2.toBlock = toBlock != null ? toBlock : "latest";
    }
    return this.provider.getLogs(filter2).then((logs) => {
      return logs.map((log) => this._wrapEvent(runningEvent, log, null));
    });
  }
  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);
    return this;
  }
  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);
    return this;
  }
  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }
    const runningEvent = this._getRunningEvent(eventName);
    const result = runningEvent.run(args) > 0;
    this._checkRunningEvents(runningEvent);
    return result;
  }
  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }
    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key2) => {
        return accum + this._runningEvents[key2].listenerCount();
      }, 0);
    }
    return this._getRunningEvent(eventName).listenerCount();
  }
  listeners(eventName) {
    if (!this.provider) {
      return [];
    }
    if (eventName == null) {
      const result = [];
      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach((listener) => {
          result.push(listener);
        });
      }
      return result;
    }
    return this._getRunningEvent(eventName).listeners();
  }
  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }
    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent2 = this._runningEvents[tag];
        runningEvent2.removeAllListeners();
        this._checkRunningEvents(runningEvent2);
      }
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeAllListeners();
    this._checkRunningEvents(runningEvent);
    return this;
  }
  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }
    const runningEvent = this._getRunningEvent(eventName);
    runningEvent.removeListener(listener);
    this._checkRunningEvents(runningEvent);
    return this;
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
};
var Contract = class extends BaseContract {
};
var ContractFactory = class {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;
    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if (isBytes(bytecode)) {
      bytecodeHex = hexlify(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      bytecodeHex = bytecode.object;
    } else {
      bytecodeHex = "!";
    }
    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    }
    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
      logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    }
    if (signer && !Signer.isSigner(signer)) {
      logger19.throwArgumentError("invalid signer", "signer", signer);
    }
    defineReadOnly(this, "bytecode", bytecodeHex);
    defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
    defineReadOnly(this, "signer", signer || null);
  }
  // @TODO: Future; rename to populateTransaction?
  getDeployTransaction(...args) {
    let tx = {};
    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = shallowCopy(args.pop());
      for (const key2 in tx) {
        if (!allowedTransactionKeys3[key2]) {
          throw new Error("unknown transaction override " + key2);
        }
      }
    }
    ["data", "from", "to"].forEach((key2) => {
      if (tx[key2] == null) {
        return;
      }
      logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
    });
    if (tx.value) {
      const value = BigNumber.from(tx.value);
      if (!value.isZero() && !this.interface.deploy.payable) {
        logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    }
    logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
    tx.data = hexlify(concat2([
      this.bytecode,
      this.interface.encodeDeploy(args)
    ]));
    return tx;
  }
  deploy(...args) {
    return __awaiter6(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      }
      logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides);
      const unsignedTx = this.getDeployTransaction(...params);
      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = getStatic(this.constructor, "getContractAddress")(tx);
      const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
      addContractWait(contract, tx);
      defineReadOnly(contract, "deployTransaction", tx);
      return contract;
    });
  }
  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }
  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }
  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
    }
    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }
    const abi = compilerOutput.abi;
    let bytecode = null;
    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }
    return new this(abi, bytecode, signer);
  }
  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }
  static getContractAddress(tx) {
    return getContractAddress(tx);
  }
  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }
};

// node_modules/@ethersproject/basex/lib.esm/index.js
var BaseX = class {
  constructor(alphabet2) {
    defineReadOnly(this, "alphabet", alphabet2);
    defineReadOnly(this, "base", alphabet2.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet2.charAt(0));
    for (let i4 = 0; i4 < alphabet2.length; i4++) {
      this._alphabetMap[alphabet2.charAt(i4)] = i4;
    }
  }
  encode(value) {
    let source = arrayify(value);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i4 = 0; i4 < source.length; ++i4) {
      let carry = source[i4];
      for (let j7 = 0; j7 < digits.length; ++j7) {
        carry += digits[j7] << 8;
        digits[j7] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string3 = "";
    for (let k5 = 0; source[k5] === 0 && k5 < source.length - 1; ++k5) {
      string3 += this._leader;
    }
    for (let q5 = digits.length - 1; q5 >= 0; --q5) {
      string3 += this.alphabet[digits[q5]];
    }
    return string3;
  }
  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes = [];
    if (value.length === 0) {
      return new Uint8Array(bytes);
    }
    bytes.push(0);
    for (let i4 = 0; i4 < value.length; i4++) {
      let byte = this._alphabetMap[value[i4]];
      if (byte === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte;
      for (let j7 = 0; j7 < bytes.length; ++j7) {
        carry += bytes[j7] * this.base;
        bytes[j7] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k5 = 0; value[k5] === this._leader && k5 < value.length - 1; ++k5) {
      bytes.push(0);
    }
    return arrayify(new Uint8Array(bytes.reverse()));
  }
};
var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
var import_hash3 = __toESM(require_hash2());

// node_modules/@ethersproject/sha2/lib.esm/types.js
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

// node_modules/@ethersproject/sha2/lib.esm/_version.js
var version16 = "sha2/5.7.0";

// node_modules/@ethersproject/sha2/lib.esm/sha2.js
var logger20 = new Logger(version16);
function ripemd160(data3) {
  return "0x" + import_hash3.default.ripemd160().update(arrayify(data3)).digest("hex");
}
function sha2562(data3) {
  return "0x" + import_hash3.default.sha256().update(arrayify(data3)).digest("hex");
}
function sha5122(data3) {
  return "0x" + import_hash3.default.sha512().update(arrayify(data3)).digest("hex");
}
function computeHmac(algorithm, key2, data3) {
  if (!SupportedAlgorithm[algorithm]) {
    logger20.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm
    });
  }
  return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify(key2)).update(arrayify(data3)).digest("hex");
}

// node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l4 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r5;
  let T4;
  for (let i4 = 1; i4 <= l4; i4++) {
    block1[salt.length] = i4 >> 24 & 255;
    block1[salt.length + 1] = i4 >> 16 & 255;
    block1[salt.length + 2] = i4 >> 8 & 255;
    block1[salt.length + 3] = i4 & 255;
    let U5 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U5.length;
      T4 = new Uint8Array(hLen);
      l4 = Math.ceil(keylen / hLen);
      r5 = keylen - (l4 - 1) * hLen;
    }
    T4.set(U5);
    for (let j7 = 1; j7 < iterations; j7++) {
      U5 = arrayify(computeHmac(hashAlgorithm, password, U5));
      for (let k5 = 0; k5 < hLen; k5++)
        T4[k5] ^= U5[k5];
    }
    const destPos = (i4 - 1) * hLen;
    const len = i4 === l4 ? r5 : hLen;
    DK.set(arrayify(T4).slice(0, len), destPos);
  }
  return hexlify(DK);
}

// node_modules/@ethersproject/wordlists/lib.esm/_version.js
var version17 = "wordlists/5.7.0";

// node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
var exportWordlist = false;
var logger21 = new Logger(version17);
var Wordlist = class _Wordlist {
  constructor(locale) {
    logger21.checkAbstract(new.target, _Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  // Subclasses may override this
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i4 = 0; i4 < 2048; i4++) {
      const word = wordlist2.getWord(i4);
      if (i4 !== wordlist2.getWordIndex(word)) {
        return "0x";
      }
      words2.push(word);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
    if (!name2) {
      name2 = lang.locale;
    }
    if (exportWordlist) {
      try {
        const anyGlobal2 = window;
        if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
          if (!anyGlobal2._ethers.wordlists[name2]) {
            defineReadOnly(anyGlobal2._ethers.wordlists, name2, lang);
          }
        }
      } catch (error) {
      }
    }
  }
};

// node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
var wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
var LangEn = class extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }
  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }
};
var langEn = new LangEn();
Wordlist.register(langEn);

// node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
var wordlists = {
  en: langEn
};

// node_modules/@ethersproject/hdnode/lib.esm/_version.js
var version18 = "hdnode/5.7.0";

// node_modules/@ethersproject/hdnode/lib.esm/index.js
var logger22 = new Logger(version18);
var N13 = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var MasterSecret = toUtf8Bytes("Bitcoin seed");
var HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value) {
  return hexZeroPad(hexlify(value), 32);
}
function base58check(data3) {
  return Base58.encode(concat2([data3, hexDataSlice(sha2562(sha2562(data3)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger22.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
var _constructorGuard4 = {};
var defaultPath = "m/44'/60'/0'/0/0";
var HDNode = class _HDNode {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    if (constructorGuard !== _constructorGuard4) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha2562(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat2([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat2(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new _HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index) {
    if (index > 4294967295) {
      throw new Error("invalid index - " + String(index));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
    }
    const data3 = new Uint8Array(37);
    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data3.set(arrayify(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data3.set(arrayify(this.publicKey));
    }
    for (let i4 = 24; i4 >= 0; i4 -= 8) {
      data3[33 + (i4 >> 3)] = index >> 24 - i4 & 255;
    }
    const I3 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data3));
    const IL = I3.slice(0, 32);
    const IR = I3.slice(32);
    let ki2 = null;
    let Ki2 = null;
    if (this.privateKey) {
      ki2 = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N13));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki2 = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new _HDNode(_constructorGuard4, ki2, Ki2, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i4 = 0; i4 < components.length; i4++) {
      const component = components[i4];
      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);
        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I3 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new _HDNode(_constructorGuard4, bytes32(I3.slice(0, 32)), null, "0x00000000", bytes32(I3.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return _HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return _HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes = Base58.decode(extendedKey);
    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes[4];
    const parentFingerprint = hexlify(bytes.slice(5, 9));
    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes.slice(13, 45));
    const key2 = bytes.slice(45, 78);
    switch (hexlify(bytes.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new _HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new _HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }
    return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
};
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger22.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i4 = 0; i4 < words2.length; i4++) {
    let index = wordlist2.getWordIndex(words2[i4].normalize("NFKD"));
    if (index === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i4 = 0; i4 < entropy.length; i4++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i4];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i4] >> 8 - remainingBits;
      indices.push(entropy[i4] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha2562(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index) => wordlist2.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error) {
  }
  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger22.throwArgumentError("invalid account index", "index", index);
  }
  return `m/44'/60'/${index}'/0/0`;
}

// node_modules/@ethersproject/random/lib.esm/_version.js
var version19 = "random/5.7.0";

// node_modules/@ethersproject/random/lib.esm/random.js
var logger23 = new Logger(version19);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
var anyGlobal = getGlobal();
var crypto2 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto2 || !crypto2.getRandomValues) {
  logger23.warn("WARNING: Missing strong random number source");
  crypto2 = {
    getRandomValues: function(buffer2) {
      return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes2(length2) {
  if (length2 <= 0 || length2 > 1024 || length2 % 1 || length2 != length2) {
    logger23.throwArgumentError("invalid length", "length", length2);
  }
  const result = new Uint8Array(length2);
  crypto2.getRandomValues(result);
  return arrayify(result);
}

// node_modules/@ethersproject/random/lib.esm/shuffle.js
function shuffled(array2) {
  array2 = array2.slice();
  for (let i4 = array2.length - 1; i4 > 0; i4--) {
    const j7 = Math.floor(Math.random() * (i4 + 1));
    const tmp = array2[i4];
    array2[i4] = array2[j7];
    array2[j7] = tmp;
  }
  return array2;
}

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var import_aes_js = __toESM(require_aes_js());

// node_modules/@ethersproject/json-wallets/lib.esm/_version.js
var version20 = "json-wallets/5.7.0";

// node_modules/@ethersproject/json-wallets/lib.esm/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value, length2) {
  value = String(value);
  while (value.length < length2) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object2, path) {
  let currentChild = object2;
  const comps = path.toLowerCase().split("/");
  for (let i4 = 0; i4 < comps.length; i4++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i4]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes3) {
  const bytes = arrayify(randomBytes3);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 63 | 128;
  const value = hexlify(bytes);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}

// node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
var logger24 = new Logger(version20);
var CrowdsaleAccount = class extends Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }
};
function decrypt(json, password) {
  const data3 = JSON.parse(json);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data3, "ethaddr"));
  const encseed = looseArrayify(searchPath(data3, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger24.throwArgumentError("invalid encseed", "json", json);
  }
  const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv2 = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv2);
  const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i4 = 0; i4 < seed.length; i4++) {
    seedHex += String.fromCharCode(seed[i4]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}

// node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
function isCrowdsaleWallet(json) {
  let data3 = null;
  try {
    data3 = JSON.parse(json);
  } catch (error) {
    return false;
  }
  return data3.encseed && data3.ethaddr;
}
function isKeystoreWallet(json) {
  let data3 = null;
  try {
    data3 = JSON.parse(json);
  } catch (error) {
    return false;
  }
  if (!data3.version || parseInt(data3.version) !== data3.version || parseInt(data3.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return getAddress(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }
  if (isKeystoreWallet(json)) {
    try {
      return getAddress(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }
  return null;
}

// node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
var import_aes_js2 = __toESM(require_aes_js());
var import_scrypt_js = __toESM(require_scrypt());
var __awaiter7 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger25 = new Logger(version20);
function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}
var KeystoreAccount = class extends Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }
};
function _decrypt(data3, key2, ciphertext) {
  const cipher = searchPath(data3, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv2 = looseArrayify(searchPath(data3, "crypto/cipherparams/iv"));
    const counter = new import_aes_js2.default.Counter(iv2);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data3, key2) {
  const ciphertext = looseArrayify(searchPath(data3, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256(concat2([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data3, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data3, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data3.address) {
    let check = data3.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data3, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data3, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data3, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
    const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data3, "x-ethers/path") || defaultPath;
    const locale = searchPath(data3, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account.mnemonic = node.mnemonic;
    } catch (error) {
      if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }
  return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc) {
  return arrayify(pbkdf2(passwordBytes, salt, count2, dkLen, prfFunc));
}
function pbkdf22(passwordBytes, salt, count2, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc));
}
function _computeKdfKey(data3, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data3, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name2, value) {
      return logger25.throwArgumentError("invalid key-derivation function parameters", name2, value);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data3, "crypto/kdfparams/salt"));
      const N15 = parseInt(searchPath(data3, "crypto/kdfparams/n"));
      const r5 = parseInt(searchPath(data3, "crypto/kdfparams/r"));
      const p6 = parseInt(searchPath(data3, "crypto/kdfparams/p"));
      if (!N15 || !r5 || !p6) {
        throwError2("kdf", kdf);
      }
      if ((N15 & N15 - 1) !== 0) {
        throwError2("N", N15);
      }
      const dkLen = parseInt(searchPath(data3, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N15, r5, p6, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data3, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data3, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count2 = parseInt(searchPath(data3, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data3, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count2, dkLen, prfFunc);
    }
  }
  return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
  const data3 = JSON.parse(json);
  const key2 = _computeKdfKey(data3, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
  return _getAccount(data3, key2);
}
function decrypt2(json, password, progressCallback) {
  return __awaiter7(this, void 0, void 0, function* () {
    const data3 = JSON.parse(json);
    const key2 = yield _computeKdfKey(data3, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
    return _getAccount(data3, key2);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    if (getAddress(account.address) !== computeAddress(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e3) {
    return Promise.reject(e3);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes2(32);
    ;
  }
  let iv2 = null;
  if (options.iv) {
    iv2 = arrayify(options.iv);
    if (iv2.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv2 = randomBytes2(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes2(16);
  }
  let N15 = 1 << 17, r5 = 8, p6 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N15 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r5 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p6 = options.scrypt.p;
    }
  }
  return import_scrypt_js.default.scrypt(passwordBytes, salt, N15, r5, p6, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new import_aes_js2.default.Counter(iv2);
    const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256(concat2([macPrefix, ciphertext]));
    const data3 = {
      address: account.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv2).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N15,
          dklen: 32,
          p: p6,
          r: r5
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes2(16);
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now2 = /* @__PURE__ */ new Date();
      const timestamp2 = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
      data3["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp2 + "--" + data3.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data3);
  });
}

// node_modules/@ethersproject/json-wallets/lib.esm/index.js
function decryptJsonWallet(json, password, progressCallback) {
  if (isCrowdsaleWallet(json)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account = decrypt(json, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account);
  }
  if (isKeystoreWallet(json)) {
    return decrypt2(json, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
  if (isCrowdsaleWallet(json)) {
    return decrypt(json, password);
  }
  if (isKeystoreWallet(json)) {
    return decryptSync(json, password);
  }
  throw new Error("invalid JSON wallet");
}

// node_modules/@ethersproject/wallet/lib.esm/_version.js
var version21 = "wallet/5.7.0";

// node_modules/@ethersproject/wallet/lib.esm/index.js
var __awaiter8 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger26 = new Logger(version21);
function isAccount(value) {
  return value != null && isHexString(value.privateKey, 32) && value.address != null;
}
function hasMnemonic2(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}
var Wallet = class _Wallet extends Signer {
  constructor(privateKey, provider) {
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic2(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger26.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new _Wallet(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256(serialize(tx)));
      return serialize(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter8(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter8(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
        if (this.provider == null) {
          logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt(this, password, options, progressCallback);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(options) {
    let entropy = randomBytes2(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256(concat2([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return _Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json, password, progressCallback) {
    return decryptJsonWallet(json, password, progressCallback).then((account) => {
      return new _Wallet(account);
    });
  }
  static fromEncryptedJsonSync(json, password) {
    return new _Wallet(decryptJsonWalletSync(json, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new _Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
};
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain, types, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature2);
}

// node_modules/@ethersproject/providers/lib.esm/index.js
var lib_exports4 = {};
__export(lib_exports4, {
  AlchemyProvider: () => AlchemyProvider,
  AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
  AnkrProvider: () => AnkrProvider,
  BaseProvider: () => BaseProvider,
  CloudflareProvider: () => CloudflareProvider,
  EtherscanProvider: () => EtherscanProvider,
  FallbackProvider: () => FallbackProvider,
  Formatter: () => Formatter,
  InfuraProvider: () => InfuraProvider,
  InfuraWebSocketProvider: () => InfuraWebSocketProvider,
  IpcProvider: () => IpcProvider,
  JsonRpcBatchProvider: () => JsonRpcBatchProvider,
  JsonRpcProvider: () => JsonRpcProvider2,
  JsonRpcSigner: () => JsonRpcSigner,
  NodesmithProvider: () => NodesmithProvider,
  PocketProvider: () => PocketProvider,
  Provider: () => Provider,
  Resolver: () => Resolver,
  StaticJsonRpcProvider: () => StaticJsonRpcProvider,
  UrlJsonRpcProvider: () => UrlJsonRpcProvider,
  Web3Provider: () => Web3Provider,
  WebSocketProvider: () => WebSocketProvider,
  getDefaultProvider: () => getDefaultProvider,
  getNetwork: () => getNetwork,
  isCommunityResourcable: () => isCommunityResourcable,
  isCommunityResource: () => isCommunityResource,
  showThrottleMessage: () => showThrottleMessage
});

// node_modules/@ethersproject/networks/lib.esm/_version.js
var version22 = "networks/5.7.1";

// node_modules/@ethersproject/networks/lib.esm/index.js
var logger27 = new Logger(version22);
function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func2 = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {
      }
    }
    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {
      }
    }
    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {
      }
    }
    if (providers.PocketProvider && options.pocket !== "-") {
      const skip2 = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const provider = new providers.PocketProvider(network, options.pocket);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {
      }
    }
    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        const skip2 = ["ropsten"];
        const provider = new providers.AnkrProvider(network, options.ankr);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func2.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func2;
}
function etcDefaultProvider(url, network) {
  const func2 = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }
    return null;
  };
  func2.renetwork = function(network2) {
    return etcDefaultProvider(url, network2);
  };
  return func2;
}
var homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
var ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
var classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
var networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: ethDefaultProvider("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: ethDefaultProvider("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: ethDefaultProvider("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger27.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger27.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

// node_modules/@ethersproject/web/lib.esm/_version.js
var version23 = "web/5.7.1";

// node_modules/@ethersproject/web/lib.esm/geturl.js
var __awaiter9 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter9(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    ;
    if (options.fetchOptions != null) {
      const opts = options.fetchOptions;
      if (opts.mode) {
        request.mode = opts.mode;
      }
      if (opts.cache) {
        request.cache = opts.cache;
      }
      if (opts.credentials) {
        request.credentials = opts.credentials;
      }
      if (opts.redirect) {
        request.redirect = opts.redirect;
      }
      if (opts.referrer) {
        request.referrer = opts.referrer;
      }
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value, key2) => {
        headers[key2.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}

// node_modules/@ethersproject/web/lib.esm/index.js
var __awaiter10 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger28 = new Logger(version23);
function staller(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
function bodyify(value, type2) {
  if (value == null) {
    return null;
  }
  if (typeof value === "string") {
    return value;
  }
  if (isBytesLike(value)) {
    if (type2 && (type2.split("/")[0] === "text" || type2.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {
      }
      ;
    }
    return hexlify(value);
  }
  return value;
}
function unpercent(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
    return String.fromCharCode(parseInt(code2, 16));
  }));
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger28.throwArgumentError("missing URL", "connection.url", connection);
    }
    url = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode6(toUtf8Bytes(authorization))
      };
    }
    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
    if (connection.fetchOptions != null) {
      options.fetchOptions = shallowCopy(connection.fetchOptions);
    }
  }
  const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] || "text/plain" },
        body: dataMatch[2] ? decode7(dataMatch[3]) : unpercent(dataMatch[3])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error) {
      logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error,
        requestBody: null,
        requestMethod: "GET",
        url
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer3 = null;
    const promise = new Promise(function(resolve, reject) {
      if (timeout2) {
        timer3 = setTimeout(() => {
          if (timer3 == null) {
            return;
          }
          timer3 = null;
          reject(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer3 == null) {
        return;
      }
      clearTimeout(timer3);
      timer3 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter10(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                let stall3 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall3 = parseInt(retryAfter) * 1e3;
                } else {
                  stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall3);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;
          if (response == null) {
            runningTimeout.cancel();
            logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;
    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json != null) {
    body = toUtf8Bytes(json);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k5) => k5.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func2, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve, reject) {
    let timer3 = null;
    let done = false;
    const cancel = () => {
      if (done) {
        return false;
      }
      done = true;
      if (timer3) {
        clearTimeout(timer3);
      }
      return true;
    };
    if (options.timeout) {
      timer3 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func2().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error) {
        if (cancel()) {
          reject(error);
        }
      });
    }
    check();
  });
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var import_bech32 = __toESM(require_bech32());

// node_modules/@ethersproject/providers/lib.esm/_version.js
var version24 = "providers/5.7.2";

// node_modules/@ethersproject/providers/lib.esm/formatter.js
var logger29 = new Logger(version24);
var Formatter = class _Formatter {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data3 = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type2 = this.type.bind(this);
    const strictData = (v5) => {
      return this.data(v5, true);
    };
    formats.transaction = {
      hash: hash3,
      type: type2,
      accessList: _Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: _Formatter.allowNull(hash3, null),
      blockNumber: _Formatter.allowNull(number2, null),
      transactionIndex: _Formatter.allowNull(number2, null),
      confirmations: _Formatter.allowNull(number2, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: _Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: _Formatter.allowNull(bigNumber),
      maxFeePerGas: _Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: _Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data: data3,
      r: _Formatter.allowNull(this.uint256),
      s: _Formatter.allowNull(this.uint256),
      v: _Formatter.allowNull(number2),
      creates: _Formatter.allowNull(address, null),
      raw: _Formatter.allowNull(data3)
    };
    formats.transactionRequest = {
      from: _Formatter.allowNull(address),
      nonce: _Formatter.allowNull(number2),
      gasLimit: _Formatter.allowNull(bigNumber),
      gasPrice: _Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: _Formatter.allowNull(bigNumber),
      maxFeePerGas: _Formatter.allowNull(bigNumber),
      to: _Formatter.allowNull(address),
      value: _Formatter.allowNull(bigNumber),
      data: _Formatter.allowNull(strictData),
      type: _Formatter.allowNull(number2),
      accessList: _Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash3,
      address,
      topics: _Formatter.arrayOf(hash3),
      data: data3,
      logIndex: number2,
      blockHash: hash3
    };
    formats.receipt = {
      to: _Formatter.allowNull(this.address, null),
      from: _Formatter.allowNull(this.address, null),
      contractAddress: _Formatter.allowNull(address, null),
      transactionIndex: number2,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: _Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: _Formatter.allowNull(data3),
      blockHash: hash3,
      transactionHash: hash3,
      logs: _Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: _Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: _Formatter.allowNull(bigNumber),
      status: _Formatter.allowNull(number2),
      type: type2
    };
    formats.block = {
      hash: _Formatter.allowNull(hash3),
      parentHash: hash3,
      number: number2,
      timestamp: number2,
      nonce: _Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: _Formatter.allowNull(address),
      extraData: data3,
      transactions: _Formatter.allowNull(_Formatter.arrayOf(hash3)),
      baseFeePerGas: _Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = _Formatter.allowNull(_Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: _Formatter.allowNull(blockTag, void 0),
      toBlock: _Formatter.allowNull(blockTag, void 0),
      blockHash: _Formatter.allowNull(hash3, void 0),
      address: _Formatter.allowNull(address, void 0),
      topics: _Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: _Formatter.allowNull(number2),
      blockHash: _Formatter.allowNull(hash3),
      transactionIndex: number2,
      removed: _Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: _Formatter.allowFalsish(data3, "0x"),
      topics: _Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  // Strict! Used on input.
  bigNumber(value) {
    return BigNumber.from(value);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }
    if (typeof value === "string") {
      value = value.toLowerCase();
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value);
  }
  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexString(value)) {
        return value.toLowerCase();
      }
    }
    return logger29.throwArgumentError("invalid hash", "value", value);
  }
  data(value, strict) {
    const result = this.hex(value, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }
    return result;
  }
  // Requires an address
  // Strict! Used on input.
  address(value) {
    return getAddress(value);
  }
  callAddress(value) {
    if (!isHexString(value, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value) {
    return getContractAddress(value);
  }
  // Strict! Used on input.
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (typeof blockTag === "number" || isHexString(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(value, strict) {
    const result = this.hex(value, strict);
    if (hexDataLength(result) !== 32) {
      return logger29.throwArgumentError("invalid hash", "value", value);
    }
    return result;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(value) {
    if (value == null) {
      return null;
    }
    const v5 = BigNumber.from(value);
    try {
      return v5.toNumber();
    } catch (error) {
    }
    return null;
  }
  uint256(value) {
    if (!isHexString(value)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value, 32);
  }
  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    }
    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = _Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value) {
    return this._block(value, this.formats.block);
  }
  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(value) {
    return _Formatter.check(this.formats.transactionRequest, value);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = _Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value) {
    return parse2(value);
  }
  receiptLog(value) {
    return _Formatter.check(this.formats.receiptLog, value);
  }
  receipt(value) {
    const result = _Formatter.check(this.formats.receipt, value);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value2 = BigNumber.from(result.root).toNumber();
        if (value2 === 0 || value2 === 1) {
          if (result.status != null && result.status !== value2) {
            logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value2;
          delete result.root;
        } else {
          logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger29.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value) {
    if (Array.isArray(value)) {
      return value.map((v5) => this.topics(v5));
    } else if (value != null) {
      return this.hash(value, true);
    }
    return null;
  }
  filter(value) {
    return _Formatter.check(this.formats.filter, value);
  }
  filterLog(value) {
    return _Formatter.check(this.formats.filterLog, value);
  }
  static check(format, object2) {
    const result = {};
    for (const key2 in format) {
      try {
        const value = format[key2](object2[key2]);
        if (value !== void 0) {
          result[key2] = value;
        }
      } catch (error) {
        error.checkKey = key2;
        error.checkValue = object2[key2];
        throw error;
      }
    }
    return result;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(format, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format(value);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(format, replaceValue) {
    return function(value) {
      if (!value) {
        return replaceValue;
      }
      return format(value);
    };
  }
  // Requires an Array satisfying check
  static arrayOf(format) {
    return function(array2) {
      if (!Array.isArray(array2)) {
        throw new Error("not an array");
      }
      const result = [];
      array2.forEach(function(value) {
        result.push(format(value));
      });
      return result;
    };
  }
};
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
}
var throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }
  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.io/api-keys/");
  console.log("==========================");
}

// node_modules/@ethersproject/providers/lib.esm/base-provider.js
var __awaiter11 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger30 = new Logger(version24);
var MAX_CCIP_REDIRECTS = 10;
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger30.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data3) {
  if (data3 === "") {
    return [];
  }
  return data3.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag2(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger30.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function stall(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
}
var PollableEvents = ["block", "network", "pending", "poll"];
var Event2 = class {
  constructor(tag, listener, once) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
};
var coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
}
function base58Encode(data3) {
  return Base58.encode(concat2([data3, hexDataSlice(sha2562(sha2562(data3)), 0, 4)]));
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {
  }
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  const length2 = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length2);
}
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger30.throwArgumentError("unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
  const result = arrayify(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
function encodeBytes(datas) {
  const result = [];
  let byteCount = 0;
  for (let i4 = 0; i4 < datas.length; i4++) {
    result.push(null);
    byteCount += 32;
  }
  for (let i4 = 0; i4 < datas.length; i4++) {
    const data3 = arrayify(datas[i4]);
    result[i4] = numPad(byteCount);
    result.push(numPad(data3.length));
    result.push(bytesPad(data3));
    byteCount += 32 + Math.ceil(data3.length / 32) * 32;
  }
  return hexConcat(result);
}
var Resolver = class {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  supportsWildcard() {
    if (!this._supportsEip2544) {
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then((result) => {
        return BigNumber.from(result).eq(1);
      }).catch((error) => {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return false;
        }
        this._supportsEip2544 = null;
        throw error;
      });
    }
    return this._supportsEip2544;
  }
  _fetch(selector, parameters) {
    return __awaiter11(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      let parseBytes = false;
      if (yield this.supportsWildcard()) {
        parseBytes = true;
        tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);
      }
      try {
        let result = yield this.provider.call(tx);
        if (arrayify(result).length % 32 === 4) {
          logger30.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }
        if (parseBytes) {
          result = _parseBytes(result, 0);
        }
        return result;
      } catch (error) {
        if (error.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error;
      }
    });
  }
  _fetchBytes(selector, parameters) {
    return __awaiter11(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);
      if (result != null) {
        return _parseBytes(result, 0);
      }
      return null;
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length2 = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat2([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length2 = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
          return base58Encode(concat2([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length2 = bytes[1];
      let version28 = bytes[0];
      if (version28 === 0) {
        if (length2 !== 20 && length2 !== 32) {
          version28 = -1;
        }
      } else {
        version28 = -1;
      }
      if (version28 >= 0 && bytes.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
        const words2 = import_bech32.default.toWords(bytes.slice(2));
        words2.unshift(version28);
        return import_bech32.default.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = yield this._fetch("0x3b3b57de");
          if (result === "0x" || result === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter11(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i4 = 0; i4 < matchers.length; i4++) {
          const match = avatar.match(matchers[i4]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx), 0);
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url-base", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter11(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length2 = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length2 * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipns) {
        const length2 = parseInt(ipns[3], 16);
        if (ipns[4].length === length2 * 2) {
          return "ipns://" + Base58.encode("0x" + ipns[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
      if (skynet) {
        if (skynet[1].length === 34 * 2) {
          const urlSafe = { "=": "", "+": "-", "/": "_" };
          const hash3 = encode6("0x" + skynet[1]).replace(/[=+\/]/g, (a4) => urlSafe[a4]);
          return "sia://" + hash3;
        }
      }
      return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter11(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat2([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat2([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
};
var defaultFormatter = null;
var nextPollId = 1;
var BaseProvider = class extends Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error) => {
      });
      this._ready().catch((error) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger30.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter11(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error) => {
        if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return void 0;
        }
        throw error;
      });
    });
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  ccipReadFetch(tx, calldata, urls) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data3 = calldata.toLowerCase();
      const errorMessages = [];
      for (let i4 = 0; i4 < urls.length; i4++) {
        const url = urls[i4];
        const href = url.replace("{sender}", sender).replace("{data}", data3);
        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data3, sender });
        const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });
        if (result.data) {
          return result.data;
        }
        const errorMessage = result.message || "unknown error";
        if (result.status >= 400 && result.status < 500) {
          return logger30.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
        }
        errorMessages.push(errorMessage);
      }
      return logger30.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m5) => JSON.stringify(m5)).join(", ")}`, Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(maxAge) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error) => error)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter11(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i4 = this._emitted.block + 1; i4 <= blockNumber; i4++) {
          this.emit("block", i4);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error) => {
              this.emit("error", error);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            if (!event._inflight) {
              event._inflight = true;
              if (event._lastBlockNumber === -2) {
                event._lastBlockNumber = blockNumber - 1;
              }
              const filter2 = event.filter;
              filter2.fromBlock = event._lastBlockNumber + 1;
              filter2.toBlock = blockNumber;
              const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
              if (minFromBlock > filter2.fromBlock) {
                filter2.fromBlock = minFromBlock;
              }
              if (filter2.fromBlock < 0) {
                filter2.fromBlock = 0;
              }
              const runner = this.getLogs(filter2).then((logs) => {
                event._inflight = false;
                if (logs.length === 0) {
                  return;
                }
                logs.forEach((log) => {
                  if (log.blockNumber > event._lastBlockNumber) {
                    event._lastBlockNumber = log.blockNumber;
                  }
                  this._emitted["b:" + log.blockHash] = log.blockNumber;
                  this._emitted["t:" + log.transactionHash] = log.blockNumber;
                  this.emit(filter2, log);
                });
              }).catch((error) => {
                this.emit("error", error);
                event._inflight = false;
              });
              runners.push(runner);
            }
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error) => {
        this.emit("error", error);
      });
      return;
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter11(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now2 = getTime();
    if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now2;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter11(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter11(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;
        const alreadyDone = function() {
          if (done) {
            return true;
          }
          done = true;
          cancelFuncs.forEach((func2) => {
            func2();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter11(this, void 0, void 0, function* () {
            if (done) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter11(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error) => {
              if (done) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer3 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer3.unref) {
            timer3.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer3);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter11(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p6) => hexValue(p6))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout2) => __awaiter11(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t3) => hexlify(t3));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v5) => v5 ? this._getAddress(v5) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v5) => v5 ? BigNumber.from(v5) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v5) => v5 != null ? v5 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v5) => v5 ? hexlify(v5) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter11(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  _call(transaction, blockTag, attempt) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger30.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }
      const txSender = transaction.to;
      const result = yield this.perform("call", { transaction, blockTag });
      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
        try {
          const data3 = hexDataSlice(result, 4);
          const sender = hexDataSlice(data3, 0, 32);
          if (!BigNumber.from(sender).eq(txSender)) {
            logger30.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const urls = [];
          const urlsOffset = BigNumber.from(hexDataSlice(data3, 32, 64)).toNumber();
          const urlsLength = BigNumber.from(hexDataSlice(data3, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = hexDataSlice(data3, urlsOffset + 32);
          for (let u5 = 0; u5 < urlsLength; u5++) {
            const url = _parseString(urlsData, u5 * 32);
            if (url == null) {
              logger30.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            urls.push(url);
          }
          const calldata = _parseBytes(data3, 64);
          if (!BigNumber.from(hexDataSlice(data3, 100, 128)).isZero()) {
            logger30.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const callbackSelector = hexDataSlice(data3, 96, 100);
          const extraData = _parseBytes(data3, 128);
          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
          if (ccipResult == null) {
            logger30.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }
          const tx = {
            to: txSender,
            data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }
      try {
        return hexlify(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction, blockTag },
          result,
          error
        });
      }
    });
  }
  call(transaction, blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(transaction) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error) {
        return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter11(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger30.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter11(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i4 = 0; i4 < block.transactions.length; i4++) {
            const tx = block.transactions[i4];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter11(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter11(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log) => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter11(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter11(this, void 0, void 0, function* () {
      let currentName = name2;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name2 !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = yield this._getResolver(currentName, "getResolver");
        if (addr != null) {
          const resolver = new Resolver(this, addr, name2);
          if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(name2, operation) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
      }
      try {
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + namehash(name2).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {
      }
      return null;
    });
  }
  resolveName(name2) {
    return __awaiter11(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error) {
        if (isHexString(name2)) {
          throw error;
        }
      }
      if (typeof name2 !== "string") {
        logger30.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter11(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");
      if (resolverAddr == null) {
        return null;
      }
      const name2 = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + namehash(node).substring(2)
      }), 0);
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter11(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, node);
        try {
          const avatar2 = yield resolver.getAvatar();
          if (avatar2) {
            return avatar2.url;
          }
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        }
        try {
          const name2 = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + namehash(node).substring(2)
          }), 0);
          resolver = yield this.getResolver(name2);
        } catch (error) {
          if (error.code !== Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
          return null;
        }
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method, params) {
    return logger30.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e3) => e3.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e3) => e3.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once) {
    const event = new Event2(getEventTag2(eventName), listener, once);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag2(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag2(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
var __awaiter12 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger31 = new Logger(version24);
var errorGas = ["call", "estimateGas"];
function spelunk(value, requireData) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match("reverted")) {
    const data3 = isHexString(value.data) ? value.data : null;
    if (!requireData || data3) {
      return { message: value.message, data: data3 };
    }
  }
  if (typeof value === "object") {
    for (const key2 in value) {
      const result = spelunk(value[key2], requireData);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value), requireData);
    } catch (error) {
    }
  }
  return null;
}
function checkError(method, error, params) {
  const transaction = params.transaction || params.signedTransaction;
  if (method === "call") {
    const result = spelunk(error, true);
    if (result) {
      return result.data;
    }
    logger31.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction,
      error
    });
  }
  if (method === "estimateGas") {
    let result = spelunk(error.body, false);
    if (result == null) {
      result = spelunk(error, false);
    }
    if (result) {
      logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        reason: result.message,
        method,
        transaction,
        error
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
    logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/nonce (is )?too low/i)) {
    logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/only replay-protected/i)) {
    logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }
  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
    logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
function timer(timeout2) {
  return new Promise(function(resolve) {
    setTimeout(resolve, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
var _constructorGuard5 = {};
var JsonRpcSigner = class extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    super();
    if (constructorGuard !== _constructorGuard5) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter12(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger31.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error) => {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
            action: "sendTransaction",
            transaction: tx
          });
        }
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter12(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter12(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error) {
        error.transactionHash = hash3;
        throw error;
      }
    });
  }
  signMessage(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const data3 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [hexlify(data3), address.toLowerCase()]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "signMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _legacySignMessage(message) {
    return __awaiter12(this, void 0, void 0, function* () {
      const data3 = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data3)]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_legacySignMessage",
            from: address,
            messageData: message
          });
        }
        throw error;
      }
    });
  }
  _signTypedData(domain, types, value) {
    return __awaiter12(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          address.toLowerCase(),
          JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
        ]);
      } catch (error) {
        if (typeof error.message === "string" && error.message.match(/user denied/i)) {
          logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
            action: "_signTypedData",
            from: address,
            messageData: { domain: populated.domain, types, value: populated.value }
          });
        }
        throw error;
      }
    });
  }
  unlock(password) {
    return __awaiter12(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
};
var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
};
var allowedTransactionKeys4 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
var JsonRpcProvider2 = class extends BaseProvider {
  constructor(url, network) {
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve(network2);
          }, (error) => {
            reject(error);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url) {
      url = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter12(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error2) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }
      return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a4) => this.formatter.address(a4));
    });
  }
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
      default:
        break;
    }
    return null;
  }
  perform(method, params) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method, params);
      if (args == null) {
        logger31.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes2) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes2.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys4);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value = hexValue(BigNumber.from(transaction[key2]));
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ws.js
var WS2 = null;
try {
  WS2 = WebSocket;
  if (WS2 == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger47 = new Logger(version24);
  WS2 = function() {
    logger47.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
}

// node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
var __awaiter13 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger32 = new Logger(version24);
var NextId = 1;
var WebSocketProvider = class extends JsonRpcProvider2 {
  constructor(url, network) {
    if (network === "any") {
      logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }
    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }
    this._pollingInterval = -1;
    this._wsReady = false;
    if (typeof url === "string") {
      defineReadOnly(this, "_websocket", new WS2(this.connection.url));
    } else {
      defineReadOnly(this, "_websocket", url);
    }
    defineReadOnly(this, "_requests", {});
    defineReadOnly(this, "_subs", {});
    defineReadOnly(this, "_subIds", {});
    defineReadOnly(this, "_detectNetwork", super.detectNetwork());
    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach((id2) => {
        this.websocket.send(this._requests[id2].payload);
      });
    };
    this.websocket.onmessage = (messageEvent) => {
      const data3 = messageEvent.data;
      const result = JSON.parse(data3);
      if (result.id != null) {
        const id2 = String(result.id);
        const request = this._requests[id2];
        delete this._requests[id2];
        if (result.result !== void 0) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;
          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data3);
          } else {
            error = new Error("unknown error");
          }
          request.callback(error, void 0);
          this.emit("debug", {
            action: "response",
            error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        const sub = this._subs[result.params.subscription];
        if (sub) {
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    };
    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1e3);
    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  }
  // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.
  get websocket() {
    return this._websocket;
  }
  detectNetwork() {
    return this._detectNetwork;
  }
  get pollingInterval() {
    return 0;
  }
  resetEventsBlock(blockNumber) {
    logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }
  set pollingInterval(value) {
    logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }
  poll() {
    return __awaiter13(this, void 0, void 0, function* () {
      return null;
    });
  }
  set polling(value) {
    if (!value) {
      return;
    }
    logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }
  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }
        return resolve(result);
      }
      const payload = JSON.stringify({
        method,
        params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = { callback, payload };
      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }
  static defaultUrl() {
    return "ws://localhost:8546";
  }
  _subscribe(tag, param, processFunc) {
    return __awaiter13(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];
      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then((param2) => {
          return this.send("eth_subscribe", param2);
        });
        this._subIds[tag] = subIdPromise;
      }
      const subId = yield subIdPromise;
      this._subs[subId] = { tag, processFunc };
    });
  }
  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], (result) => {
          const blockNumber = BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });
        break;
      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], (result) => {
          this.emit("pending", result);
        });
        break;
      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
          if (result.removed == null) {
            result.removed = false;
          }
          this.emit(event.filter, this.formatter.filterLog(result));
        });
        break;
      case "tx": {
        const emitReceipt = (event2) => {
          const hash3 = event2.hash;
          this.getTransactionReceipt(hash3).then((receipt) => {
            if (!receipt) {
              return;
            }
            this.emit(hash3, receipt);
          });
        };
        emitReceipt(event);
        this._subscribe("tx", ["newHeads"], (result) => {
          this._events.filter((e3) => e3.type === "tx").forEach(emitReceipt);
        });
        break;
      }
      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;
      default:
        console.log("unhandled:", event);
        break;
    }
  }
  _stopEvent(event) {
    let tag = event.tag;
    if (event.type === "tx") {
      if (this._events.filter((e3) => e3.type === "tx").length) {
        return;
      }
      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      return;
    }
    const subId = this._subIds[tag];
    if (!subId) {
      return;
    }
    delete this._subIds[tag];
    subId.then((subId2) => {
      if (!this._subs[subId2]) {
        return;
      }
      delete this._subs[subId2];
      this.send("eth_unsubscribe", [subId2]);
    });
  }
  destroy() {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this.websocket.readyState === WS2.CONNECTING) {
        yield new Promise((resolve) => {
          this.websocket.onopen = function() {
            resolve(true);
          };
          this.websocket.onerror = function() {
            resolve(false);
          };
        });
      }
      this.websocket.close(1e3);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
var __awaiter14 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger33 = new Logger(version24);
var StaticJsonRpcProvider = class extends JsonRpcProvider2 {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter14(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          defineReadOnly(this, "_network", network);
          this.emit("network", network, null);
        }
      }
      return network;
    });
  }
};
var UrlJsonRpcProvider = class _UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger33.checkAbstract(new.target, _UrlJsonRpcProvider);
    network = getStatic(new.target, "getNetwork")(network);
    apiKey = getStatic(new.target, "getApiKey")(apiKey);
    const connection = getStatic(new.target, "getUrl")(network, apiKey);
    super(connection, network);
    if (typeof apiKey === "string") {
      defineReadOnly(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach((key2) => {
        defineReadOnly(this, key2, apiKey[key2]);
      });
    }
  }
  _startPending() {
    logger33.warn("WARNING: API provider does not support pending filters");
  }
  isCommunityResource() {
    return false;
  }
  getSigner(address) {
    return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
  }
  listAccounts() {
    return Promise.resolve([]);
  }
  // Return a defaultApiKey if null, otherwise validate the API key
  static getApiKey(apiKey) {
    return apiKey;
  }
  // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.
  static getUrl(network, apiKey) {
    return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
var logger34 = new Logger(version24);
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
var AlchemyWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    defineReadOnly(this, "apiKey", provider.apiKey);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};
var AlchemyProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }
    if (apiKey && typeof apiKey !== "string") {
      logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;
      case "goerli":
        host = "eth-goerli.g.alchemy.com/v2/";
        break;
      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;
      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;
      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;
      case "arbitrum-goerli":
        host = "arb-goerli.g.alchemy.com/v2/";
        break;
      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;
      case "optimism-goerli":
        host = "opt-goerli.g.alchemy.com/v2/";
        break;
      default:
        logger34.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return {
      allowGzip: true,
      url: "https://" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
var logger35 = new Logger(version24);
var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name2) {
  switch (name2) {
    case "homestead":
      return "rpc.ankr.com/eth/";
    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";
    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";
    case "goerli":
      return "rpc.ankr.com/eth_goerli/";
    case "matic":
      return "rpc.ankr.com/polygon/";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }
  return logger35.throwArgumentError("unsupported network", "name", name2);
}
var AnkrProvider = class extends UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey2;
    }
    return apiKey;
  }
  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const connection = {
      allowGzip: true,
      url: "https://" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey2) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
};

// node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
var __awaiter15 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger36 = new Logger(version24);
var CloudflareProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger36.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }
    return null;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;
      default:
        logger36.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host;
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter15(this, void 0, void 0, function* () {
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
        return block.number;
      }
      return _super.perform.call(this, method, params);
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
var __awaiter16 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger37 = new Logger(version24);
function getTransactionPostData(transaction) {
  const result = {};
  for (let key2 in transaction) {
    if (transaction[key2] == null) {
      continue;
    }
    let value = transaction[key2];
    if (key2 === "type" && value === 0) {
      continue;
    }
    if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
      value = hexValue(hexlify(value));
    } else if (key2 === "accessList") {
      value = "[" + accessListify(value).map((set3) => {
        return `{address:"${set3.address}",storageKeys:["${set3.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }
    result[key2] = value;
  }
  return result;
}
function getResult2(result) {
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }
  if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }
    throw error;
  }
  return result.result;
}
function getJsonResult(result) {
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }
  if (result.jsonrpc != "2.0") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }
  if (result.error) {
    const error = new Error(result.error.message || "unknown error");
    if (result.error.code) {
      error.code = result.error.code;
    }
    if (result.error.data) {
      error.data = result.error.data;
    }
    throw error;
  }
  return result.result;
}
function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }
  if (blockTag === "latest") {
    return blockTag;
  }
  return parseInt(blockTag.substring(2), 16);
}
function checkError2(method, error, transaction) {
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    const e3 = error.error;
    if (e3 && (e3.message.match(/reverted/i) || e3.message.match(/VM execution error/i))) {
      let data3 = e3.data;
      if (data3) {
        data3 = "0x" + data3.replace(/^.*0x/i, "");
      }
      if (isHexString(data3)) {
        return data3;
      }
      logger37.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  }
  let message = error.message;
  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }
  message = (message || "").toLowerCase();
  if (message.match(/insufficient funds/)) {
    logger37.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger37.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/another transaction with same nonce/)) {
    logger37.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }
  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger37.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }
  throw error;
}
var EtherscanProvider = class extends BaseProvider {
  constructor(network, apiKey) {
    super(network);
    defineReadOnly(this, "baseUrl", this.getBaseUrl());
    defineReadOnly(this, "apiKey", apiKey || null);
  }
  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "maticmum":
        return "https://api-testnet.polygonscan.com";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      default:
    }
    return logger37.throwArgumentError("unsupported network", "network", this.network.name);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key2) => {
      const value = params[key2];
      if (value != null) {
        accum += `&${key2}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.baseUrl}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  fetch(module, params, post) {
    return __awaiter16(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult2;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url,
        throttleSlotInterval: 1e3,
        throttleCallback: (attempt, url2) => {
          if (this.isCommunityResource()) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      let payloadStr = null;
      if (payload) {
        connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
        payloadStr = Object.keys(payload).map((key2) => {
          return `${key2}=${payload[key2]}`;
        }).join("&");
      }
      const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: deepCopy(result),
        provider: this
      });
      return result;
    });
  }
  detectNetwork() {
    return __awaiter16(this, void 0, void 0, function* () {
      return this.network;
    });
  }
  perform(method, params) {
    const _super = Object.create(null, {
      perform: { get: () => super.perform }
    });
    return __awaiter16(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", { action: "eth_blockNumber" });
        case "getGasPrice":
          return this.fetch("proxy", { action: "eth_gasPrice" });
        case "getBalance":
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });
        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });
        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });
        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });
        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch((error) => {
            return checkError2("sendTransaction", error, params.signedTransaction);
          });
        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }
          throw new Error("getBlock by blockHash not implemented");
        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });
        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });
        case "call": {
          if (params.blockTag !== "latest") {
            throw new Error("EtherscanProvider does not support blockTag for call");
          }
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_call";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("call", error, params.transaction);
          }
        }
        case "estimateGas": {
          const postData = getTransactionPostData(params.transaction);
          postData.module = "proxy";
          postData.action = "eth_estimateGas";
          try {
            return yield this.fetch("proxy", postData, true);
          } catch (error) {
            return checkError2("estimateGas", error, params.transaction);
          }
        }
        case "getLogs": {
          const args = { action: "getLogs" };
          if (params.filter.fromBlock) {
            args.fromBlock = checkLogTag(params.filter.fromBlock);
          }
          if (params.filter.toBlock) {
            args.toBlock = checkLogTag(params.filter.toBlock);
          }
          if (params.filter.address) {
            args.address = params.filter.address;
          }
          if (params.filter.topics && params.filter.topics.length > 0) {
            if (params.filter.topics.length > 1) {
              logger37.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
            }
            if (params.filter.topics.length === 1) {
              const topic0 = params.filter.topics[0];
              if (typeof topic0 !== "string" || topic0.length !== 66) {
                logger37.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
              }
              args.topic0 = topic0;
            }
          }
          const logs = yield this.fetch("logs", args);
          let blocks = {};
          for (let i4 = 0; i4 < logs.length; i4++) {
            const log = logs[i4];
            if (log.blockHash != null) {
              continue;
            }
            if (blocks[log.blockNumber] == null) {
              const block = yield this.getBlock(log.blockNumber);
              if (block) {
                blocks[log.blockNumber] = block.hash;
              }
            }
            log.blockHash = blocks[log.blockNumber];
          }
          return logs;
        }
        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0;
          }
          return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
        default:
          break;
      }
      return _super.perform.call(this, method, params);
    });
  }
  // Note: The `page` page parameter only allows pagination within the
  //       10,000 window available without a page and offset parameter
  //       Error: Result window is too large, PageNo x Offset size must
  //              be less than or equal to 10000
  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter16(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map((tx) => {
        ["contractAddress", "to"].forEach(function(key2) {
          if (tx[key2] == "") {
            delete tx[key2];
          }
        });
        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }
        const item = this.formatter.transactionResponse(tx);
        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }
        return item;
      });
    });
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
};

// node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
var __awaiter17 = function(thisArg, _arguments, P4, generator) {
  function adopt(value) {
    return value instanceof P4 ? value : new P4(function(resolve) {
      resolve(value);
    });
  }
  return new (P4 || (P4 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var logger38 = new Logger(version24);
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function checkNetworks(networks2) {
  let result = null;
  for (let i4 = 0; i4 < networks2.length; i4++) {
    const network = networks2[i4];
    if (network == null) {
      return null;
    }
    if (result) {
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger38.throwArgumentError("provider mismatch", "networks", networks2);
      }
    } else {
      result = network;
    }
  }
  return result;
}
function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[middle];
  }
  const a4 = values[middle - 1], b6 = values[middle];
  if (maxDelta != null && Math.abs(a4 - b6) > maxDelta) {
    return null;
  }
  return (a4 + b6) / 2;
}
function serialize2(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map((i4) => serialize2(i4)));
  } else if (typeof value === "object") {
    const keys2 = Object.keys(value);
    keys2.sort();
    return "{" + keys2.map((key2) => {
      let v5 = value[key2];
      if (typeof v5 === "function") {
        v5 = "[function]";
      } else {
        v5 = serialize2(v5);
      }
      return JSON.stringify(key2) + ":" + v5;
    }).join(",") + "}";
  }
  throw new Error("unknown value type: " + typeof value);
}
var nextRid = 1;
function stall2(duration) {
  let cancel = null;
  let timer3 = null;
  let promise = new Promise((resolve) => {
    cancel = function() {
      if (timer3) {
        clearTimeout(timer3);
        timer3 = null;
      }
      resolve();
    };
    timer3 = setTimeout(cancel, duration);
  });
  const wait = (func2) => {
    promise = promise.then(func2);
    return promise;
  };
  function getPromise() {
    return promise;
  }
  return { cancel, getPromise, wait };
}
var ForwardErrors = [
  Logger.errors.CALL_EXCEPTION,
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED,
  Logger.errors.UNPREDICTABLE_GAS_LIMIT
];
var ForwardProperties = [
  "address",
  "args",
  "errorArgs",
  "errorSignature",
  "method",
  "transaction"
];
function exposeDebugConfig(config2, now2) {
  const result = {
    weight: config2.weight
  };
  Object.defineProperty(result, "provider", { get: () => config2.provider });
  if (config2.start) {
    result.start = config2.start;
  }
  if (now2) {
    result.duration = now2 - config2.start;
  }
  if (config2.done) {
    if (config2.error) {
      result.error = config2.error;
    } else {
      result.result = config2.result || null;
    }
  }
  return result;
}
function normalizedTally(normalize2, quorum) {
  return function(configs) {
    const tally = {};
    configs.forEach((c5) => {
      const value = normalize2(c5.result);
      if (!tally[value]) {
        tally[value] = { count: 0, result: c5.result };
      }
      tally[value].count++;
    });
    const keys2 = Object.keys(tally);
    for (let i4 = 0; i4 < keys2.length; i4++) {
      const check = tally[keys2[i4]];
      if (check.count >= quorum) {
        return check.result;
      }
    }
    return void 0;
  };
}
function getProcessFunc(provider, method, params) {
  let normalize2 = serialize2;
  switch (method) {
    case "getBlockNumber":
      return function(configs) {
        const values = configs.map((c5) => c5.result);
        let blockNumber = median(configs.map((c5) => c5.result), 2);
        if (blockNumber == null) {
          return void 0;
        }
        blockNumber = Math.ceil(blockNumber);
        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        }
        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }
        return provider._highestBlockNumber;
      };
    case "getGasPrice":
      return function(configs) {
        const values = configs.map((c5) => c5.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };
    case "getEtherPrice":
      return function(configs) {
        return median(configs.map((c5) => c5.result));
      };
    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    case "getTransaction":
    case "getTransactionReceipt":
      normalize2 = function(tx) {
        if (tx == null) {
          return null;
        }
        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize2(tx);
      };
      break;
    case "getBlock":
      if (params.includeTransactions) {
        normalize2 = function(block) {
          if (block == null) {
            return null;
          }
          block = shallowCopy(block);
          block.transactions = block.transactions.map((tx) => {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize2(block);
        };
      } else {
        normalize2 = function(block) {
          if (block == null) {
            return null;
          }
          return serialize2(block);
        };
      }
      break;
    default:
      throw new Error("unknown method: " + method);
  }
  return normalizedTally(normalize2, provider.quorum);
}
function waitForSync(config2, blockNumber) {
  return __awaiter17(this, void 0, void 0, function* () {
    const provider = config2.provider;
    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }
    return poll(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function() {
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          }
          if (config2.cancelled) {
            return resolve(null);
          }
          return resolve(void 0);
        }, 0);
      });
    }, { oncePoll: provider });
  });
}
function getRunner(config2, currentBlockNumber, method, params) {
  return __awaiter17(this, void 0, void 0, function* () {
    let provider = config2.provider;
    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();
      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }
        break;
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[method](params.address, params.blockTag || "latest");
      case "getStorageAt":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
      case "getBlock":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
      case "call":
      case "estimateGas":
        if (params.blockTag && isHexString(params.blockTag)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        if (method === "call" && params.blockTag) {
          return provider[method](params.transaction, params.blockTag);
        }
        return provider[method](params.transaction);
      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);
      case "getLogs": {
        let filter2 = params.filter;
        if (filter2.fromBlock && isHexString(filter2.fromBlock) || filter2.toBlock && isHexString(filter2.toBlock)) {
          provider = yield waitForSync(config2, currentBlockNumber);
        }
        return provider.getLogs(filter2);
      }
    }
    return logger38.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
      method,
      params
    });
  });
}
var FallbackProvider = class extends BaseProvider {
  constructor(providers, quorum) {
    if (providers.length === 0) {
      logger38.throwArgumentError("missing providers", "providers", providers);
    }
    const providerConfigs = providers.map((configOrProvider, index) => {
      if (Provider.isProvider(configOrProvider)) {
        const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        const priority = 1;
        return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
      }
      const config2 = shallowCopy(configOrProvider);
      if (config2.priority == null) {
        config2.priority = 1;
      }
      if (config2.stallTimeout == null) {
        config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
      }
      if (config2.weight == null) {
        config2.weight = 1;
      }
      const weight = config2.weight;
      if (weight % 1 || weight > 512 || weight < 1) {
        logger38.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }
      return Object.freeze(config2);
    });
    const total = providerConfigs.reduce((accum, c5) => accum + c5.weight, 0);
    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger38.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    }
    let networkOrReady = checkNetworks(providerConfigs.map((c5) => c5.provider.network));
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }
    super(networkOrReady);
    defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }
  detectNetwork() {
    return __awaiter17(this, void 0, void 0, function* () {
      const networks2 = yield Promise.all(this.providerConfigs.map((c5) => c5.provider.getNetwork()));
      return checkNetworks(networks2);
    });
  }
  perform(method, params) {
    return __awaiter17(this, void 0, void 0, function* () {
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map((c5) => {
          return c5.provider.sendTransaction(params.signedTransaction).then((result) => {
            return result.hash;
          }, (error) => {
            return error;
          });
        }));
        for (let i5 = 0; i5 < results.length; i5++) {
          const result = results[i5];
          if (typeof result === "string") {
            return result;
          }
        }
        throw results[0];
      }
      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }
      const processFunc = getProcessFunc(this, method, params);
      const configs = shuffled(this.providerConfigs.map(shallowCopy));
      configs.sort((a4, b6) => a4.priority - b6.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i4 = 0;
      let first2 = true;
      while (true) {
        const t0 = now();
        let inflightWeight = configs.filter((c5) => c5.runner && t0 - c5.start < c5.stallTimeout).reduce((accum, c5) => accum + c5.weight, 0);
        while (inflightWeight < this.quorum && i4 < configs.length) {
          const config2 = configs[i4++];
          const rid = nextRid++;
          config2.start = now();
          config2.staller = stall2(config2.stallTimeout);
          config2.staller.wait(() => {
            config2.staller = null;
          });
          config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
            config2.done = true;
            config2.result = result;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          }, (error) => {
            config2.done = true;
            config2.error = error;
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, now()),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
          });
          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid,
              backend: exposeDebugConfig(config2, null),
              request: { method, params: deepCopy(params) },
              provider: this
            });
          }
          inflightWeight += config2.weight;
        }
        const waiting = [];
        configs.forEach((c5) => {
          if (c5.done || !c5.runner) {
            return;
          }
          waiting.push(c5.runner);
          if (c5.staller) {
            waiting.push(c5.staller.getPromise());
          }
        });
        if (waiting.length) {
          yield Promise.race(waiting);
        }
        const results = configs.filter((c5) => c5.done && c5.error == null);
        if (results.length >= this.quorum) {
          const result = processFunc(results);
          if (result !== void 0) {
            configs.forEach((c5) => {
              if (c5.staller) {
                c5.staller.cancel();
              }
              c5.cancelled = true;
            });
            return result;
          }
          if (!first2) {
            yield stall2(100).getPromise();
          }
          first2 = false;
        }
        const errors = configs.reduce((accum, c5) => {
          if (!c5.done || c5.error == null) {
            return accum;
          }
          const code2 = c5.error.code;
          if (ForwardErrors.indexOf(code2) >= 0) {
            if (!accum[code2]) {
              accum[code2] = { error: c5.error, weight: 0 };
            }
            accum[code2].weight += c5.weight;
          }
          return accum;
        }, {});
        Object.keys(errors).forEach((errorCode) => {
          const tally = errors[errorCode];
          if (tally.weight < this.quorum) {
            return;
          }
          configs.forEach((c5) => {
            if (c5.staller) {
              c5.staller.cancel();
            }
            c5.cancelled = true;
          });
          const e3 = tally.error;
          const props = {};
          ForwardProperties.forEach((name2) => {
            if (e3[name2] == null) {
              return;
            }
            props[name2] = e3[name2];
          });
          logger38.throwError(e3.reason || e3.message, errorCode, props);
        });
        if (configs.filter((c5) => !c5.done).length === 0) {
          break;
        }
      }
      configs.forEach((c5) => {
        if (c5.staller) {
          c5.staller.cancel();
        }
        c5.cancelled = true;
      });
      return logger38.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
        method,
        params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map((c5) => exposeDebugConfig(c5)),
        provider: this
      });
    });
  }
};

// node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
var IpcProvider = null;

// node_modules/@ethersproject/providers/lib.esm/infura-provider.js
var logger39 = new Logger(version24);
var defaultProjectId = "84842078b09946638c03157f83405213";
var InfuraWebSocketProvider = class extends WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;
    if (connection.password) {
      logger39.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }
    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    defineReadOnly(this, "apiKey", provider.projectId);
    defineReadOnly(this, "projectId", provider.projectId);
    defineReadOnly(this, "projectSecret", provider.projectSecret);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};
var InfuraProvider = class extends UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }
  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };
    if (apiKey == null) {
      return apiKeyObj;
    }
    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger39.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger39.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }
    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;
      case "goerli":
        host = "goerli.infura.io";
        break;
      case "sepolia":
        host = "sepolia.infura.io";
        break;
      case "matic":
        host = "polygon-mainnet.infura.io";
        break;
      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;
      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;
      case "optimism-goerli":
        host = "optimism-goerli.infura.io";
        break;
      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;
      case "arbitrum-goerli":
        host = "arbitrum-goerli.infura.io";
        break;
      default:
        logger39.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const connection = {
      allowGzip: true,
      url: "https://" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          showThrottleMessage();
        }
        return Promise.resolve(true);
      }
    };
    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }
    return connection;
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
var JsonRpcBatchProvider = class extends JsonRpcProvider2 {
  send(method, params) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }
    const inflightRequest = { request, resolve: null, reject: null };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });
    this._pendingBatch.push(inflightRequest);
    if (!this._pendingBatchAggregator) {
      this._pendingBatchAggregator = setTimeout(() => {
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null;
        const request2 = batch.map((inflight) => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: deepCopy(request2),
          provider: this
        });
        return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
          this.emit("debug", {
            action: "response",
            request: request2,
            response: result,
            provider: this
          });
          batch.forEach((inflightRequest2, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest2.reject(error);
            } else {
              inflightRequest2.resolve(payload.result);
            }
          });
        }, (error) => {
          this.emit("debug", {
            action: "response",
            error,
            request: request2,
            provider: this
          });
          batch.forEach((inflightRequest2) => {
            inflightRequest2.reject(error);
          });
        });
      }, 10);
    }
    return promise;
  }
};

// node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
var logger40 = new Logger(version24);
var defaultApiKey3 = "ETHERS_JS_SHARED";
var NodesmithProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger40.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }
    return apiKey || defaultApiKey3;
  }
  static getUrl(network, apiKey) {
    logger40.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;
    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;
      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;
      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;
      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;
      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;
      default:
        logger40.throwArgumentError("unsupported network", "network", arguments[0]);
    }
    return host + "?apiKey=" + apiKey;
  }
};

// node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
var logger41 = new Logger(version24);
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
var PocketProvider = class extends UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    const apiKeyObj = {
      applicationId: null,
      loadBalancer: true,
      applicationSecretKey: null
    };
    if (apiKey == null) {
      apiKeyObj.applicationId = defaultApplicationId;
    } else if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
    } else if (apiKey.applicationId) {
      apiKeyObj.applicationId = apiKey.applicationId;
    } else {
      logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }
    return apiKeyObj;
  }
  static getUrl(network, apiKey) {
    let host = null;
    switch (network ? network.name : "unknown") {
      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;
      case "kovan":
        host = "poa-kovan.gateway.pokt.network";
        break;
      case "matic":
        host = "poly-mainnet.gateway.pokt.network";
        break;
      case "maticmum":
        host = "polygon-mumbai-rpc.gateway.pokt.network";
        break;
      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;
      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;
      default:
        logger41.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }
    const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
    const connection = { headers: {}, url };
    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }
    return connection;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
};

// node_modules/@ethersproject/providers/lib.esm/web3-provider.js
var logger42 = new Logger(version24);
var _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method, params) {
    const request = {
      method,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error2 = new Error(response.error.message);
          error2.code = response.error.code;
          error2.data = response.error.data;
          return reject(error2);
        }
        resolve(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method, params) {
    if (params == null) {
      params = [];
    }
    const request = { method, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}
var Web3Provider = class extends JsonRpcProvider2 {
  constructor(provider, network) {
    if (provider == null) {
      logger42.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger42.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider);
  }
  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }
};

// node_modules/@ethersproject/providers/lib.esm/index.js
var logger43 = new Logger(version24);
function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  }
  if (typeof network === "string") {
    const match = network.match(/^(ws|http)s?:/i);
    if (match) {
      switch (match[1].toLowerCase()) {
        case "http":
        case "https":
          return new JsonRpcProvider2(network);
        case "ws":
        case "wss":
          return new WebSocketProvider(network);
        default:
          logger43.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }
  const n3 = getNetwork(network);
  if (!n3 || !n3._defaultProvider) {
    logger43.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network
    });
  }
  return n3._defaultProvider({
    FallbackProvider,
    AlchemyProvider,
    AnkrProvider,
    CloudflareProvider,
    EtherscanProvider,
    InfuraProvider,
    JsonRpcProvider: JsonRpcProvider2,
    NodesmithProvider,
    PocketProvider,
    Web3Provider,
    IpcProvider
  }, options);
}

// node_modules/ethers/lib.esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  AbiCoder: () => AbiCoder,
  ConstructorFragment: () => ConstructorFragment,
  ErrorFragment: () => ErrorFragment,
  EventFragment: () => EventFragment,
  FormatTypes: () => FormatTypes,
  Fragment: () => Fragment,
  FunctionFragment: () => FunctionFragment,
  HDNode: () => HDNode,
  Indexed: () => Indexed,
  Interface: () => Interface,
  LogDescription: () => LogDescription,
  Logger: () => Logger,
  ParamType: () => ParamType,
  RLP: () => lib_exports,
  SigningKey: () => SigningKey,
  SupportedAlgorithm: () => SupportedAlgorithm,
  TransactionDescription: () => TransactionDescription,
  TransactionTypes: () => TransactionTypes,
  UnicodeNormalizationForm: () => UnicodeNormalizationForm,
  Utf8ErrorFuncs: () => Utf8ErrorFuncs,
  Utf8ErrorReason: () => Utf8ErrorReason,
  _TypedDataEncoder: () => TypedDataEncoder,
  _fetchData: () => _fetchData,
  _toEscapedUtf8String: () => _toEscapedUtf8String,
  accessListify: () => accessListify,
  arrayify: () => arrayify,
  base58: () => Base58,
  base64: () => lib_exports3,
  checkProperties: () => checkProperties,
  checkResultErrors: () => checkResultErrors,
  commify: () => commify,
  computeAddress: () => computeAddress,
  computeHmac: () => computeHmac,
  computePublicKey: () => computePublicKey,
  concat: () => concat2,
  deepCopy: () => deepCopy,
  defaultAbiCoder: () => defaultAbiCoder,
  defaultPath: () => defaultPath,
  defineReadOnly: () => defineReadOnly,
  dnsEncode: () => dnsEncode,
  entropyToMnemonic: () => entropyToMnemonic,
  fetchJson: () => fetchJson,
  formatBytes32String: () => formatBytes32String,
  formatEther: () => formatEther,
  formatUnits: () => formatUnits,
  getAccountPath: () => getAccountPath,
  getAddress: () => getAddress,
  getContractAddress: () => getContractAddress,
  getCreate2Address: () => getCreate2Address,
  getIcapAddress: () => getIcapAddress,
  getJsonWalletAddress: () => getJsonWalletAddress,
  getStatic: () => getStatic,
  hashMessage: () => hashMessage,
  hexConcat: () => hexConcat,
  hexDataLength: () => hexDataLength,
  hexDataSlice: () => hexDataSlice,
  hexStripZeros: () => hexStripZeros,
  hexValue: () => hexValue,
  hexZeroPad: () => hexZeroPad,
  hexlify: () => hexlify,
  id: () => id,
  isAddress: () => isAddress,
  isBytes: () => isBytes,
  isBytesLike: () => isBytesLike,
  isHexString: () => isHexString,
  isValidMnemonic: () => isValidMnemonic,
  isValidName: () => isValidName,
  joinSignature: () => joinSignature,
  keccak256: () => keccak256,
  mnemonicToEntropy: () => mnemonicToEntropy,
  mnemonicToSeed: () => mnemonicToSeed,
  namehash: () => namehash,
  nameprep: () => nameprep,
  parseBytes32String: () => parseBytes32String,
  parseEther: () => parseEther,
  parseTransaction: () => parse2,
  parseUnits: () => parseUnits,
  poll: () => poll,
  randomBytes: () => randomBytes2,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  resolveProperties: () => resolveProperties,
  ripemd160: () => ripemd160,
  serializeTransaction: () => serialize,
  sha256: () => sha2562,
  sha512: () => sha5122,
  shallowCopy: () => shallowCopy,
  shuffled: () => shuffled,
  solidityKeccak256: () => keccak2562,
  solidityPack: () => pack2,
  soliditySha256: () => sha2563,
  splitSignature: () => splitSignature,
  stripZeros: () => stripZeros,
  toUtf8Bytes: () => toUtf8Bytes,
  toUtf8CodePoints: () => toUtf8CodePoints,
  toUtf8String: () => toUtf8String,
  verifyMessage: () => verifyMessage,
  verifyTypedData: () => verifyTypedData,
  zeroPad: () => zeroPad
});

// node_modules/@ethersproject/solidity/lib.esm/_version.js
var version25 = "solidity/5.7.0";

// node_modules/@ethersproject/solidity/lib.esm/index.js
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
var Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
var logger44 = new Logger(version25);
function _pack(type2, value, isArray2) {
  switch (type2) {
    case "address":
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return arrayify(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value, 32);
      }
      return arrayify(value);
  }
  let match = type2.match(regexNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    if (match[2] && String(size2) !== match[2] || size2 % 8 !== 0 || size2 === 0 || size2 > 256) {
      logger44.throwArgumentError("invalid number type", "type", type2);
    }
    if (isArray2) {
      size2 = 256;
    }
    value = BigNumber.from(value).toTwos(size2);
    return zeroPad(value, size2 / 8);
  }
  match = type2.match(regexBytes);
  if (match) {
    const size2 = parseInt(match[1]);
    if (String(size2) !== match[1] || size2 === 0 || size2 > 32) {
      logger44.throwArgumentError("invalid bytes type", "type", type2);
    }
    if (arrayify(value).byteLength !== size2) {
      logger44.throwArgumentError(`invalid value for ${type2}`, "value", value);
    }
    if (isArray2) {
      return arrayify((value + Zeros2).substring(0, 66));
    }
    return value;
  }
  match = type2.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value.length));
    if (count2 != value.length) {
      logger44.throwArgumentError(`invalid array length for ${type2}`, "value", value);
    }
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return concat2(result);
  }
  return logger44.throwArgumentError("invalid type", "type", type2);
}
function pack2(types, values) {
  if (types.length != values.length) {
    logger44.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types.forEach(function(type2, index) {
    tight.push(_pack(type2, values[index]));
  });
  return hexlify(concat2(tight));
}
function keccak2562(types, values) {
  return keccak256(pack2(types, values));
}
function sha2563(types, values) {
  return sha2562(pack2(types, values));
}

// node_modules/@ethersproject/units/lib.esm/_version.js
var version26 = "units/5.7.0";

// node_modules/@ethersproject/units/lib.esm/index.js
var logger45 = new Logger(version26);
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value) {
  const comps = String(value).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger45.throwArgumentError("invalid value", "value", value);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return formatFixed(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger45.throwArgumentError("value must be a string", "value", value);
  }
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);
    if (index !== -1) {
      unitName = 3 * index;
    }
  }
  return parseFixed(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

// node_modules/ethers/lib.esm/_version.js
var version27 = "ethers/5.7.2";

// node_modules/ethers/lib.esm/ethers.js
var logger46 = new Logger(version27);

// node_modules/ethers/lib.esm/index.js
try {
  const anyGlobal2 = window;
  if (anyGlobal2._ethers == null) {
    anyGlobal2._ethers = ethers_exports;
  }
} catch (error) {
}

// node_modules/@web3modal/ethers5/dist/esm/src/controllers/ProviderController.js
var state2 = proxy({
  provider: void 0,
  providerType: void 0,
  address: void 0,
  chainId: void 0,
  isConnected: false
});
var ProviderController = {
  state: state2,
  subscribeKey(key2, callback) {
    return subscribeKey(state2, key2, callback);
  },
  subscribe(callback) {
    return subscribe(state2, () => callback(state2));
  },
  setProvider(provider) {
    if (provider) {
      state2.provider = ref(provider);
    }
  },
  setProviderType(providerType) {
    state2.providerType = providerType;
  },
  setAddress(address) {
    state2.address = address;
  },
  setChainId(chainId) {
    state2.chainId = chainId;
  },
  setIsConnected(isConnected) {
    state2.isConnected = isConnected;
  },
  reset() {
    state2.provider = void 0;
    state2.address = void 0;
    state2.chainId = void 0;
    state2.providerType = void 0;
    state2.isConnected = false;
  }
};

// node_modules/@web3modal/ethers5/dist/esm/src/utils/helpers.js
function getCaipDefaultChain(chain) {
  if (!chain) {
    return void 0;
  }
  return {
    id: `${ConstantsUtil2.EIP155}:${chain.chainId}`,
    name: chain.name,
    imageId: PresetsUtil.EIP155NetworkImageIds[chain.chainId]
  };
}
function hexStringToNumber(value) {
  const string3 = value.startsWith("0x") ? value.slice(2) : value;
  const number2 = parseInt(string3, 16);
  return number2;
}
function numberToHexString(value) {
  return `0x${value.toString(16)}`;
}
async function addEthereumChain(provider, chain, id2) {
  if (id2 === "walletConnect") {
    const WalletConnectProvider = provider;
    await WalletConnectProvider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: numberToHexString(chain.chainId),
          rpcUrls: chain.rpcUrl,
          chainName: chain.name,
          nativeCurrency: {
            name: chain.currency,
            decimals: 18,
            symbol: chain.currency
          },
          blockExplorerUrls: chain.explorerUrl,
          iconUrls: [PresetsUtil.EIP155NetworkImageIds[chain.chainId]]
        }
      ]
    });
  } else {
    const providerWeb3 = provider;
    await providerWeb3.send("wallet_addEthereumChain", [
      {
        chainId: numberToHexString(chain.chainId),
        rpcUrls: chain.rpcUrl,
        chainName: chain.name,
        nativeCurrency: {
          name: chain.currency,
          decimals: 18,
          symbol: chain.currency
        },
        blockExplorerUrls: chain.explorerUrl,
        iconUrls: [PresetsUtil.EIP155NetworkImageIds[chain.chainId]]
      }
    ]);
  }
}

// node_modules/@web3modal/ethers5/dist/esm/src/utils/constants.js
var WALLET_ID = "@w3m/wallet_id";
var ERROR_CODE_UNRECOGNIZED_CHAIN_ID = 4902;
var ERROR_CODE_DEFAULT = 5e3;

// node_modules/@web3modal/ethers5/dist/esm/src/client.js
var Web3Modal = class extends Web3ModalScaffold {
  constructor(options) {
    const { ethersConfig, chains, defaultChain, tokens, chainImages, _sdkVersion, ...w3mOptions } = options;
    if (!ethersConfig) {
      throw new Error("web3modal:constructor - ethersConfig is undefined");
    }
    if (!w3mOptions.projectId) {
      throw new Error("web3modal:constructor - projectId is undefined");
    }
    const networkControllerClient = {
      switchCaipNetwork: async (caipNetwork) => {
        const chainId = HelpersUtil.caipNetworkIdToNumber(caipNetwork == null ? void 0 : caipNetwork.id);
        if (chainId) {
          await this.switchNetwork(chainId);
        }
      },
      getApprovedCaipNetworksData: async () => new Promise(async (resolve) => {
        var _a2, _b, _c, _d;
        const walletChoice = localStorage.getItem(WALLET_ID);
        if (walletChoice == null ? void 0 : walletChoice.includes(ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID)) {
          const provider = await this.getWalletConnectProvider();
          if (!provider) {
            throw new Error("networkControllerClient:getApprovedCaipNetworks - connector is undefined");
          }
          const ns3 = (_b = (_a2 = (provider == null ? void 0 : provider.provider).signer) == null ? void 0 : _a2.session) == null ? void 0 : _b.namespaces;
          const nsMethods = (_c = ns3 == null ? void 0 : ns3[ConstantsUtil2.EIP155]) == null ? void 0 : _c.methods;
          const nsChains = (_d = ns3 == null ? void 0 : ns3[ConstantsUtil2.EIP155]) == null ? void 0 : _d.chains;
          const result = {
            supportsAllNetworks: (nsMethods == null ? void 0 : nsMethods.includes(ConstantsUtil2.ADD_CHAIN_METHOD)) ?? false,
            approvedCaipNetworkIds: nsChains
          };
          resolve(result);
        } else {
          const result = {
            approvedCaipNetworkIds: void 0,
            supportsAllNetworks: true
          };
          resolve(result);
        }
      })
    };
    const connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        const connector = await this.getWalletConnectProvider();
        if (!connector) {
          throw new Error("connectionControllerClient:getWalletConnectUri - connector is undefined");
        }
        const WalletConnectProvider = connector.provider;
        WalletConnectProvider.on("display_uri", (uri) => {
          onUri(uri);
        });
        await WalletConnectProvider.connect();
        await this.setWalletConnectProvider();
      },
      connectExternal: async ({ id: id2, info, provider }) => {
        if (id2 === ConstantsUtil2.INJECTED_CONNECTOR_ID) {
          const InjectedProvider = ethersConfig.injected;
          if (!InjectedProvider) {
            throw new Error("connectionControllerClient:connectInjected - connector is undefined");
          }
          await InjectedProvider.send("eth_requestAccounts", []);
          this.setInjectedProvider(ethersConfig);
        } else if (id2 === ConstantsUtil2.EIP6963_CONNECTOR_ID && info && provider) {
          const EIP6963Provider = provider;
          const EIP6963Info = info;
          await EIP6963Provider.send("eth_requestAccounts", []);
          this.setEIP6963Provider(EIP6963Provider, EIP6963Info.name);
        } else if (id2 === ConstantsUtil2.COINBASE_CONNECTOR_ID) {
          const CoinbaseProvider = ethersConfig.coinbase;
          if (!CoinbaseProvider) {
            throw new Error("connectionControllerClient:connectCoinbase - connector is undefined");
          }
          await CoinbaseProvider.send("eth_requestAccounts", []);
          this.setCoinbaseProvider(ethersConfig);
        }
      },
      checkInstalled(ids) {
        if (!ids) {
          return Boolean(window.ethereum);
        }
        if (ethersConfig.injected) {
          if (!(window == null ? void 0 : window.ethereum)) {
            return false;
          }
        }
        return ids.some((id2) => {
          var _a2;
          return Boolean((_a2 = window.ethereum) == null ? void 0 : _a2[String(id2)]);
        });
      },
      disconnect: async () => {
        const provider = ProviderController.state.provider;
        const providerType = ProviderController.state.providerType;
        localStorage.removeItem(WALLET_ID);
        ProviderController.reset();
        if (providerType === ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID) {
          const WalletConnectProvider = provider == null ? void 0 : provider.provider;
          await WalletConnectProvider.disconnect();
        } else if (provider) {
          provider.emit("disconnect");
        }
      }
    };
    super({
      networkControllerClient,
      connectionControllerClient,
      defaultChain: getCaipDefaultChain(defaultChain),
      tokens: HelpersUtil.getCaipTokens(tokens),
      _sdkVersion: _sdkVersion ?? `html-ethers5-${ConstantsUtil2.VERSION}`,
      ...w3mOptions
    });
    this.hasSyncedConnectedAccount = false;
    this.EIP6963Providers = [];
    this.options = void 0;
    this.options = options;
    this.metadata = ethersConfig.metadata;
    this.projectId = w3mOptions.projectId;
    this.chains = chains;
    this.createProvider();
    ProviderController.subscribeKey("address", () => {
      this.syncAccount();
    });
    ProviderController.subscribeKey("chainId", () => {
      this.syncNetwork(chainImages);
    });
    this.syncRequestedNetworks(chains, chainImages);
    this.syncConnectors(ethersConfig);
    if (ethersConfig.EIP6963) {
      if (typeof window !== "undefined") {
        this.listenConnectors(ethersConfig.EIP6963);
        this.checkActive6963Provider();
      }
    }
    if (ethersConfig.injected) {
      this.checkActiveInjectedProvider(ethersConfig);
    }
    if (ethersConfig.coinbase) {
      this.checkActiveCoinbaseProvider(ethersConfig);
    }
  }
  getState() {
    const state3 = super.getState();
    return {
      ...state3,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state3.selectedNetworkId)
    };
  }
  subscribeState(callback) {
    return super.subscribeState((state3) => callback({
      ...state3,
      selectedNetworkId: HelpersUtil.caipNetworkIdToNumber(state3.selectedNetworkId)
    }));
  }
  getAddress() {
    return ProviderController.state.address;
  }
  getChainId() {
    return ProviderController.state.chainId;
  }
  getIsConnected() {
    return ProviderController.state.isConnected;
  }
  getWalletProvider() {
    return ProviderController.state.provider;
  }
  getWalletProviderType() {
    return ProviderController.state.providerType;
  }
  getSigner() {
    var _a2;
    return (_a2 = ProviderController.state.provider) == null ? void 0 : _a2.getSigner();
  }
  subscribeProvider(callback) {
    return ProviderController.subscribe(callback);
  }
  async disconnect() {
    const { provider, providerType } = ProviderController.state;
    localStorage.removeItem(WALLET_ID);
    ProviderController.reset();
    if (providerType === "injected" || providerType === "eip6963") {
      provider == null ? void 0 : provider.emit("disconnect");
    } else {
      const ethersProvider = provider == null ? void 0 : provider.provider;
      await ethersProvider.disconnect();
    }
  }
  createProvider() {
    if (!this.walletConnectProviderInitPromise && typeof window !== "undefined") {
      this.walletConnectProviderInitPromise = this.initWalletConnectProvider();
    }
    return this.walletConnectProviderInitPromise;
  }
  async initWalletConnectProvider() {
    const walletConnectProviderOptions = {
      projectId: this.projectId,
      showQrModal: false,
      rpcMap: this.chains ? this.chains.reduce((map3, chain) => {
        map3[chain.chainId] = chain.rpcUrl;
        return map3;
      }, {}) : {},
      optionalChains: this.chains ? [0, ...this.chains.map((chain) => chain.chainId)] : [0],
      metadata: {
        name: this.metadata ? this.metadata.name : "",
        description: this.metadata ? this.metadata.description : "",
        url: this.metadata ? this.metadata.url : "",
        icons: this.metadata ? this.metadata.icons : [""]
      }
    };
    this.walletConnectProvider = await v2.init(walletConnectProviderOptions);
    this.ethersWalletConnectProvider = new ethers_exports.providers.Web3Provider(this.walletConnectProvider, "any");
    await this.checkActiveWalletConnectProvider();
  }
  async getWalletConnectProvider() {
    if (!this.ethersWalletConnectProvider) {
      await this.createProvider();
    }
    return this.ethersWalletConnectProvider;
  }
  syncRequestedNetworks(chains, chainImages) {
    const requestedCaipNetworks = chains == null ? void 0 : chains.map((chain) => ({
      id: `${ConstantsUtil2.EIP155}:${chain.chainId}`,
      name: chain.name,
      imageId: PresetsUtil.EIP155NetworkImageIds[chain.chainId],
      imageUrl: chainImages == null ? void 0 : chainImages[chain.chainId]
    }));
    this.setRequestedCaipNetworks(requestedCaipNetworks ?? []);
  }
  async checkActiveWalletConnectProvider() {
    const provider = await this.getWalletConnectProvider();
    const WalletConnectProvider = provider == null ? void 0 : provider.provider;
    const walletId = localStorage.getItem(WALLET_ID);
    if (WalletConnectProvider) {
      if (walletId === ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID) {
        await this.setWalletConnectProvider();
      }
    }
  }
  checkActiveInjectedProvider(config2) {
    var _a2;
    const InjectedProvider = (_a2 = config2.injected) == null ? void 0 : _a2.provider;
    const walletId = localStorage.getItem(WALLET_ID);
    if (InjectedProvider) {
      if (walletId === ConstantsUtil2.INJECTED_CONNECTOR_ID) {
        this.setInjectedProvider(config2);
        this.watchInjected(config2);
      }
    }
  }
  checkActiveCoinbaseProvider(config2) {
    var _a2, _b;
    const CoinbaseProvider = (_a2 = config2.coinbase) == null ? void 0 : _a2.provider;
    const walletId = localStorage.getItem(WALLET_ID);
    if (CoinbaseProvider) {
      if (walletId === ConstantsUtil2.COINBASE_CONNECTOR_ID) {
        if (CoinbaseProvider._addresses && ((_b = CoinbaseProvider._addresses) == null ? void 0 : _b.length) > 0) {
          this.setCoinbaseProvider(config2);
          this.watchCoinbase(config2);
        } else {
          localStorage.removeItem(WALLET_ID);
          ProviderController.reset();
        }
      }
    }
  }
  checkActive6963Provider() {
    const currentActiveWallet = window == null ? void 0 : window.localStorage.getItem(WALLET_ID);
    if (currentActiveWallet) {
      const currentProvider = this.EIP6963Providers.find((provider) => provider.name === currentActiveWallet);
      if (currentProvider) {
        this.setEIP6963Provider(currentProvider.provider, currentProvider.name);
      }
    }
  }
  async setWalletConnectProvider() {
    window == null ? void 0 : window.localStorage.setItem(WALLET_ID, ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID);
    const provider = await this.getWalletConnectProvider();
    const WalletConnectProvider = provider == null ? void 0 : provider.provider;
    if (WalletConnectProvider) {
      ProviderController.setChainId(WalletConnectProvider.chainId);
      ProviderController.setProviderType("walletConnect");
      ProviderController.setProvider(provider);
      ProviderController.setIsConnected(true);
      ProviderController.setAddress(WalletConnectProvider.accounts[0]);
      this.watchWalletConnect();
    }
  }
  async setInjectedProvider(config2) {
    window == null ? void 0 : window.localStorage.setItem(WALLET_ID, ConstantsUtil2.INJECTED_CONNECTOR_ID);
    const InjectedProvider = config2.injected;
    if (InjectedProvider) {
      const signer = InjectedProvider.getSigner();
      const chainId = await signer.getChainId();
      const address = await signer.getAddress();
      if (address && chainId) {
        ProviderController.setChainId(chainId);
        ProviderController.setProviderType("injected");
        ProviderController.setProvider(config2.injected);
        ProviderController.setIsConnected(true);
        ProviderController.setAddress(address);
        this.watchCoinbase(config2);
      }
    }
  }
  async setEIP6963Provider(provider, name2) {
    window == null ? void 0 : window.localStorage.setItem(WALLET_ID, name2);
    if (provider) {
      const signer = provider.getSigner();
      const chainId = await signer.getChainId();
      const address = await signer.getAddress();
      if (address && chainId) {
        ProviderController.setChainId(chainId);
        ProviderController.setProviderType("eip6963");
        ProviderController.setProvider(provider);
        ProviderController.setIsConnected(true);
        ProviderController.setAddress(address);
        this.watchEIP6963(provider);
      }
    }
  }
  async setCoinbaseProvider(config2) {
    window == null ? void 0 : window.localStorage.setItem(WALLET_ID, ConstantsUtil2.COINBASE_CONNECTOR_ID);
    const CoinbaseProvider = config2.coinbase;
    if (CoinbaseProvider) {
      const signer = CoinbaseProvider.getSigner();
      const chainId = await signer.getChainId();
      const address = await signer.getAddress();
      if (address && chainId) {
        ProviderController.setChainId(chainId);
        ProviderController.setProviderType("coinbaseWallet");
        ProviderController.setProvider(config2.coinbase);
        ProviderController.setIsConnected(true);
        ProviderController.setAddress(address);
        this.watchCoinbase(config2);
      }
    }
  }
  async watchWalletConnect() {
    const provider = await this.getWalletConnectProvider();
    const WalletConnectProvider = provider == null ? void 0 : provider.provider;
    function disconnectHandler() {
      localStorage.removeItem(WALLET_ID);
      ProviderController.reset();
      WalletConnectProvider.removeListener("disconnect", disconnectHandler);
      WalletConnectProvider.removeListener("accountsChanged", accountsChangedHandler);
      WalletConnectProvider.removeListener("chainChanged", chainChangedHandler);
    }
    function chainChangedHandler(chainId) {
      if (chainId) {
        const chain = hexStringToNumber(chainId);
        ProviderController.setChainId(chain);
      }
    }
    const accountsChangedHandler = async (accounts) => {
      if (accounts.length > 0) {
        await this.setWalletConnectProvider();
      }
    };
    if (WalletConnectProvider) {
      WalletConnectProvider.on("disconnect", disconnectHandler);
      WalletConnectProvider.on("accountsChanged", accountsChangedHandler);
      WalletConnectProvider.on("chainChanged", chainChangedHandler);
    }
  }
  watchInjected(config2) {
    const provider = config2.injected;
    const InjectedProvider = provider == null ? void 0 : provider.provider;
    function disconnectHandler() {
      localStorage.removeItem(WALLET_ID);
      ProviderController.reset();
      InjectedProvider.removeListener("disconnect", disconnectHandler);
      InjectedProvider.removeListener("accountsChanged", accountsChangedHandler);
      InjectedProvider.removeListener("chainChanged", chainChangedHandler);
    }
    function accountsChangedHandler(accounts) {
      if (accounts.length === 0) {
        localStorage.removeItem(WALLET_ID);
        ProviderController.reset();
      } else {
        ProviderController.setAddress(accounts[0]);
      }
    }
    function chainChangedHandler(chainId) {
      if (chainId) {
        const chain = typeof chainId === "string" ? hexStringToNumber(chainId) : Number(chainId);
        ProviderController.setChainId(chain);
      }
    }
    if (InjectedProvider && provider) {
      provider.on("disconnect", disconnectHandler);
      InjectedProvider.on("disconnect", disconnectHandler);
      InjectedProvider.on("accountsChanged", accountsChangedHandler);
      InjectedProvider.on("chainChanged", chainChangedHandler);
    }
  }
  watchEIP6963(provider) {
    const EIP6963Provider = provider.provider;
    function disconnectHandler() {
      localStorage.removeItem(WALLET_ID);
      ProviderController.reset();
      EIP6963Provider.removeListener("disconnect", disconnectHandler);
      EIP6963Provider.removeListener("accountsChanged", accountsChangedHandler);
      EIP6963Provider.removeListener("chainChanged", chainChangedHandler);
    }
    function accountsChangedHandler(accounts) {
      if (accounts.length === 0) {
        localStorage.removeItem(WALLET_ID);
        ProviderController.reset();
      } else {
        ProviderController.setAddress(accounts[0]);
      }
    }
    function chainChangedHandler(chainId) {
      if (chainId) {
        const chain = typeof chainId === "string" ? hexStringToNumber(chainId) : Number(chainId);
        ProviderController.setChainId(chain);
      }
    }
    if (EIP6963Provider) {
      provider.on("disconnect", disconnectHandler);
      EIP6963Provider.on("disconnect", disconnectHandler);
      EIP6963Provider.on("accountsChanged", accountsChangedHandler);
      EIP6963Provider.on("chainChanged", chainChangedHandler);
    }
  }
  watchCoinbase(config2) {
    const provider = config2.coinbase;
    const CoinbaseProvider = provider == null ? void 0 : provider.provider;
    const walletId = localStorage.getItem(WALLET_ID);
    function disconnectHandler() {
      localStorage.removeItem(WALLET_ID);
      ProviderController.reset();
      CoinbaseProvider.removeListener("disconnect", disconnectHandler);
      CoinbaseProvider.removeListener("accountsChanged", accountsChangedHandler);
      CoinbaseProvider.removeListener("chainChanged", chainChangedHandler);
    }
    function accountsChangedHandler(accounts) {
      if (accounts.length === 0) {
        localStorage.removeItem(WALLET_ID);
        ProviderController.reset();
      } else {
        ProviderController.setAddress(accounts[0]);
      }
    }
    function chainChangedHandler(chainId) {
      if (chainId && walletId === ConstantsUtil2.COINBASE_CONNECTOR_ID) {
        const chain = Number(chainId);
        ProviderController.setChainId(chain);
      }
    }
    if (CoinbaseProvider && provider) {
      provider.on("disconnect", disconnectHandler);
      CoinbaseProvider.on("disconnect", disconnectHandler);
      CoinbaseProvider.on("accountsChanged", accountsChangedHandler);
      CoinbaseProvider.on("chainChanged", chainChangedHandler);
    }
  }
  async syncAccount() {
    const address = ProviderController.state.address;
    const chainId = ProviderController.state.chainId;
    const isConnected = ProviderController.state.isConnected;
    this.resetAccount();
    if (isConnected && address && chainId) {
      const caipAddress = `${ConstantsUtil2.EIP155}:${chainId}:${address}`;
      this.setIsConnected(isConnected);
      this.setCaipAddress(caipAddress);
      await Promise.all([
        this.syncProfile(address),
        this.syncBalance(address),
        this.getApprovedCaipNetworksData()
      ]);
      this.hasSyncedConnectedAccount = true;
    } else if (!isConnected && this.hasSyncedConnectedAccount) {
      this.resetWcConnection();
      this.resetNetwork();
    }
  }
  async syncNetwork(chainImages) {
    const address = ProviderController.state.address;
    const chainId = ProviderController.state.chainId;
    const isConnected = ProviderController.state.isConnected;
    if (this.chains) {
      const chain = this.chains.find((c5) => c5.chainId === chainId);
      if (chain) {
        const caipChainId = `${ConstantsUtil2.EIP155}:${chain.chainId}`;
        this.setCaipNetwork({
          id: caipChainId,
          name: chain.name,
          imageId: PresetsUtil.EIP155NetworkImageIds[chain.chainId],
          imageUrl: chainImages == null ? void 0 : chainImages[chain.chainId]
        });
        if (isConnected && address) {
          const caipAddress = `${ConstantsUtil2.EIP155}:${chainId}:${address}`;
          this.setCaipAddress(caipAddress);
          if (chain.explorerUrl) {
            const url = `${chain.explorerUrl}/address/${address}`;
            this.setAddressExplorerUrl(url);
          } else {
            this.setAddressExplorerUrl(void 0);
          }
          if (this.hasSyncedConnectedAccount) {
            await this.syncBalance(address);
          }
        }
      }
    }
  }
  async syncProfile(address) {
    const ensProvider = new ethers_exports.providers.InfuraProvider("mainnet");
    const name2 = await ensProvider.lookupAddress(address);
    const avatar = await ensProvider.getAvatar(address);
    if (name2) {
      this.setProfileName(name2);
    }
    if (avatar) {
      this.setProfileImage(avatar);
    }
  }
  async syncBalance(address) {
    const chainId = ProviderController.state.chainId;
    if (chainId && this.chains) {
      const chain = this.chains.find((c5) => c5.chainId === chainId);
      if (chain) {
        const JsonRpcProvider3 = new ethers_exports.providers.JsonRpcProvider(chain.rpcUrl, {
          chainId,
          name: chain.name
        });
        if (JsonRpcProvider3) {
          const balance = await JsonRpcProvider3.getBalance(address);
          const formattedBalance = utils_exports.formatEther(balance);
          this.setBalance(formattedBalance, chain.currency);
        }
      }
    }
  }
  async switchNetwork(chainId) {
    var _a2, _b, _c, _d, _e4, _f, _g, _h;
    const provider = ProviderController.state.provider;
    const providerType = ProviderController.state.providerType;
    if (this.chains) {
      const chain = this.chains.find((c5) => c5.chainId === chainId);
      if (providerType === ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID && chain) {
        const WalletConnectProvider = provider == null ? void 0 : provider.provider;
        if (WalletConnectProvider) {
          try {
            await WalletConnectProvider.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: numberToHexString(chain.chainId) }]
            });
            ProviderController.setChainId(chainId);
          } catch (switchError) {
            if (switchError.code === ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === ERROR_CODE_DEFAULT || ((_b = (_a2 = switchError == null ? void 0 : switchError.data) == null ? void 0 : _a2.originalError) == null ? void 0 : _b.code) === ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await addEthereumChain(WalletConnectProvider, chain, ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID);
            } else {
              throw new Error("Chain is not supported");
            }
          }
        }
      } else if (providerType === ConstantsUtil2.INJECTED_CONNECTOR_ID && chain) {
        const InjectedProvider = provider;
        if (InjectedProvider) {
          try {
            await InjectedProvider.send("wallet_switchEthereumChain", [
              { chainId: numberToHexString(chain.chainId) }
            ]);
            ProviderController.setChainId(chain.chainId);
          } catch (switchError) {
            if (switchError.code === ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === ERROR_CODE_DEFAULT || ((_d = (_c = switchError == null ? void 0 : switchError.data) == null ? void 0 : _c.originalError) == null ? void 0 : _d.code) === ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await addEthereumChain(InjectedProvider, chain, ConstantsUtil2.INJECTED_CONNECTOR_ID);
            } else {
              throw new Error("Chain is not supported");
            }
          }
        }
      } else if (providerType === ConstantsUtil2.EIP6963_CONNECTOR_ID && chain) {
        const EIP6963Provider = provider;
        if (EIP6963Provider) {
          try {
            await EIP6963Provider.send("wallet_switchEthereumChain", [
              { chainId: numberToHexString(chain.chainId) }
            ]);
            ProviderController.setChainId(chain.chainId);
          } catch (switchError) {
            if (switchError.code === ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === ERROR_CODE_DEFAULT || ((_f = (_e4 = switchError == null ? void 0 : switchError.data) == null ? void 0 : _e4.originalError) == null ? void 0 : _f.code) === ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await addEthereumChain(EIP6963Provider, chain, ConstantsUtil2.INJECTED_CONNECTOR_ID);
            } else {
              throw new Error("Chain is not supported");
            }
          }
        }
      } else if (providerType === ConstantsUtil2.COINBASE_CONNECTOR_ID && chain) {
        const CoinbaseProvider = provider;
        if (CoinbaseProvider) {
          try {
            await CoinbaseProvider.send("wallet_switchEthereumChain", [
              { chainId: numberToHexString(chain.chainId) }
            ]);
            ProviderController.setChainId(chain.chainId);
          } catch (switchError) {
            if (switchError.code === ERROR_CODE_UNRECOGNIZED_CHAIN_ID || switchError.code === ERROR_CODE_DEFAULT || ((_h = (_g = switchError == null ? void 0 : switchError.data) == null ? void 0 : _g.originalError) == null ? void 0 : _h.code) === ERROR_CODE_UNRECOGNIZED_CHAIN_ID) {
              await addEthereumChain(CoinbaseProvider, chain, ConstantsUtil2.INJECTED_CONNECTOR_ID);
            }
          }
        }
      }
    }
  }
  syncConnectors(config2) {
    var _a2, _b, _c, _d, _e4, _f;
    const w3mConnectors = [];
    const connectorType = PresetsUtil.ConnectorTypesMap[ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID];
    if (connectorType) {
      w3mConnectors.push({
        id: ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID,
        explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID],
        imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID],
        imageUrl: (_b = (_a2 = this.options) == null ? void 0 : _a2.connectorImages) == null ? void 0 : _b[ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID],
        name: PresetsUtil.ConnectorNamesMap[ConstantsUtil2.WALLET_CONNECT_CONNECTOR_ID],
        type: connectorType
      });
    }
    if (config2.injected) {
      const injectedConnectorType = PresetsUtil.ConnectorTypesMap[ConstantsUtil2.INJECTED_CONNECTOR_ID];
      if (injectedConnectorType) {
        w3mConnectors.push({
          id: ConstantsUtil2.INJECTED_CONNECTOR_ID,
          explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil2.INJECTED_CONNECTOR_ID],
          imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil2.INJECTED_CONNECTOR_ID],
          imageUrl: (_d = (_c = this.options) == null ? void 0 : _c.connectorImages) == null ? void 0 : _d[ConstantsUtil2.INJECTED_CONNECTOR_ID],
          name: PresetsUtil.ConnectorNamesMap[ConstantsUtil2.INJECTED_CONNECTOR_ID],
          type: injectedConnectorType
        });
      }
    }
    if (config2.coinbase) {
      w3mConnectors.push({
        id: ConstantsUtil2.COINBASE_CONNECTOR_ID,
        explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil2.COINBASE_CONNECTOR_ID],
        imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil2.COINBASE_CONNECTOR_ID],
        imageUrl: (_f = (_e4 = this.options) == null ? void 0 : _e4.connectorImages) == null ? void 0 : _f[ConstantsUtil2.COINBASE_CONNECTOR_ID],
        name: PresetsUtil.ConnectorNamesMap[ConstantsUtil2.COINBASE_CONNECTOR_ID],
        type: "EXTERNAL"
      });
    }
    this.setConnectors(w3mConnectors);
  }
  eip6963EventHandler(event) {
    var _a2, _b;
    if (event.detail) {
      const { info, provider } = event.detail;
      const connectors = this.getConnectors();
      const existingConnector = connectors.find((c5) => c5.name === info.name);
      if (!existingConnector) {
        const eip6963Provider = provider;
        const web3provider = new ethers_exports.providers.Web3Provider(eip6963Provider, "any");
        const type2 = PresetsUtil.ConnectorTypesMap[ConstantsUtil2.EIP6963_CONNECTOR_ID];
        if (type2) {
          this.addConnector({
            id: ConstantsUtil2.EIP6963_CONNECTOR_ID,
            type: type2,
            imageUrl: info.icon ?? ((_b = (_a2 = this.options) == null ? void 0 : _a2.connectorImages) == null ? void 0 : _b[ConstantsUtil2.EIP6963_CONNECTOR_ID]),
            name: info.name,
            provider: web3provider,
            info
          });
          const eip6963ProviderObj = {
            name: info.name,
            provider: web3provider
          };
          this.EIP6963Providers.push(eip6963ProviderObj);
        }
      }
    }
  }
  listenConnectors(enableEIP6963) {
    if (typeof window !== "undefined" && enableEIP6963) {
      const handler = this.eip6963EventHandler.bind(this);
      window.addEventListener(ConstantsUtil2.EIP6963_ANNOUNCE_EVENT, handler);
      window.dispatchEvent(new Event(ConstantsUtil2.EIP6963_REQUEST_EVENT));
    }
  }
};

// node_modules/@web3modal/polyfills/dist/esm/index.js
var import_buffer = __toESM(require_buffer2());
var _a;
if (typeof window !== "undefined") {
  if (!window.Buffer) {
    window.Buffer = import_buffer.Buffer;
  }
  if (!window.global) {
    window.global = window;
  }
  if (!window.process) {
    window.process = {};
  }
  if (!((_a = window.process) == null ? void 0 : _a.env)) {
    window.process = { env: {} };
  }
}

// node_modules/@web3modal/ethers5/dist/esm/src/utils/defaultConfig.js
var import_wallet_sdk = __toESM(require_dist5(), 1);
function defaultConfig(options) {
  const { enableEIP6963 = true, enableInjected = true, enableCoinbase = true, metadata, rpcUrl, defaultChainId } = options;
  let injectedProvider = void 0;
  let coinbaseProvider = void 0;
  const providers = { metadata };
  function getInjectedProvider() {
    if (injectedProvider) {
      return injectedProvider;
    }
    if (typeof window === "undefined") {
      return void 0;
    }
    if (!window.ethereum) {
      return void 0;
    }
    injectedProvider = new ethers_exports.providers.Web3Provider(window.ethereum, "any");
    return injectedProvider;
  }
  function getCoinbaseProvider() {
    if (coinbaseProvider) {
      return coinbaseProvider;
    }
    if (typeof window === "undefined") {
      return void 0;
    }
    const coinbaseWallet = new import_wallet_sdk.CoinbaseWalletSDK({
      appName: metadata.name,
      appLogoUrl: metadata.icons[0],
      darkMode: false
    });
    const coinbaseWalletProvider = coinbaseWallet.makeWeb3Provider(rpcUrl, defaultChainId);
    coinbaseProvider = new ethers_exports.providers.Web3Provider(coinbaseWalletProvider, "any");
    return coinbaseProvider;
  }
  if (enableInjected) {
    providers.injected = getInjectedProvider();
  }
  if (enableCoinbase && rpcUrl && defaultChainId) {
    providers.coinbase = getCoinbaseProvider();
  }
  if (enableEIP6963) {
    providers.EIP6963 = true;
  }
  return providers;
}

// node_modules/@web3modal/ethers5/dist/esm/exports/index.js
function createWeb3Modal(options) {
  return new Web3Modal({ ...options, _sdkVersion: `html-ethers5-${ConstantsUtil2.VERSION}` });
}
export {
  createWeb3Modal,
  defaultConfig
};
/*! Bundled license information:

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@walletconnect/universal-provider/dist/index.es.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=@web3modal_ethers5.js.map
